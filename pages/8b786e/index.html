<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>依赖注入 | kaokei&#39;s blog</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/img/favicon.ico">
    <script data-ad-client="ca-pub-3912182864105528" async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="description" content="web前端技术博客,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,React,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="code-JzonidIhwe">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.8c222d0c.css" as="style"><link rel="preload" href="/assets/js/app.ab008859.js" as="script"><link rel="preload" href="/assets/js/2.057a5450.js" as="script"><link rel="preload" href="/assets/js/56.8c0d939b.js" as="script"><link rel="prefetch" href="/assets/js/10.a760bf9e.js"><link rel="prefetch" href="/assets/js/11.595bbd7a.js"><link rel="prefetch" href="/assets/js/12.00437c60.js"><link rel="prefetch" href="/assets/js/13.bef0adce.js"><link rel="prefetch" href="/assets/js/14.a4f7a027.js"><link rel="prefetch" href="/assets/js/15.c8d40d97.js"><link rel="prefetch" href="/assets/js/16.c860bd59.js"><link rel="prefetch" href="/assets/js/17.7f554190.js"><link rel="prefetch" href="/assets/js/18.7284de15.js"><link rel="prefetch" href="/assets/js/19.2f703eed.js"><link rel="prefetch" href="/assets/js/20.8d3cc40d.js"><link rel="prefetch" href="/assets/js/21.5603e41e.js"><link rel="prefetch" href="/assets/js/22.9f77deef.js"><link rel="prefetch" href="/assets/js/23.b5a26126.js"><link rel="prefetch" href="/assets/js/24.5b7867c6.js"><link rel="prefetch" href="/assets/js/25.db369c78.js"><link rel="prefetch" href="/assets/js/26.deb529cd.js"><link rel="prefetch" href="/assets/js/27.49f1c7d5.js"><link rel="prefetch" href="/assets/js/28.dcb57436.js"><link rel="prefetch" href="/assets/js/29.8e8aa6a4.js"><link rel="prefetch" href="/assets/js/3.f4d237ff.js"><link rel="prefetch" href="/assets/js/30.4e05497d.js"><link rel="prefetch" href="/assets/js/31.242c64c3.js"><link rel="prefetch" href="/assets/js/32.694f52c9.js"><link rel="prefetch" href="/assets/js/33.fa271ad6.js"><link rel="prefetch" href="/assets/js/34.cf83d59c.js"><link rel="prefetch" href="/assets/js/35.57ea62e0.js"><link rel="prefetch" href="/assets/js/36.703c15da.js"><link rel="prefetch" href="/assets/js/37.6f53098e.js"><link rel="prefetch" href="/assets/js/38.616e0ee3.js"><link rel="prefetch" href="/assets/js/39.bec526ad.js"><link rel="prefetch" href="/assets/js/4.8bcf114c.js"><link rel="prefetch" href="/assets/js/40.f4e189c0.js"><link rel="prefetch" href="/assets/js/41.83f4eeef.js"><link rel="prefetch" href="/assets/js/42.da09d14e.js"><link rel="prefetch" href="/assets/js/43.4440e84d.js"><link rel="prefetch" href="/assets/js/44.e0236475.js"><link rel="prefetch" href="/assets/js/45.bf004714.js"><link rel="prefetch" href="/assets/js/46.e49cf645.js"><link rel="prefetch" href="/assets/js/47.57af564a.js"><link rel="prefetch" href="/assets/js/48.425b2abd.js"><link rel="prefetch" href="/assets/js/49.6ccef877.js"><link rel="prefetch" href="/assets/js/5.b21fd5e0.js"><link rel="prefetch" href="/assets/js/50.36ea4e95.js"><link rel="prefetch" href="/assets/js/51.5e341df4.js"><link rel="prefetch" href="/assets/js/52.77e96512.js"><link rel="prefetch" href="/assets/js/53.3765b567.js"><link rel="prefetch" href="/assets/js/54.393308af.js"><link rel="prefetch" href="/assets/js/55.49445590.js"><link rel="prefetch" href="/assets/js/57.83d20f17.js"><link rel="prefetch" href="/assets/js/58.2eea3d88.js"><link rel="prefetch" href="/assets/js/59.e1b71115.js"><link rel="prefetch" href="/assets/js/6.a9936221.js"><link rel="prefetch" href="/assets/js/60.58f58ea4.js"><link rel="prefetch" href="/assets/js/61.4117d0c3.js"><link rel="prefetch" href="/assets/js/62.c74dc220.js"><link rel="prefetch" href="/assets/js/63.3b95bd1f.js"><link rel="prefetch" href="/assets/js/64.eabf7d16.js"><link rel="prefetch" href="/assets/js/65.8715bfaf.js"><link rel="prefetch" href="/assets/js/66.d662d045.js"><link rel="prefetch" href="/assets/js/67.f5a8dc44.js"><link rel="prefetch" href="/assets/js/68.f8581ffe.js"><link rel="prefetch" href="/assets/js/69.e983212e.js"><link rel="prefetch" href="/assets/js/7.7091358f.js"><link rel="prefetch" href="/assets/js/70.81048b4e.js"><link rel="prefetch" href="/assets/js/71.eba5be4e.js"><link rel="prefetch" href="/assets/js/72.55e8f06e.js"><link rel="prefetch" href="/assets/js/73.f49cc1f2.js"><link rel="prefetch" href="/assets/js/74.4c3ba4fb.js"><link rel="prefetch" href="/assets/js/75.9ca668cc.js"><link rel="prefetch" href="/assets/js/76.f51753f4.js"><link rel="prefetch" href="/assets/js/77.8bcc8593.js"><link rel="prefetch" href="/assets/js/78.36c68f0f.js"><link rel="prefetch" href="/assets/js/79.22a68813.js"><link rel="prefetch" href="/assets/js/8.bbda885c.js"><link rel="prefetch" href="/assets/js/80.8bdb3edb.js"><link rel="prefetch" href="/assets/js/81.a035fa17.js"><link rel="prefetch" href="/assets/js/9.0718fc25.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8c222d0c.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open no-sidebar have-rightmenu have-body-img"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.svg" alt="kaokei's blog" class="logo"> <span class="site-name can-hide">kaokei's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目文档" class="dropdown-title"><a href="/project/" class="link-title">项目文档</a> <span class="title" style="display:none;">项目文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/project/di/" class="nav-link">di</a></li><li class="dropdown-item"><!----> <a href="/project/use-vue-service/" class="nav-link">use-vue-service</a></li><li class="dropdown-item"><!----> <a href="/project/use-react-service/" class="nav-link">use-react-service</a></li><li class="dropdown-item"><!----> <a href="/project/use-solid-service/" class="nav-link">use-solid-service</a></li><li class="dropdown-item"><!----> <a href="/project/use-svelte-service/" class="nav-link">use-svelte-service</a></li></ul></div></div><div class="nav-item"><a href="/categories/" class="nav-link">分类</a></div><div class="nav-item"><a href="/tags/" class="nav-link">标签</a></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div> <a href="https://github.com/kaokei/kaokei.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://cdn.jsdelivr.net/gh/kaokei/static-cdn/logo/white/logo@512.png"> <div class="blogger-info"><h3></h3> <span></span></div></div> <nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目文档" class="dropdown-title"><a href="/project/" class="link-title">项目文档</a> <span class="title" style="display:none;">项目文档</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/project/di/" class="nav-link">di</a></li><li class="dropdown-item"><!----> <a href="/project/use-vue-service/" class="nav-link">use-vue-service</a></li><li class="dropdown-item"><!----> <a href="/project/use-react-service/" class="nav-link">use-react-service</a></li><li class="dropdown-item"><!----> <a href="/project/use-solid-service/" class="nav-link">use-solid-service</a></li><li class="dropdown-item"><!----> <a href="/project/use-svelte-service/" class="nav-link">use-svelte-service</a></li></ul></div></div><div class="nav-item"><a href="/categories/" class="nav-link">分类</a></div><div class="nav-item"><a href="/tags/" class="nav-link">标签</a></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div> <a href="https://github.com/kaokei/kaokei.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>依赖注入</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/8b786e/#doux" class="sidebar-link">doux</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/8b786e/#dob" class="sidebar-link">dob</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/8b786e/#dob-react" class="sidebar-link">dob-react</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/8b786e/#concent" class="sidebar-link">concent</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/8b786e/#nx-js-observer-util" class="sidebar-link">@nx-js/observer-util</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/8b786e/#preact-nx-observer" class="sidebar-link">preact-nx-observer</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/8b786e/#react-easy-state" class="sidebar-link">react-easy-state</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/8b786e/#mobx" class="sidebar-link">mobx</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/8b786e/#vue-next" class="sidebar-link">vue-next</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/8b786e/#constate" class="sidebar-link">constate</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/8b786e/#react-类组件-vs-vue-类组件" class="sidebar-link">react 类组件 vs vue 类组件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/8b786e/#总结" class="sidebar-link">总结</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><!----> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="javascript:;" data-v-06225672>kaokei</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2021-12-19</a></div> <div title="分类" class="date iconfont icon-wenjian" data-v-06225672><a href="/categories/?category=%E9%9A%8F%E7%AC%94" data-v-06225672>随笔 </a><a href="/categories/?category=%E6%8A%80%E6%9C%AF" data-v-06225672>技术 </a></div></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">依赖注入<!----></h1>  <div class="theme-vdoing-content content__default"><h2 id="doux"><a href="#doux" class="header-anchor">#</a> doux</h2> <p>该库似乎已经被删除了，但是历史代码还存在，代码实现比较简单，非常方便入门分析。</p> <p>observable 相当于 reactive
observe 相当于 watch
observer 相当于 watchEffect</p> <p>其实 observable 和另外两个是比较独立的，可以独立分析。</p> <p>observable 在 get/ownKeys/has 三个方法中会调用 track 方法来收集依赖。在 set/deleteProperty 这个两个方法中会调用 trigger 方法来触发副作用。</p> <p>对比 track 和 trigger 的参数部分，主要是通过 target+key 这两个参数作为链接的桥梁。简单的理解为在 track 时，把 activeEffect 存储到 target+key 对应的 map 中，当 trigger 发生时就可以通过 target+key 来获取曾经保存的 activeEffect，然后执行它。关键点在于 activeEffect 是一个运行时产生的，observable 本身是不依赖它的。</p> <p>提到 activeEffect，它是怎么产生的呢？其实就是由 observe 产生的。observe 的返回值就是 effect。
其中这段代码说明了 activeEffect 是怎么产生的：</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code>effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span><span class="token punctuation">;</span>
activeEffect <span class="token operator">=</span> effect<span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token function">Reflect</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> ctx<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>其中<code>fn</code>就是我们想要观察的代码，想要收集依赖的代码。所以在执行该代码之前，我们提前准备好 activeEffect。</p> <p>observer 主要是实现了对组件的观察，主要是判断 effect 是否有 cb 属性。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code>effects<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token operator">:</span> Effect<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token function">isFn</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>cb<span class="token punctuation">)</span> <span class="token operator">?</span> e<span class="token punctuation">.</span><span class="token function">cb</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">e</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="dob"><a href="#dob" class="header-anchor">#</a> dob</h2> <p>首先查看最简单的例子。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> observable<span class="token punctuation">,</span> observe <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;dob&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">observable</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">debugger</span><span class="token punctuation">;</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;obj.a has changed to&quot;</span><span class="token punctuation">,</span> obj<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;· obj.a has changed to 1</span>

obj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// &lt;· obj.a has changed to 2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>首先 observable 会把一个普通对象转变为 Proxy 对象。主要是 get/set/deleteProperty 这三个属性。这种转变只是为了后续作服务的。</p> <p>当执行 observe 函数时，类似于 vue-next 中的 watchEffect，它是立即执行的。关键在于 Reaction 中有一段代码是这样的。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code>global_state_1<span class="token punctuation">.</span>globalState<span class="token punctuation">.</span>currentReaction <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// Clear bindings first.</span>

<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">clearBinding</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    debugId<span class="token operator">:</span> global_state_1<span class="token punctuation">.</span>globalState<span class="token punctuation">.</span>currentDebugId
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
  global_state_1<span class="token punctuation">.</span>globalState<span class="token punctuation">.</span>currentReaction <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>这段代码是非常经典的，首先设置当前的依赖项 currentReaction，然后执行 callback，再清除 currentReaction。这样在执行 callback 的过程中，会触发 observable 中设置的 getter 函数。会把 currentReaction 当作所有数据的依赖。关键代码在<code>bindCurrentReaction</code>中实现。</p> <p>相应的当我们执行<code>obj.a = 2</code>时，会触发 Proxy 的 setter 函数，会调用 queueRunReactions 从而找到刚才保存下来的 currentReaction，然后就可以<code>runReaction(currentReaction)</code>。</p> <p>重点需要关注<code>Reaction</code>的实现，类似于 vue-next 中的<code>effect</code>的实现。</p> <p>另一个比较重要的点是这个库非常依赖全局状态管理，主要集中在 global-state.ts 文件中，尤其是其中的 objectReactionBindings 这个对象。它全局保存了数据和 Reaction 的依赖关系。</p> <p>依赖<code>dependency-inject</code>实现依赖注入的功能。</p> <h2 id="dob-react"><a href="#dob-react" class="header-anchor">#</a> dob-react</h2> <p>主要是提供了 Provider 和 Connect 这两个方法。可以在 Provider 这个组件上声明任意多个 props，这些 props 数据都会被注入到<code>@Connect</code>装饰的组件中。</p> <p>也就是说我们自己写的组件如果使用了<code>@Connect</code>装饰器，那么组件内<code>this.props</code>就会自动被注入一些属性，这些属性就是 Provider 上声明的属性。</p> <p>目前发现的唯一路径是这样的。<code>observe</code>调用<code>new Reaction</code>调用<code>设置currentReaction</code>，然后在访问 getter 时，就会把数据和 currentReaction 绑定起来，也就是<code>bindCurrentReaction</code>。</p> <p>在 dob 中只能通过<code>observe</code>才能实现依赖收集。在<code>dob-react</code>中，有以下流程：
<code>@connect</code>调用<code>mixinAndInject</code>调用<code>mixinLifecycleEvents</code>调用<code>patch</code>调用<code>reactiveMixin</code>调用<code>initialRender</code>调用<code>new Reaction</code>，从而把组件的 render 函数和数据绑定起来。</p> <p>当然最终的实现部分还是需要注意<code>baseRender</code>和<code>initialRender</code>和<code>reactiveRender</code>之间的关系。</p> <h2 id="concent"><a href="#concent" class="header-anchor">#</a> concent</h2> <p>这是一个框架，而且功能非常强大，并且更新非常活跃。同时支持类组件和函数组件。唯一我不太喜欢的地方可能就是过于复杂了，上手成本有点高，再加上使用字符串来区分模块也是一个原罪。不过它仍然是一个非常优秀的框架。</p> <p>我这里重点关注一下 register 和 useConcent 是如何实现组件的响应式更新的。</p> <p>参考官方文档中<a href="https://concentjs.github.io/concent-doc/api-much-used/useConcent" target="_blank" rel="noopener noreferrer">最简单的例子<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> state<span class="token punctuation">,</span> setState <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useConcent</span><span class="token punctuation">(</span><span class="token punctuation">{</span> module<span class="token operator">:</span> <span class="token string">&quot;foo&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">changeName</span> <span class="token operator">=</span> e <span class="token operator">=&gt;</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>可以猜测到 useConcent 本身是不需要做依赖收集的。因为我们还是需要手动调用<code>setState</code>方法去更新数据，这时可以强制调用<code>forseUpdate</code>方法去更新组件。</p> <p>分析源码可知，useConcent 返回值是一个<code>CcHook</code>的实例对象。这个实例对象的 state 和 setState 就是<code>React.useState</code>的返回值。综上 useConcent 就是对<code>React.useState</code>的封装，说明我猜测的没有错。</p> <p>我还发现 useConcent 是不支持直接 mutable 修改 state 数据的，只能通过 setState 来修改数据。make-ob-state.js 中的 setter 中是没有 trigger 方法的，说明确实没有实现 mutable 响应式。</p> <p>当然 useConcent 是需要做到多个组件共享数据的，也就是一个组件修改了数据，可能会影响到别的组件。</p> <p>useConcent 调用 buildRef 调用 buildRefCtx，其中 buildRefCtx 会修改 ref.state 属性，该属性会合并当前组件的 state 和 moduleState。这就是 useConcent 从全局获取 moduleState 的过程。</p> <p>至于 moduleState 状态的改变，是如何改变所有依赖这个 moduleState 所有组件的稍微复杂一些。</p> <p>build-ref-ctx.js 中使用了 makeObState 处理了 state 数据， 从而利用 Proxy 的 getter 收集依赖。收集依赖的逻辑在 updateDep 函数中。主要是以下代码。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token comment">// 这个key代表着refCtx，从而可以利用这个refCtx来更新组件</span>
<span class="token keyword">const</span> ccUniqueKey <span class="token operator">=</span> refCtx<span class="token punctuation">.</span>ccUniqueKey<span class="token punctuation">;</span>
<span class="token comment">// 这个key代表着数据foo/count</span>
<span class="token keyword">const</span> waKey <span class="token operator">=</span> <span class="token function">makeWaKey</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 最终在wakey-ukey-map.js文件中把这两个key通过waKey2uKeyMap关联起来。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>当用户点击某个按钮，触发点击事件，然后调用 setState 去修改数据时，这个 setState 其实是在 build-ref-ctx.js 文件中定义的，最终会调用 changeState 调用 changeRefState。
changeRefState 会调用 triggerBroadcastState 会调用 broadcastState，其中有个重要的函数是 findUpdateRefs，这个函数会返回所有依赖了变更数据的 ref 的 key。有了这个 key，再加上我们还有全局的 ref 对象池。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token comment">// 获取全局ref对象池，是一个Record&lt;string, Ref&gt;的对象</span>
<span class="token keyword">const</span> ccUKey2ref <span class="token operator">=</span> ccContext<span class="token punctuation">.</span>ccUKey2ref<span class="token punctuation">;</span>
<span class="token comment">// 通过key和全局ref对象池，就能获取到ref对象</span>
<span class="token keyword">const</span> ref <span class="token operator">=</span> ccUKey2ref<span class="token punctuation">[</span>refKey<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 有了ref对象，就能触发这个ref上的setState方法，从而更新组件</span>
<span class="token function">triggerReactSetState</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>以上分析我是通过 debug 代码观察到  的整个过程。当然我只是观察了最简单的两个组件依赖同一个 module 的过程。</p> <p>我观察到的最大的结论是 useConcent 没有实现 Proxy 中的 setter 的响应式触发，也就是不支持 mutable 更新数据。第二点就是 concent 在保存数据和视图的依赖关系时，是通过保存 key 与 key 之间的依赖关系，而且还保存了全局的 ref 对象池。从而实现当某个数据变化时，多个依赖该数据的视图都能得到更新。相对应的在很多别的  库中，都是直接通过 map 来保存数据和 Dep 之间的依赖关系。</p> <p>register 作为一个装饰器，会包装一个类组件，然后返回一个新的类组件。只需要知道这一行代码即可。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token function">buildRefCtx</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> params<span class="token punctuation">,</span> lite<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>上面有提到的 useConcent 的核心代码就是<code>buildRefCtx(hookRef, params, lite);</code>，这行代码内部会重新包装 state 和 setState，从而可以支持 module 等特性。</p> <h2 id="nx-js-observer-util"><a href="#nx-js-observer-util" class="header-anchor">#</a> @nx-js/observer-util</h2> <p>observable 方法对应的是 reactive 方法，实现原理和 doux 比较一致，只是封装的更好一些。也是在不同的 handler 中处理 track 和 trigger。当然 track 和 trigger 需要处理的是 reaction，相当于 doux 中的 effect。</p> <p>observe 和 unobserve 则分别对应的是 watch 和 stopWatch 方法。注意这里使用<code>reaction.scheduler</code>代替了<code>reaction</code>。从而实现了从组件收集依赖和更新组件的分离。这一点和 doux 的<code>cb</code>属性是比较相似的。</p> <h2 id="preact-nx-observer"><a href="#preact-nx-observer" class="header-anchor">#</a> preact-nx-observer</h2> <p>observer 方法支持类组件，这里比较取巧的地方就是在 componentDidMount 中替换了 render 方法。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">this</span><span class="token punctuation">.</span>render <span class="token operator">=</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>render<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">scheduler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  lazy<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这一段代码还是比较巧妙的，但就是不知道兼容性如何。而且也没有支持函数组件。</p> <h2 id="react-easy-state"><a href="#react-easy-state" class="header-anchor">#</a> react-easy-state</h2> <p>store，以及 createStore 都是对 observable 的封装。只是增加了对<code>unstable_batchedUpdates</code>的支持。<a href="https://zhuanlan.zhihu.com/p/78516581" target="_blank" rel="noopener noreferrer">参考这片文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>view 则是对组件的封装。支持函数组件和类组件。</p> <p>注意类组件中是在构造函数中替换掉的 render 方法，对比<code>preact-nx-observer</code>是在 componentDidMount 中替换的。我认为在构造函数中替换更符合直觉。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token comment">// 针对函数组件的封装</span>
<span class="token keyword">const</span> render <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    <span class="token function">observe</span><span class="token punctuation">(</span>Comp<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">scheduler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      lazy<span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token comment">// Adding the original Comp here is necessary to make React Hot Reload work</span>
  <span class="token comment">// it does not affect behavior otherwise</span>
  <span class="token punctuation">[</span>Comp<span class="token punctuation">]</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token comment">// 针对类组件的封装</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>render <span class="token operator">=</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>render<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">scheduler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  lazy<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="mobx"><a href="#mobx" class="header-anchor">#</a> mobx</h2> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token comment">// 相当于vue-next中的reactive</span>
<span class="token function">makeObservable</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> annotations<span class="token operator">?</span><span class="token punctuation">,</span> options<span class="token operator">?</span><span class="token punctuation">)</span>
<span class="token function">makeAutoObservable</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> overrides<span class="token operator">?</span><span class="token punctuation">,</span> options<span class="token operator">?</span><span class="token punctuation">)</span>
<span class="token function">observable</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> overrides<span class="token operator">?</span><span class="token punctuation">,</span> options<span class="token operator">?</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>需要指定<code>@observable</code>,<code>@action</code>,<code>@computed</code>等来指定各个属性的性质。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token comment">// 相当于vue-next中的watch</span>
<span class="token function">reaction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> value<span class="token punctuation">,</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> previousValue<span class="token punctuation">,</span> reaction<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> sideEffect <span class="token punctuation">}</span><span class="token punctuation">,</span> options<span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token comment">// 相当于vue-next中的watchEffect</span>
<span class="token function">autorun</span><span class="token punctuation">(</span><span class="token function-variable function">effect</span><span class="token operator">:</span> <span class="token punctuation">(</span>reaction<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token comment">// 对组件的封装</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> observer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;mobx-react-lite&quot;</span><span class="token punctuation">;</span> <span class="token comment">// Or &quot;mobx-react&quot;.</span>
<span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token function">observer</span><span class="token punctuation">(</span>props <span class="token operator">=&gt;</span> ReactElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里的 observer 功能非常强大，只要组件依赖了 observable 数据，不管这个<a href="https://mobx.js.org/react-integration.html#local-and-external-state" target="_blank" rel="noopener noreferrer">数据的来源<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>是什么，都能触发组件重新渲染。</p> <p>尤其是对各种情况都考虑的非常周全，值得学习。</p> <h2 id="vue-next"><a href="#vue-next" class="header-anchor">#</a> vue-next</h2> <p>整个流程比较像<code>@nx-js/observer-util</code>，reactive 也是借助的 Proxy 来实现的，关键是 baseHandler 的实现。然后利用 track 来收集依赖。依赖被转为 effect，又有 activeEffect 和 effectStack 这些概念。</p> <p>可惜我只想依赖其中的@vue/reactivity 这个库。但是 watch/watchEffect 这两个方法都不包含在内，因为 watch 和 watchEffect 都是和 vue 深度绑定的。</p> <p>所以如果想要在 react 中使用，则必须实现自己的 watch/watchEffect 方法。</p> <p>我理解广义 watch 的 api 形式有这 3 种场景：</p> <ol><li>指定需要 watch 的数据，可以是对象、数组、函数形式指定依赖数据，当数据有变化时，执行 callback</li> <li>指定一个 effect，第一次立即执行时会收集依赖，后续当这些依赖数据有变化的时候，会再次执行这个 effect</li> <li>指定 effect 和 callback，当 effect 对应的依赖有变化的时候，会执行 callback</li></ol> <p>很容易发现在 vue-next 中已经实现了<code>watch</code>和<code>watchEffect</code>方法，但是实际上在 dowatch 中，又一个细节实现：</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">const</span> runner <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>getter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  lazy<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  onTrack<span class="token punctuation">,</span>
  onTrigger<span class="token punctuation">,</span>
  scheduler
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这段代码可以理解为观察 getter 返回的数据是否有变化，如果有变化就执行 scheduler。这就是上面提到的第 3 中 api。而且 1 和 2 就是依赖 3 来实现的。
当 watch 的数据本身看作是一个 getter 时，1 就变成 3 了。
当 effect 等于 callback 时，2 就是 3 的一种特殊形式。
需要注意这里的 3 中的 effect 和 callback 不是完全独立的。如果是完全独立的，应该采用 1 这种形式以 getter 的形式提供观察的数据，而不是以 effect 的形式提供依赖数据。观察如下代码：</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token comment">// 这里的本意是当state.count变化时，输出state.name</span>
<span class="token comment">// 但是这里不应该这么写</span>
<span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 这里明确以getter的形式提供依赖数据</span>
<span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count<span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>3 的场景可能是这样的。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token comment">// renderView是渲染试图的函数，也是我们观察的effect，当其依赖的数据有变化时，我们可能没有办法直接调用renderView这个函数</span>
<span class="token comment">// 我们只能通过另一个函数forceUpdate来触发视图更新</span>
<span class="token function">watch</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">renderView</span><span class="token punctuation">(</span>someView<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">forceUpdate</span><span class="token punctuation">(</span>someView<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="constate"><a href="#constate" class="header-anchor">#</a> constate</h2> <p><a href="https://github.com/diegohaz/constate" target="_blank" rel="noopener noreferrer">github 网址<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>我想实现的库可以看作是 constate 的升级版。现在 constate 只是把 hooks 都放到一个全局的空间中。然后达到所有组件可以共享这个 hooks 的状态。</p> <p>缺点是只有一个全局命名空间。而且服务的形式只能是 hooks，没有依赖注入，没有 mutable 响应式。</p> <p>优点是简单，而且只依赖 hooks 和 context，应该是兼容并发模式的。</p> <h2 id="react-类组件-vs-vue-类组件"><a href="#react-类组件-vs-vue-类组件" class="header-anchor">#</a> react 类组件 vs vue 类组件</h2> <p>react 类组件是官方原生支持的，实例属性不是 reactive 的，只有通过 this.setState 修改 this.state 才会 re-render。</p> <p>vue 类组件必须借助 vue-class-component 才能工作，其原理也是转化为 Option 组件。其中所有实例属性都是 reactive 的。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>doux 使用函数组件包裹业务组件，也可以看作是<code>observe</code>函数的返回值作为 this.render
preact-nx-observer 是<code>observe</code>直接返回新的 render 函数替换 this.render
react-easy-state 也是直接替换的 this.render
dob-react 是需要自己构建新的 render 函数去替换 this.render
concent 主要是对<code>setState</code>的封装，而且不支持 mutable 响应式
mobx 再看看
vue-next 中的 render 函数默认就会收集依赖的，而且会把 render 函数当作一个 watchEffect 来对待</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/kaokei/kaokei.github.io/edit/docs/docs/_posts/reactive-analysis.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="tags"><a href="/tags/?tag=todo" title="标签">#todo</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/06/15, 15:55:13</span></div></div> <div class="page-nav-wapper"><!----> <!----></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/c1a9df/"><div>
            前端和后端的思考
            <!----></div></a> <span class="date">06-15</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/31f626/"><div>
            小规模纳税人报税
            <!----></div></a> <span class="date">06-15</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/c70da9/"><div>
            资源
            <!----></div></a> <span class="date">02-18</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2022
    <span>kaokei | <a href="https://github.com/kaokei/kaokei.github.io/blob/docs/LICENSE" target="_blank">kaokei License</a> | <a href="https://beian.miit.gov.cn/" target="_blank">京ICP备16051049号</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <div class="body-bg" style="background:url() center center / cover no-repeat;opacity:0.5;"></div> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.ab008859.js" defer></script><script src="/assets/js/2.057a5450.js" defer></script><script src="/assets/js/56.8c0d939b.js" defer></script>
  </body>
</html>
