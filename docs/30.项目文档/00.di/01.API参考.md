---
title: API参考
date: 2021-12-19 20:48:09
permalink: /pages/64784b/
categories:
  - 项目文档
  - di
tags:
  -
---

# API 参考

## Injector

本身是一个类，提供了依赖注入的核心功能。

主要逻辑是通过配置 providers 来生成 injector 实例，然后通过 `injector.get` 来自动化获取服务实例，从而避免手动维护依赖关系。

参数：

第一个参数：providers，代表 provider 的配置信息，类型是数组

第二个参数：parent，代表父级 injector，类型还是 Injector

第三个参数：options，代表 injector 的配置属性，类型是一个普通对象

::: tip
options.beforeCacheHook

这个配置项是一个函数，作用是在缓存服务对象之前的一个钩子。目前是用来是服务对象响应化。

options.mergePropertyHook

这个配置项是一个函数，作用是通过@Inject 注入的属性需要合并到类实例上。目前主要还是为了通过这个钩子保持属性合并后的响应能力。
:::

用法：

```ts
const injector = new Injector([
  SomeClass,
  {
    provide: someUseValueToken,
    useValue: 'someValue',
  },
  {
    provide: someUseClassToken,
    useClass: SomeClass,
  },
  {
    provide: someUseExistingToken,
    useExisting: AnotherExistingToken,
  },
  {
    provide: someUseFactoryToken,
    useFactory: (dep1, dep2, dep3...) => {
      return someValue
    },
    deps: [dep1Token, dep2Token, dep3Token...],
  },
]);

const service1 = injector.get(SomeClass);
const service2 = injector.get(someUseValueToken);
const service3 = injector.get(someUseClassToken);
const service4 = injector.get(someUseExistingToken);
const service5 = injector.get(someUseFactoryToken);
```

目前提供了以上 5 种配置 provider 的方式，这里主要是参考了 [Angular 的概念](https://angular.cn/guide/dependency-injection-providers)。

实际上@Injectable 也是另外一种配置 provider 的方式。只不过这种方式只会在`root injector`中生效。

## @Injectable

标志类是可注入的，只有通过`@Injectable`声明过的类才会参与到依赖注入的过程中。

参数：无

用法：

```ts
@Injectable()
export class LoggerService {
  public log(...msg: any[]) {
    console.log("from logger service ==>", ...msg);
  }
}
```

## @Inject

使用在类的构造函数的参数中和类的实例属性中，作用是手动声明该参数/属性的依赖注入的 token。

首先需要明确一点就是这个装饰器并不是必须的。而是作为某些场景的补充手段。

一般情况下如果指定构造函数的参数的类型/实例属性的类型是某个类。这时候依赖注入对应的 token 就是这个类，那么`@Inejct`就不是必须的。

但是如果参数类型/属性类型是 interface 或者基本类型。那么就必须要通过`@Inject`来手动指定依赖注入的 token 了。

因为这个时候默认获取到的 token 其实是 Object/Boolean/Number/String 这些构造函数。那么根据默认逻辑就是实例化这些类。

```ts
// 返回空对象{}
new Object();
// 返回Boolean(false)对象
new Boolean();
// 返回Number(0)对象
new Number();
// 返回String('')对象
new String();
```

以上这些实例化对象绝大多数场景并不会是我们想要的逻辑。所以需要借助`@Inject`来替换以上的默认逻辑。

参数：除了 js 中的 Falsy 的任意值，常见的比如类、字符串、Symbol。

用法：

```ts
type Theme = "white" | "black" | "dark" | "light";
const themeToken: Theme = Symbol();

@Injectable()
export class CountService {
  public count = 0;

  // 这里演示了实例属性的类型是一个类型，而不是一个类
  // 所以必须手动指定属性的依赖注入token是themeToken
  // 注意这里并没有演示具体怎么通过themeToken获取到真正的theme的逻辑，这个逻辑需要在Injector中配置
  @Inject(themeToken)
  public theme!: Theme;

  // 这里演示了@Inject注入一个类
  // 实际上这里并不需要使用@Inject，因为LoggerService本身就是一个类，所以默认就会注入LoggerService对应的类实例
  // 这里演示了通过@Inject手动配置依赖注入的token变成AnotherLoggerService，这里也体现了依赖注入的灵活性
  constructor(@Inject(AnotherLoggerService) private logger: LoggerService) {}

  public addOne() {
    this.count++;
    this.logger.log("addOne ==> ", this.count);
  }
}
```

## @Self

必须要意识到 Injector 最大的特色就是支持层级 Injector。直观的表述就是每一个 injector 都可以设置它的`parent injector`。

类似的数据结构就是 dom 树，每一个 dom 节点都可以有它的`parent node`。

正是因为层级结构，所以存在如下这样的逻辑。当我们调用如下代码时。

```ts
const injector = new Injector();
const parentInjector = new Injector();
injector.parent = parentInjector;
injector.get(LoggerService);
```

以上代码的执行逻辑是这样的，因为 injector 中并没有配置 LoggerService，所以在 injector 并不能提供相应的服务对象。

所以会自动进入 parentInjector 中寻找 LoggerService。虽然在 parentInjector 中也没有配置 LoggerService。

但是因为 parentInjector 已经没有 parent，也就是作为`root injector`，它会自动尝试实例化 LoggerService。

有了以上背景知识，就能理解`@Self`的作用了。就是强制指定`injector.get`只会在当前 injector 中寻找相应的服务，而不会从 parentInjector 中寻找服务。

参数：boolean | undefined，当不传参数时，默认为 true

用法：

```ts
@Injectable()
export class CountService {
  public count = 0;

  // 这里配置了@Self
  // 但是实际上还需要看Injector本身的配置
  // 也就是一定要保证当前injector中存在LoggerService配置
  constructor(@Self() private logger: LoggerService) {}

  public addOne() {
    this.count++;
    this.logger.log("addOne ==> ", this.count);
  }
}
```

::: tip
需要注意`@Self`作为一个装饰器，应该在类的构造函数的参数/类的实例属性上使用。
实际上`injector.get(token, options)`存在第二个参数`options`，这个 options 中可以指定 `self、skip、optional` 参数。

```ts
injector.get(LoggerService, { self: true, skip: true, optional: true });
```

实际上类的依赖注入的实现过程中就是调用的 injector.get 来实现的。也就是本库会把`@Self、@Skip、@Optional`这些装饰器转化为`injector.get`的第二个参数。

:::

## @Skip

基本作用类似`@Self`，只不过功能正好相反，一开始就会跳过当前 injector，而是直接从 parentInjector 中寻找服务。

参数：boolean | undefined，当不传参数时，默认为 true

用法：

```ts
@Injectable()
export class CountService {
  public count = 0;

  // 这里配置了@Skip
  // 但是实际上还需要看Injector的配置
  // 也就是一定要保证父级或者祖先injector中存在LoggerService配置
  constructor(@Skip() private logger: LoggerService) {}

  public addOne() {
    this.count++;
    this.logger.log("addOne ==> ", this.count);
  }
}
```

## @Optional

本库作为依赖注入工具，必须处理一个场景就是当本库找不到对应的服务的时候，应该怎么处理。

目前的处理逻辑是，默认会抛出`TokenNotFoundError`异常。

但是如果我们认为某个服务是可选的，可以配置`@Optional`，这样当本库找不到对应的服务的时候，就会返回 `undefined`，而不是抛出异常了。

参数：boolean | undefined，当不传参数时，默认为 true

用法：

```ts
@Injectable()
export class CountService {
  public count = 0;

  // 这里配置了@Optional
  // 所以logger应该是可选属性
  constructor(@Optional() private logger?: LoggerService) {}

  public addOne() {
    this.count++;
    // 因为this.logger可能是undefined
    // 所以应该使用可选调用?.
    this.logger?.log("addOne ==> ", this.count);
  }
}
```

## forwardRef

这个函数是为了解决`@Inject`的时候存在循环依赖的问题的。

参数：Function，类似这样的`() => someToken`

用法：

```ts
interface IA {
  name: string;
  b: IB;
}
interface IB {
  name: string;
  b: IA;
}
class A {
  public name = "A";
  // 类A依赖类B
  @Inject(forwardRef(() => B))
  public b!: IB;
}
class B {
  public name = "B";
  // 类B依赖类A
  @Inject(forwardRef(() => A))
  public a!: IA;
}
```

以上代码演示了 AB 两个类互相依赖，如果缺少 forwardRef，会导致代码编译失败。因为装饰器是立即执行的，所以导致 A 依赖 B 的时候，B 还没有准备好。

## InjectionKey

类似 vue 中的 InjectionKey，主要是为了解决类型推导的问题。

注意到 InjectionKey 不是一个函数，而是一个类型范型。

注意到类本身可以自己实例化，而且自带类型信息。但是对于字符串和 Symbol 是没有更多的业务类型信息的。

用法：

```ts
// 这里logger1自动推导为LoggerService类型
const logger1 = injector.get(LoggerService);

// 假设LoggerServiceStringToken这个token已经指向LoggerService
// 虽然运行时logger2确实是一个LoggerService类的实例
// 但是已经丢失了typescript的类型信息
const logger2 = injector.get("LoggerServiceStringToken");

const LoggerServiceStringTokenWithType: InjectionKey<LoggerService> =
  "LoggerServiceStringToken";
// 虽然logger3和logger2在运行时并没有什么区别，但是logger3已经可以推导出为LoggerService类型
const logger3 = injector.get(LoggerServiceStringTokenWithType);
```
