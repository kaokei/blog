---
title: 应用服务化
date: 2022-02-06 17:55:28
permalink: /pages/3a3a6b/
categories:
  - 项目文档
  - use-vue-service
tags:
  -
---

# 应用服务化

## 简介

在[基础教程](/pages/4497fd/)和[进阶教程](/pages/a03917/)中主要是介绍了 declareProviders 和 useService 这两个 API，不过在[API 文档](/pages/36ae88/)中还介绍了另外两个 API(declareRootProviders、useRootService)，本文主要是介绍为什么还需要这两个 API。

## 场景分析

基础教程和进阶教程可以解决 90%的问题，但是有些场景的问题是解决不了的。因为 declareProviders 和 useService 这两个 API 都有一个限制条件就是只能在组件的 setup 函数中使用，这就导致在组件之外或者应用创建之前等场景中不能使用。

我在实践过程中，发现有两个具体场景比较明显。

一个是在工具函数中，如果是无状态的工具函数倒也问题不大，但是如果是有状态的工具函数，就会导致状态的割裂，即有些状态是通过服务来维护，有些状态是在工具函数中维护，而且工具函数中的状态不是响应式的数据。这种割裂最大的问题是如果是服务依赖工具函数的状态，还可以直接 import 这个状态，但是如果工具函数依赖服务的状态，是没有办法直接 import 的。因为服务的初始化过程已经交给本库了，最终服务对应的实例化对象会存储在对应的 Injector 中了。工具函数只能 import 到服务对应定义的那个类而已。并不能直接 import 到那个实例化对象。

另一个是 router 的创建过程，一般我们会在单独的文件中创建 router 对象，然后导出这个对象，最终在`main.js`文件中创建应用。关键在于我们可能还会定义 router 的一些钩子方法。这些钩子方法可能会依赖一些服务的状态，这里也会像工具函数依赖服务状态一样无能为力。

## 解决方案

通过上面的分析，对应的解决方案也很明显了，就是最开始提到的 declareRootProviders 和 useRootService 这两个 API。

我们可以把有状态的工具函数和 router 的创建过程全部转化为服务，然后通过 declareRootProviders 定义为全局的服务，以及通过 useRootService 获取对应的服务对象。这样当这些服务依赖其他服务时，就可以直接通过本库的依赖注入的方式使用其他服务，这里的其他服务必须也是全局服务，因为全局服务只能依赖全局服务而不能依赖局部服务。

[参考示例](@todo)

::: tip 总结
整个应用的所有状态都需要通过服务来维护，不允许在工具函数和其他地方维护自己的状态。
除非是一次性状态或者非常明确的局部状态，这里就需要具体场景具体分析了。
:::

::: tip 注意
这个解决方案并不是银弹，即工具函数和 router 依赖的服务都必须是全局服务，如果它们依赖的不是全局服务，那么这个方案依然是行不通的。不过一般也不存在这种复杂的依赖关系。
:::

## 换一种角度思考

我了解到有些同学是这么开发 vue3 项目的，因为不愿意使用 vuex，所以只用到了 provide/inject 这两个 api 来实现依赖注入。
首先是维护一个全局的大对象，然后使用 reactive 使其变成响应式对象。然后使用`provide('globalKey', globalObject);`。这样在任意组件中我们都可以使用`inject('globalKey');`来获取这个`globalObject`对象，而且也可以直接在 vue 模版中使用这个对象的属性。因为属性也是响应式的。

以上方案可以看作是最简版的依赖注入实现了。注入的是一个全局对象，获取到的还是这个全局对象。

相对来说，declareRootProviders 和 useRootService 这两个 API 实现的是注入服务工厂，获取到的是通过服务工厂生产的服务对象。这其中有一个抽象到具体的生产过程。除此之外也没有什么差别。

再对比一下 declareProviders 和 useService 这两个 API 解决的就是全局问题，有时候我们的数据的生命周期并不是全局的，全局意味着生命周期是和整个应用的生命周期是一致的，只要应用还在，数据就存在。但是如果我们的数据是给某个路由子页面使用的，当路由切换时，理所应当这些数据应该被销毁。只有当我们再次进入该路由子页面，会重新生成数据。
