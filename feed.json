{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "kaokei's blog",
  "home_page_url": "https://www.kaokei.com/",
  "feed_url": "https://www.kaokei.com/feed.json",
  "author": {
    "name": "kaokei"
  },
  "items": [
    {
      "title": "Component disabled",
      "url": "https://www.kaokei.com/en/guide/disable/",
      "id": "https://www.kaokei.com/en/guide/disable/",
      "summary": "<p>You can disable some functions on the page by setting the Frontmatter of the page.</p>\n",
      "content_html": "<p>You can disable some functions on the page by setting the Frontmatter of the page.</p>\n\n<p>These should be disabled on this page:</p>\n<ul>\n<li>Navbar</li>\n<li>Sidebar</li>\n<li>Breadcrumb</li>\n<li>Page information</li>\n<li>Contributors</li>\n<li>Edit link</li>\n<li>Update time</li>\n<li>Prev/Next link</li>\n<li>Comment</li>\n<li>Footer</li>\n<li>Back to top button</li>\n</ul>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": [
        "Guide"
      ]
    },
    {
      "title": "Encryption article",
      "url": "https://www.kaokei.com/en/guide/encrypt/",
      "id": "https://www.kaokei.com/en/guide/encrypt/",
      "content_html": "<h1 id=\"encryption-article\"> Encryption article</h1>\n<p>The actual article content.</p>\n<p>Paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text paragraph 1 text.</p>\n<p>Paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text paragraph 2 text.</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": [
        "Guide"
      ]
    },
    {
      "title": "Markdown Enhance",
      "url": "https://www.kaokei.com/en/guide/markdown/",
      "id": "https://www.kaokei.com/en/guide/markdown/",
      "summary": "<p><code>vuepress-theme-hope</code> enables more syntax in Markdown via the built-in <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a> plugin.</p>\n",
      "content_html": "<p><code>vuepress-theme-hope</code> enables more syntax in Markdown via the built-in <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a> plugin.</p>\n\n<h2 id=\"enable-all\"> Enable all</h2>\n<p>You can set <code>themeconfig.mdEnhance.enableAll</code> to enable all features of the <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a> plugin.</p>\n<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  themeConfig<span>:</span> <span>{</span>\n    mdEnhance<span>:</span> <span>{</span>\n      enableAll<span>:</span> <span>true</span><span>,</span>\n    <span>}</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"new-feature\"> New Feature</h2>\n<h3 id=\"superscript-and-subscript\"> Superscript and Subscript</h3>\n<p>19<sup>th</sup> H<sub>2</sub>O</p>\n<details><summary>Code</summary>\n<div><pre><code>19^th^ H<span><span>~</span><span>2</span><span>~</span></span>O\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/sup-sub/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h3 id=\"align\"> Align</h3>\n<div>\n<p>I am center</p>\n</div>\n<div>\n<p>I am right align</p>\n</div>\n<details><summary>Code</summary>\n<div><pre><code>::: center\n\nI am center\n\n:::\n\n::: right\n\nI am right align\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/align/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h3 id=\"footnote\"> Footnote</h3>\n<p>This text has footnote<sup></sup>.</p>\n<details><summary>Code</summary>\n<div><pre><code>This text has footnote[^first].\n\n<span><span>[</span><span>^first</span><span>]</span><span>:</span> This</span> is footnote content\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/footnote/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h3 id=\"mark\"> Mark</h3>\n<p>You can mark <mark>important words</mark> .</p>\n<details><summary>Code</summary>\n<div><pre><code>You can mark ==important words== .\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/mark/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h3 id=\"tasklist\"> Tasklist</h3>\n<ul>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> Plan A</label></li>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> Plan B</label></li>\n</ul>\n<details><summary>Code</summary>\n<div><pre><code><span>-</span> [x] Plan A\n<span>-</span> [ ] Plan B\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/tasklist/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h3 id=\"flowchart\"> Flowchart</h3>\n<i>Not supported content</i><details><summary>Code</summary>\n<div><pre><code><span><span>```</span><span>flow</span>\n<span>cond=>condition: Process?\nprocess=>operation: Process\ne=>end: End\n\ncond(yes)->process->e\ncond(no)->e</span>\n<span>```</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/flowchart/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h2 id=\"mermaid\"> Mermaid</h2>\n<Mermaid id=\"mermaid-64a57060\" data-code=\"graph%20TD%3B%0A%20%20%20%20A--%3EB%3B%0A%20%20%20%20A--%3EC%3B%0A%20%20%20%20B--%3ED%3B%0A%20%20%20%20C--%3ED%3B%0A\"></Mermaid><details><summary>Code</summary>\n<div><pre><code><span><span>```</span><span>mermaid</span>\n<span>graph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;</span>\n<span>```</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/mermaid/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h3 id=\"tex\"> Tex</h3>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:2.4em;vertical-align:-0.95em;\"></span><span><span></span><span><span><span><span style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.05556em;\">∂</span><span><span style=\"margin-right:0.03588em;\">ω</span><span><span><span><span style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.05556em;\">∂</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span style=\"top:0em;\"><span>(</span></span><span><span></span><span><span><span><span style=\"height:1.3414em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>)</span></span></span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:3.0277em;vertical-align:-1.2777em;\"></span><span><span style=\"top:0em;\"><span>(</span></span><span><span></span><span><span><span><span style=\"height:1.3414em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>)</span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span style=\"top:0em;\"><span>{</span></span><span>(</span><span>lo<span style=\"margin-right:0.01389em;\">g</span></span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span><span>)</span><span><span><span><span style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span><span><span><span><span style=\"height:1.6514em;\"><span style=\"top:-1.8723em;margin-left:0em;\"><span style=\"height:3.05em;\"></span><span><span><span>i</span><span>=</span><span>1</span></span></span></span><span style=\"top:-3.05em;\"><span style=\"height:3.05em;\"></span><span><span>∑</span></span></span><span style=\"top:-4.3em;margin-left:0em;\"><span style=\"height:3.05em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span><span>​</span></span><span><span style=\"height:1.2777em;\"><span></span></span></span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span></span><span><span><span><span style=\"height:1.5017em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span><span><span><span><span style=\"height:0.7507em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span>(</span><span>−</span><span>1</span><span><span>)</span><span><span><span><span style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span></span></span></span></span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.1667em;\"></span><span>⋯</span><span style=\"margin-right:0.1667em;\"></span><span>(</span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span><span>1</span><span>)</span><span>(</span><span>lo<span style=\"margin-right:0.01389em;\">g</span></span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span><span>)</span><span><span><span><span style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.02778em;\">r</span><span>−</span><span>i</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>}</span></span></span></span></span></span></span></p>\n<details><summary>Code</summary>\n<div><pre><code>$$\n\\frac {\\partial^r} {\\partial \\omega^r} \\left(\\frac {y^{\\omega}} {\\omega}\\right)\n= \\left(\\frac {y^{\\omega}} {\\omega}\\right) \\left\\{(\\log y)^r + \\sum_{i=1}^r \\frac {(-1)^i r \\cdots (r-i+1) (\\log y)^{r-i}} {\\omega^i} \\right\\}\n$$\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/tex/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h3 id=\"demo\"> Demo</h3>\n\n          <div\n            id=\"code-demo-794afbd4\"\n           \n  \n data-title=\"A%20normal%20demo\"\n\n            data-code=\"%7B%22html%22%3A%22%3Ch1%3EMr.Kaokei%3C%2Fh1%3E%5Cn%3Cp%3EIs%20%3Cspan%20id%3D%5C%22very%5C%22%3Every%3C%2Fspan%3E%20handsome%3C%2Fp%3E%5Cn%22%2C%22js%22%3A%22document.querySelector(%5C%22%23very%5C%22).addEventListener(%5C%22click%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20alert(%5C%22Very%20handsome!%5C%22)%3B%5Cn%7D)%3B%5Cn%22%2C%22css%22%3A%22span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Kaokei<span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span>Is <span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>\"</span>very<span>\"</span></span><span>></span></span>very<span><span><span>&lt;/</span>span</span><span>></span></span> handsome<span><span><span>&lt;/</span>p</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>document<span>.</span><span>querySelector</span><span>(</span><span>\"#very\"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>\"click\"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>alert</span><span>(</span><span>\"Very handsome!\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>Code</summary>\n<div><pre><code>::: demo A normal demo\n\n<span><span>```</span><span>html</span>\n<span><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Kaokei<span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span>Is <span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>\"</span>very<span>\"</span></span><span>></span></span>very<span><span><span>&lt;/</span>span</span><span>></span></span> handsome<span><span><span>&lt;/</span>p</span><span>></span></span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>js</span>\n<span>document<span>.</span><span>querySelector</span><span>(</span><span>\"#very\"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>\"click\"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>alert</span><span>(</span><span>\"Very handsome!\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>css</span>\n<span><span>span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-7a65acdb\"\n           \n  data-type=\"react\"\n data-title=\"A%20react%20demo\"\n\n            data-code=\"%7B%22js%22%3A%22export%20default%20class%20App%20extends%20React.Component%20%7B%5Cn%20%20constructor(props)%20%7B%5Cn%20%20%20%20super(props)%3B%5Cn%20%20%20%20this.state%20%3D%20%7B%20message%3A%20%5C%22very%20handsome%5C%22%20%7D%3B%5Cn%20%20%7D%5Cn%20%20render()%20%7B%5Cn%20%20%20%20return%20(%5Cn%20%20%20%20%20%20%3Cdiv%20className%3D%5C%22box-react%5C%22%3E%5Cn%20%20%20%20%20%20%20%20Mr.Kaokei%20is%20%3Cspan%3E%7Bthis.state.message%7D%3C%2Fspan%3E%5Cn%20%20%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%20%20)%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%2C%22css%22%3A%22.box-react%20span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span>export</span> <span>default</span> <span>class</span> <span>App</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>props<span>)</span><span>;</span>\n    <span>this</span><span>.</span>state <span>=</span> <span>{</span> message<span>:</span> <span>\"very handsome\"</span> <span>}</span><span>;</span>\n  <span>}</span>\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>\n      <span>&lt;</span>div className<span>=</span><span>\"box-react\"</span><span>></span>\n        Mr<span>.</span>Kaokei is <span>&lt;</span>span<span>></span><span>{</span><span>this</span><span>.</span>state<span>.</span>message<span>}</span><span>&lt;</span><span>/</span>span<span>></span>\n      <span>&lt;</span><span>/</span>div<span>></span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>.box-react span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>Code</summary>\n<div><pre><code>::: demo [react] A react demo\n\n<span><span>```</span><span>js</span>\n<span><span>export</span> <span>default</span> <span>class</span> <span>App</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>props<span>)</span><span>;</span>\n    <span>this</span><span>.</span>state <span>=</span> <span>{</span> message<span>:</span> <span>\"very handsome\"</span> <span>}</span><span>;</span>\n  <span>}</span>\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>\n      <span>&lt;</span>div className<span>=</span><span>\"box-react\"</span><span>></span>\n        Mr<span>.</span>Kaokei is <span>&lt;</span>span<span>></span><span>{</span><span>this</span><span>.</span>state<span>.</span>message<span>}</span><span>&lt;</span><span>/</span>span<span>></span>\n      <span>&lt;</span><span>/</span>div<span>></span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>css</span>\n<span><span>.box-react span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-9b42a5ee\"\n           \n  data-type=\"vue\"\n data-title=\"A%20vue%20demo\"\n\n            data-code=\"%7B%22vue%22%3A%22%3Ctemplate%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20Mr.Kaokei%20is%20%3Cspan%3E%7B%7B%20message%20%7D%7D%3C%2Fspan%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Ftemplate%3E%5Cn%3Cscript%3E%5Cnexport%20default%20%7B%5Cn%20%20data%3A%20()%20%3D%3E%20(%7B%20message%3A%20%5C%22very%20handsome%5C%22%20%7D)%2C%5Cn%7D%3B%5Cn%3C%2Fscript%3E%5Cn%3Cstyle%3E%5Cn.box%20span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%3C%2Fstyle%3E%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>box<span>\"</span></span><span>></span></span>\n    Mr.Kaokei is <span><span><span>&lt;</span>span</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>span</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  <span>data</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span>{</span> message<span>:</span> <span>\"very handsome\"</span> <span>}</span><span>)</span><span>,</span>\n<span>}</span><span>;</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n<span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n<span>.box span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>Code</summary>\n<div><pre><code>::: demo [vue] A vue demo\n\n<span><span>```</span><span>vue</span>\n<span>&lt;template>\n  &lt;div>\n    Mr.Kaokei is &lt;span>{{ message }}&lt;/span>\n  &lt;/div>\n&lt;/template>\n&lt;script>\nexport default {\n  data: () => ({ message: \"very handsome\" }),\n};\n&lt;/script>\n&lt;style>\n.box span {\n  color: red;\n}\n&lt;/style></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-4f6232b2\"\n           \n  \n data-title=\"A%20normal%20demo\"\n\n            data-code=\"%7B%22md%22%3A%22%23%20Title%5Cn%5Cnis%20very%20handsome.%5Cn%22%2C%22ts%22%3A%22const%20message%3A%20string%20%3D%20%5C%22Mr.Kaokei%5C%22%3B%5Cn%5Cndocument.querySelector(%5C%22h1%5C%22).innerHTML%20%3D%20message%3B%5Cn%22%2C%22scss%22%3A%22h1%20%7B%5Cn%20%20font-style%3A%20italic%3B%5Cn%5Cn%20%20%2B%20p%20%7B%5Cn%20%20%20%20color%3A%20red%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span>#</span> Title</span>\n\nis very handsome.\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>const</span> message<span>:</span> <span>string</span> <span>=</span> <span>\"Mr.Kaokei\"</span><span>;</span>\n\ndocument<span>.</span><span>querySelector</span><span>(</span><span>\"h1\"</span><span>)</span><span>.</span>innerHTML <span>=</span> message<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>h1 </span><span>{</span>\n  <span>font-style</span><span>:</span> italic<span>;</span>\n\n  <span>+ p </span><span>{</span>\n    <span>color</span><span>:</span> red<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>Code</summary>\n<div><pre><code>::: demo A normal demo\n\n<span><span>```</span><span>md</span>\n<span><span><span>#</span> Title</span>\n\nis very handsome.</span>\n<span>```</span></span>\n\n<span><span>```</span><span>ts</span>\n<span><span>const</span> message<span>:</span> <span>string</span> <span>=</span> <span>\"Mr.Kaokei\"</span><span>;</span>\n\ndocument<span>.</span><span>querySelector</span><span>(</span><span>\"h1\"</span><span>)</span><span>.</span>innerHTML <span>=</span> message<span>;</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>scss</span>\n<span><span>h1 </span><span>{</span>\n  <span>font-style</span><span>:</span> italic<span>;</span>\n\n  <span>+ p </span><span>{</span>\n    <span>color</span><span>:</span> red<span>;</span>\n  <span>}</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/demo/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h3 id=\"presentation\"> Presentation</h3>\n<i>Not supported content</i><details><summary>Code</summary>\n<div><pre><code>@slidestart\n\n<span><span>##</span> Slide 1</span>\n\nA paragraph with some text and a <span>[<span>link</span>](<span>https://mrhope.site</span>)</span>\n\n<span>---</span>\n\n<span><span>##</span> Slide 2</span>\n\n<span>-</span> Item 1\n<span>-</span> Item 2\n\n<span>---</span>\n\n<span><span>##</span> Slide 3.1</span>\n\n<span><span>```</span><span>js</span>\n<span><span>const</span> a <span>=</span> <span>1</span><span>;</span></span>\n<span>```</span></span>\n\n--\n\n<span><span>##</span> Slide 3.2</span>\n\n$$\nJ(\\theta_0,\\theta_1) = \\sum_{i=0}\n$$\n\n@slideend\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/presentation/\" target=\"_blank\" rel=\"noopener noreferrer\">View Detail</a></li>\n</ul>\n<h2 id=\"other-syntax\"> Other Syntax</h2>\n<div><p>custom title</p>\n<p>A custom information container</p>\n</div>\n<div><p>custom title</p>\n<p>A custom tip container</p>\n</div>\n<div><p>custom title</p>\n<p>A custom warning container</p>\n</div>\n<div><p>custom Title</p>\n<p>A custom danger container</p>\n</div>\n<details><summary>custom title</summary>\n<p>A custom details container</p>\n</details>\n<details><summary>Code</summary>\n<div><pre><code>::: info custom title\n\nA custom information container\n\n:::\n\n::: tip custom title\n\nA custom tip container\n\n:::\n\n::: warning custom title\n\nA custom warning container\n\n:::\n\n::: danger custom Title\n\nA custom danger container\n\n:::\n\n::: details custom title\n\nA custom details container\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div></details>\n<hr>\n<section>\n<ol>\n<li id=\"footnote1\"><p>This is footnote content </p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": [
        "Guide"
      ]
    },
    {
      "title": "page config",
      "url": "https://www.kaokei.com/en/guide/page/",
      "id": "https://www.kaokei.com/en/guide/page/",
      "content_html": "<h2 id=\"page-information\"> Page information</h2>\n<p>You can set page information in Markdown’s Frontmatter.</p>\n<ul>\n<li>\n<p>The author is set to Ms.Kaokei.</p>\n</li>\n<li>\n<p>The writing time should be January 1, 2020</p>\n</li>\n<li>\n<p>Category is &quot;Guide&quot;</p>\n</li>\n<li>\n<p>Tags are &quot;Page Config&quot; and &quot;Guide&quot;</p>\n</li>\n</ul>\n<h2 id=\"page-content\"> Page content</h2>\n<p>You are free to write your Markdown here.</p>\n<div><p>提示</p>\n<ul>\n<li>\n<p>Please use the relative link <code>./</code> for pictures in the Markdown folder.</p>\n</li>\n<li>\n<p>For pictures in <code>.vuepress/public</code> folder, please use absolute link <code>/</code> for reference</p>\n</li>\n</ul>\n</div>\n<p>The theme contains a custom badge:</p>\n<blockquote>\n<p>A dark blue badge text badge at the end of line. <i>Not supported content</i></p>\n</blockquote>\n<h2 id=\"page-structure\"> Page structure</h2>\n<p>This page should contain:</p>\n<ul>\n<li>Back to top button</li>\n<li>Route navigation</li>\n<li>Comments</li>\n<li>Footer</li>\n</ul>\n",
      "date_published": "2020-01-01T00:00:00.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "Ms.Kaokei"
        }
      ],
      "tags": [
        "Guide"
      ]
    },
    {
      "title": "Guides",
      "url": "https://www.kaokei.com/en/guide/",
      "id": "https://www.kaokei.com/en/guide/",
      "content_html": "<h1 id=\"guides\"> Guides</h1>\n<ul>\n<li>\n<p><a href=\"./page.html\">Page Config</a></p>\n</li>\n<li>\n<p><a href=\"./markdown.html\">Markdown Enhance</a></p>\n</li>\n<li>\n<p><a href=\"./disable.html\">Function Disable</a></p>\n</li>\n<li>\n<p><a href=\"./encrypt.html\">Encryption Demo</a></p>\n</li>\n</ul>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": [
        "Guide"
      ]
    },
    {
      "title": "Project home",
      "url": "https://www.kaokei.com/en/home/",
      "id": "https://www.kaokei.com/en/home/",
      "content_html": "<p>This is an example of a normal homepage. You can place your main content here.</p>\n<p>To use this layout, you need to set <code>home: true</code> in the page front matter.</p>\n<p>For related descriptions of configuration items, please see <a href=\"https://vuepress-theme-hope.github.io/guide/layout/home/\" target=\"_blank\" rel=\"noopener noreferrer\">Project HomePage Layout Config</a>.</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "Intro Page",
      "url": "https://www.kaokei.com/en/intro/",
      "id": "https://www.kaokei.com/en/intro/",
      "content_html": "<h1 id=\"intro-page\"> Intro Page</h1>\n<p>Place your introducation and profile here.</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "Custom Layout",
      "url": "https://www.kaokei.com/en/layout/",
      "id": "https://www.kaokei.com/en/layout/",
      "content_html": "<p>You can use slots with markdown and component support to custom page layout.</p>\n<div><p>注意</p>\n<p>This is just a demo, you should add styles according to your own needs.</p>\n\n\n</div>\n<template #page-top><p>Page top content</p>\n</template><template #page-bottom><p>Page bottom content</p>\n</template><template #content-top><p>Content top content</p>\n</template><template #content-bottom><p>Content bottom content</p>\n</template><template #navbar-start><p>Navbar start content</p>\n</template><template #navbar-center><p>Navbar center content</p>\n</template><template #navbar-end><p>Navbar end content</p>\n</template><template #sidebar-top><p>Sidebar top content</p>\n</template><template #sidebar-center><p>Sidebar center content</p>\n</template><template #sidebar-bottom><p>Sidebar bottom content</p>\n</template><p>For details, see <a href=\"https://vuepress-theme-hope.github.io/guide/layout/custom/\" target=\"_blank\" rel=\"noopener noreferrer\">Custom layout</a>.</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "Blog Home",
      "url": "https://www.kaokei.com/en/",
      "id": "https://www.kaokei.com/en/",
      "content_html": "<p>This is a blog home page.</p>\n<p>To use this layout, you should set both <code>blog: true</code> and <code>home: true</code> in the page front matter.</p>\n<p>For related configuration docs, please see <a href=\"https://vuepress-theme-hope.github.io/guide/blog/home/\" target=\"_blank\" rel=\"noopener noreferrer\">blog homepage</a></p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "Slide page",
      "url": "https://www.kaokei.com/en/slides/",
      "id": "https://www.kaokei.com/en/slides/",
      "content_html": "\n<i>Not supported content</i>",
      "image": "https://www.kaokei.com/logo.svg",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "组件禁用",
      "url": "https://www.kaokei.com/guide/disable/",
      "id": "https://www.kaokei.com/guide/disable/",
      "summary": "<p>你可以通过设置页面的 Frontmatter，在页面禁用一些功能。</p>\n",
      "content_html": "<p>你可以通过设置页面的 Frontmatter，在页面禁用一些功能。</p>\n\n<p>本页面应当禁用了:</p>\n<ul>\n<li>导航栏</li>\n<li>侧边栏</li>\n<li>路径导航</li>\n<li>页面信息</li>\n<li>贡献者</li>\n<li>编辑此页链接</li>\n<li>更新时间</li>\n<li>上一篇/下一篇 链接</li>\n<li>评论</li>\n<li>页脚</li>\n<li>返回顶部按钮</li>\n</ul>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "密码加密的文章",
      "url": "https://www.kaokei.com/guide/encrypt/",
      "id": "https://www.kaokei.com/guide/encrypt/",
      "content_html": "<h1 id=\"密码加密的文章\"> 密码加密的文章</h1>\n<p>实际的文章内容。</p>\n<p>段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字。</p>\n<p>段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "Markdown 增强",
      "url": "https://www.kaokei.com/guide/markdown/",
      "id": "https://www.kaokei.com/guide/markdown/",
      "summary": "<p><code>vuepress-theme-hope</code> 通过内置 <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a>，在 Markdown 中启用了更多的语法与新功能。</p>\n",
      "content_html": "<p><code>vuepress-theme-hope</code> 通过内置 <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a>，在 Markdown 中启用了更多的语法与新功能。</p>\n\n<h2 id=\"一键启用\"> 一键启用</h2>\n<p>你可以设置 <code>themeconfig.mdEnhance.enableAll</code> 启用 <a href=\"https://vuepress-theme-hope.github.io/md-enhance\" target=\"_blank\" rel=\"noopener noreferrer\">md-enhance</a> 插件的所有功能。</p>\n<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>\n  themeConfig<span>:</span> <span>{</span>\n    mdEnhance<span>:</span> <span>{</span>\n      enableAll<span>:</span> <span>true</span><span>,</span>\n    <span>}</span><span>,</span>\n  <span>}</span><span>,</span>\n<span>}</span><span>;</span>\n</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id=\"新增的更多语法\"> 新增的更多语法</h2>\n<h3 id=\"上下角标\"> 上下角标</h3>\n<p>19<sup>th</sup> H<sub>2</sub>O</p>\n<details><summary>代码</summary>\n<div><pre><code>19^th^ H<span><span>~</span><span>2</span><span>~</span></span>O\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/sup-sub/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"自定义对齐\"> 自定义对齐</h3>\n<div>\n<p>我是居中的</p>\n</div>\n<div>\n<p>我在右对齐</p>\n</div>\n<details><summary>代码</summary>\n<div><pre><code>::: center\n\n我是居中的\n\n:::\n\n::: right\n\n我在右对齐\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/align/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"脚注\"> 脚注</h3>\n<p>此文字有脚注<sup></sup>.</p>\n<details><summary>代码</summary>\n<div><pre><code>此文字有脚注[^first].\n\n<span><span>[</span><span>^first</span><span>]</span><span>:</span> 这是脚注内容</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/footnote/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"标记\"> 标记</h3>\n<p>你可以标记 <mark>重要的内容</mark> 。</p>\n<details><summary>代码</summary>\n<div><pre><code>你可以标记 ==重要的内容== 。\n</code></pre>\n<div><span>1</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/mark/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"任务列表\"> 任务列表</h3>\n<ul>\n<li><input type=\"checkbox\" checked=\"checked\" disabled=\"disabled\" id=\"task-item-0\"><label for=\"task-item-0\"> 计划 1</label></li>\n<li><input type=\"checkbox\"  disabled=\"disabled\" id=\"task-item-1\"><label for=\"task-item-1\"> 计划 2</label></li>\n</ul>\n<details><summary>Code</summary>\n<div><pre><code><span>-</span> [x] 计划 1\n<span>-</span> [ ] 计划 2\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/guide/markdown/tasklist/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"流程图\"> 流程图</h3>\n<i>Not supported content</i><details><summary>代码</summary>\n<div><pre><code><span><span>```</span><span>flow</span>\n<span>cond=>condition: Process?\nprocess=>operation: Process\ne=>end: End\n\ncond(yes)->process->e\ncond(no)->e</span>\n<span>```</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/flowchart/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h2 id=\"mermaid\"> Mermaid</h2>\n<Mermaid id=\"mermaid-64a57060\" data-code=\"graph%20TD%3B%0A%20%20%20%20A--%3EB%3B%0A%20%20%20%20A--%3EC%3B%0A%20%20%20%20B--%3ED%3B%0A%20%20%20%20C--%3ED%3B%0A\"></Mermaid><details><summary>代码</summary>\n<div><pre><code><span><span>```</span><span>mermaid</span>\n<span>graph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;</span>\n<span>```</span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/mermaid/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"tex-语法\"> Tex 语法</h3>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:2.4em;vertical-align:-0.95em;\"></span><span><span></span><span><span><span><span style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.05556em;\">∂</span><span><span style=\"margin-right:0.03588em;\">ω</span><span><span><span><span style=\"height:0.5904em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.05556em;\">∂</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span style=\"top:0em;\"><span>(</span></span><span><span></span><span><span><span><span style=\"height:1.3414em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>)</span></span></span><span style=\"margin-right:0.2778em;\"></span><span>=</span><span style=\"margin-right:0.2778em;\"></span></span><span><span style=\"height:3.0277em;vertical-align:-1.2777em;\"></span><span><span style=\"top:0em;\"><span>(</span></span><span><span></span><span><span><span><span style=\"height:1.3414em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>)</span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span style=\"top:0em;\"><span>{</span></span><span>(</span><span>lo<span style=\"margin-right:0.01389em;\">g</span></span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span><span>)</span><span><span><span><span style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span><span><span><span><span style=\"height:1.6514em;\"><span style=\"top:-1.8723em;margin-left:0em;\"><span style=\"height:3.05em;\"></span><span><span><span>i</span><span>=</span><span>1</span></span></span></span><span style=\"top:-3.05em;\"><span style=\"height:3.05em;\"></span><span><span>∑</span></span></span><span style=\"top:-4.3em;margin-left:0em;\"><span style=\"height:3.05em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span><span>​</span></span><span><span style=\"height:1.2777em;\"><span></span></span></span></span></span><span style=\"margin-right:0.1667em;\"></span><span><span></span><span><span><span><span style=\"height:1.5017em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.03588em;\">ω</span><span><span><span><span style=\"height:0.7507em;\"><span style=\"top:-2.989em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span>(</span><span>−</span><span>1</span><span><span>)</span><span><span><span><span style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span></span></span></span></span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.1667em;\"></span><span>⋯</span><span style=\"margin-right:0.1667em;\"></span><span>(</span><span style=\"margin-right:0.02778em;\">r</span><span style=\"margin-right:0.2222em;\"></span><span>−</span><span style=\"margin-right:0.2222em;\"></span><span>i</span><span style=\"margin-right:0.2222em;\"></span><span>+</span><span style=\"margin-right:0.2222em;\"></span><span>1</span><span>)</span><span>(</span><span>lo<span style=\"margin-right:0.01389em;\">g</span></span><span style=\"margin-right:0.1667em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span><span>)</span><span><span><span><span style=\"height:0.8247em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.02778em;\">r</span><span>−</span><span>i</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"top:0em;\"><span>}</span></span></span></span></span></span></span></p>\n<details><summary>代码</summary>\n<div><pre><code>$$\n\\frac {\\partial^r} {\\partial \\omega^r} \\left(\\frac {y^{\\omega}} {\\omega}\\right)\n= \\left(\\frac {y^{\\omega}} {\\omega}\\right) \\left\\{(\\log y)^r + \\sum_{i=1}^r \\frac {(-1)^i r \\cdots (r-i+1) (\\log y)^{r-i}} {\\omega^i} \\right\\}\n$$\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/tex/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"代码案例\"> 代码案例</h3>\n\n          <div\n            id=\"code-demo-5baf50d0\"\n           \n  \n data-title=\"%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo\"\n\n            data-code=\"%7B%22html%22%3A%22%3Ch1%3EMr.Kaokei%3C%2Fh1%3E%5Cn%3Cp%3E%3Cspan%20id%3D%5C%22very%5C%22%3E%E5%8D%81%E5%88%86%3C%2Fspan%3E%20%E5%B8%85%3C%2Fp%3E%5Cn%22%2C%22js%22%3A%22document.querySelector(%5C%22%23very%5C%22).addEventListener(%5C%22click%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20alert(%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22)%3B%5Cn%7D)%3B%5Cn%22%2C%22css%22%3A%22span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Kaokei<span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>\"</span>very<span>\"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>document<span>.</span><span>querySelector</span><span>(</span><span>\"#very\"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>\"click\"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>alert</span><span>(</span><span>\"十分帅\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo 一个普通 Demo\n\n<span><span>```</span><span>html</span>\n<span><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Kaokei<span><span><span>&lt;/</span>h1</span><span>></span></span>\n<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>\"</span>very<span>\"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>js</span>\n<span>document<span>.</span><span>querySelector</span><span>(</span><span>\"#very\"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>\"click\"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>alert</span><span>(</span><span>\"十分帅\"</span><span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>css</span>\n<span><span>span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-14734487\"\n           \n  data-type=\"react\"\n data-title=\"%E4%B8%80%E4%B8%AA%20React%20Demo\"\n\n            data-code=\"%7B%22js%22%3A%22export%20default%20class%20App%20extends%20React.Component%20%7B%5Cn%20%20constructor(props)%20%7B%5Cn%20%20%20%20super(props)%3B%5Cn%20%20%20%20this.state%20%3D%20%7B%20message%3A%20%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22%20%7D%3B%5Cn%20%20%7D%5Cn%20%20render()%20%7B%5Cn%20%20%20%20return%20(%5Cn%20%20%20%20%20%20%3Cdiv%20className%3D%5C%22box-react%5C%22%3E%5Cn%20%20%20%20%20%20%20%20Mr.Kaokei%20%3Cspan%3E%7Bthis.state.message%7D%3C%2Fspan%3E%5Cn%20%20%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%20%20)%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%2C%22css%22%3A%22.box-react%20span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span>export</span> <span>default</span> <span>class</span> <span>App</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>props<span>)</span><span>;</span>\n    <span>this</span><span>.</span>state <span>=</span> <span>{</span> message<span>:</span> <span>\"十分帅\"</span> <span>}</span><span>;</span>\n  <span>}</span>\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>\n      <span>&lt;</span>div className<span>=</span><span>\"box-react\"</span><span>></span>\n        Mr<span>.</span>Kaokei <span>&lt;</span>span<span>></span><span>{</span><span>this</span><span>.</span>state<span>.</span>message<span>}</span><span>&lt;</span><span>/</span>span<span>></span>\n      <span>&lt;</span><span>/</span>div<span>></span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>.box-react span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo [react] 一个 React Demo\n\n<span><span>```</span><span>js</span>\n<span><span>export</span> <span>default</span> <span>class</span> <span>App</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>\n  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span>props<span>)</span><span>;</span>\n    <span>this</span><span>.</span>state <span>=</span> <span>{</span> message<span>:</span> <span>\"十分帅\"</span> <span>}</span><span>;</span>\n  <span>}</span>\n  <span>render</span><span>(</span><span>)</span> <span>{</span>\n    <span>return</span> <span>(</span>\n      <span>&lt;</span>div className<span>=</span><span>\"box-react\"</span><span>></span>\n        Mr<span>.</span>Kaokei <span>&lt;</span>span<span>></span><span>{</span><span>this</span><span>.</span>state<span>.</span>message<span>}</span><span>&lt;</span><span>/</span>span<span>></span>\n      <span>&lt;</span><span>/</span>div<span>></span>\n    <span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>css</span>\n<span><span>.box-react span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-ba093f4a\"\n           \n  data-type=\"vue\"\n data-title=\"%E4%B8%80%E4%B8%AA%20Vue%20Demo\"\n\n            data-code=\"%7B%22vue%22%3A%22%3Ctemplate%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20Mr.Kaokei%20%3Cspan%3E%7B%7B%20message%20%7D%7D%3C%2Fspan%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Ftemplate%3E%5Cn%3Cscript%3E%5Cnexport%20default%20%7B%5Cn%20%20data%3A%20()%20%3D%3E%20(%7B%20message%3A%20%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22%20%7D)%2C%5Cn%7D%3B%5Cn%3C%2Fscript%3E%5Cn%3Cstyle%3E%5Cn.box%20span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%3C%2Fstyle%3E%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>box<span>\"</span></span><span>></span></span>\n    Mr.Kaokei <span><span><span>&lt;</span>span</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>span</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n<span><span><span>&lt;</span>script</span><span>></span></span><span><span>\n<span>export</span> <span>default</span> <span>{</span>\n  <span>data</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span>{</span> message<span>:</span> <span>\"十分帅\"</span> <span>}</span><span>)</span><span>,</span>\n<span>}</span><span>;</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n<span><span><span>&lt;</span>style</span><span>></span></span><span><span>\n<span>.box span</span> <span>{</span>\n  <span>color</span><span>:</span> red<span>;</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo [vue] 一个 Vue Demo\n\n<span><span>```</span><span>vue</span>\n<span>&lt;template>\n  &lt;div>\n    Mr.Kaokei &lt;span>{{ message }}&lt;/span>\n  &lt;/div>\n&lt;/template>\n&lt;script>\nexport default {\n  data: () => ({ message: \"十分帅\" }),\n};\n&lt;/script>\n&lt;style>\n.box span {\n  color: red;\n}\n&lt;/style></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></details>\n\n          <div\n            id=\"code-demo-48ec6bde\"\n           \n  \n data-title=\"%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo\"\n\n            data-code=\"%7B%22md%22%3A%22%23%20%E6%A0%87%E9%A2%98%5Cn%5Cn%E5%8D%81%E5%88%86%E5%B8%85%5Cn%22%2C%22ts%22%3A%22const%20message%3A%20string%20%3D%20%5C%22Mr.Kaokei%5C%22%3B%5Cn%5Cndocument.querySelector(%5C%22h1%5C%22).innerHTML%20%3D%20message%3B%5Cn%22%2C%22scss%22%3A%22h1%20%7B%5Cn%20%20font-style%3A%20italic%3B%5Cn%5Cn%20%20%2B%20p%20%7B%5Cn%20%20%20%20color%3A%20red%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%7D\"\n          >\n              \n              <div>\n                <div>\n<div><pre><code><span><span>#</span> 标题</span>\n\n十分帅\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>const</span> message<span>:</span> <span>string</span> <span>=</span> <span>\"Mr.Kaokei\"</span><span>;</span>\n\ndocument<span>.</span><span>querySelector</span><span>(</span><span>\"h1\"</span><span>)</span><span>.</span>innerHTML <span>=</span> message<span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>h1 </span><span>{</span>\n  <span>font-style</span><span>:</span> italic<span>;</span>\n\n  <span>+ p </span><span>{</span>\n    <span>color</span><span>:</span> red<span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>\n            </div>\n          </div>\n          \n        </div>\n<details><summary>代码</summary>\n<div><pre><code>::: demo 一个普通 Demo\n\n<span><span>```</span><span>md</span>\n<span><span><span>#</span> 标题</span>\n\n十分帅</span>\n<span>```</span></span>\n\n<span><span>```</span><span>ts</span>\n<span><span>const</span> message<span>:</span> <span>string</span> <span>=</span> <span>\"Mr.Kaokei\"</span><span>;</span>\n\ndocument<span>.</span><span>querySelector</span><span>(</span><span>\"h1\"</span><span>)</span><span>.</span>innerHTML <span>=</span> message<span>;</span></span>\n<span>```</span></span>\n\n<span><span>```</span><span>scss</span>\n<span><span>h1 </span><span>{</span>\n  <span>font-style</span><span>:</span> italic<span>;</span>\n\n  <span>+ p </span><span>{</span>\n    <span>color</span><span>:</span> red<span>;</span>\n  <span>}</span>\n<span>}</span></span>\n<span>```</span></span>\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/demo/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h3 id=\"幻灯片\"> 幻灯片</h3>\n<i>Not supported content</i><details><summary>代码</summary>\n<div><pre><code>@slidestart\n\n<span><span>##</span> 幻灯片 1</span>\n\n一个有文字和 <span>[<span>链接</span>](<span>https://mrhope.site</span>)</span> 的段落\n\n<span>---</span>\n\n<span><span>##</span> 幻灯片 2</span>\n\n<span>-</span> 列表 1\n<span>-</span> 列表 2\n\n<span>---</span>\n\n<span><span>##</span> 幻灯片 3.1</span>\n\n<span><span>```</span><span>js</span>\n<span><span>const</span> a <span>=</span> <span>1</span><span>;</span></span>\n<span>```</span></span>\n\n--\n\n<span><span>##</span> 幻灯片 3.2</span>\n\n$$\nJ(\\theta_0,\\theta_1) = \\sum_{i=0}\n$$\n\n@slideend\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div></details>\n<ul>\n<li><a href=\"https://vuepress-theme-hope.github.io/zh/guide/markdown/presentation/\" target=\"_blank\" rel=\"noopener noreferrer\">点击查看</a></li>\n</ul>\n<h2 id=\"其他语法\"> 其他语法</h2>\n<div><p>自定义标题</p>\n<p>信息容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>提示容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>警告容器</p>\n</div>\n<div><p>自定义标题</p>\n<p>危险容器</p>\n</div>\n<details><summary>自定义标题</summary>\n<p>详情容器</p>\n</details>\n<details><summary>代码</summary>\n<div><pre><code>::: info 自定义标题\n\n信息容器\n\n:::\n\n::: tip 自定义标题\n\n提示容器\n\n:::\n\n::: warning 自定义标题\n\n警告容器\n\n:::\n\n::: danger 自定义标题\n\n危险容器\n\n:::\n\n::: details 自定义标题\n\n详情容器\n\n:::\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div></details>\n<hr>\n<section>\n<ol>\n<li id=\"footnote1\"><p>这是脚注内容 </p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "页面配置",
      "url": "https://www.kaokei.com/guide/page/",
      "id": "https://www.kaokei.com/guide/page/",
      "content_html": "<h2 id=\"页面信息\"> 页面信息</h2>\n<p>你可以在 Markdown 的 Frontmatter 中设置页面信息。</p>\n<ul>\n<li>\n<p>作者设置为 Mr.Kaokei。</p>\n</li>\n<li>\n<p>写作时间应为 2020 年 1 月 1 日</p>\n</li>\n<li>\n<p>分类为 “使用指南”</p>\n</li>\n<li>\n<p>标签为 “页面配置” 和 “使用指南”</p>\n</li>\n</ul>\n<h2 id=\"页面内容\"> 页面内容</h2>\n<p>你可以自由在这里书写你的 Markdown。</p>\n<div><p>提示</p>\n<ul>\n<li>\n<p>Markdown 文件夹的图片请使用相对链接 <code>./</code> 进行引用。</p>\n</li>\n<li>\n<p><code>.vuepress/public</code> 文件夹的图片，请使用绝对链接 <code>/</code> 进行引用</p>\n</li>\n</ul>\n</div>\n<p>主题包含了一个自定义徽章章可以使用:</p>\n<blockquote>\n<p>文字结尾应该有深蓝色的 徽章文字 徽章。 <i>Not supported content</i></p>\n</blockquote>\n<h2 id=\"页面结构\"> 页面结构</h2>\n<p>此页面应当包含：</p>\n<ul>\n<li>返回顶部按钮</li>\n<li>路径导航</li>\n<li>评论</li>\n<li>页脚</li>\n</ul>\n",
      "date_published": "2020-01-01T00:00:00.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "Ms.Kaokei"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "主要功能与配置演示",
      "url": "https://www.kaokei.com/guide/",
      "id": "https://www.kaokei.com/guide/",
      "content_html": "<h1 id=\"主要功能与配置演示\"> 主要功能与配置演示</h1>\n<ul>\n<li>\n<p><a href=\"./page.html\">页面展示</a></p>\n</li>\n<li>\n<p><a href=\"./markdown.html\">Markdown 展示</a></p>\n</li>\n<li>\n<p><a href=\"./disable.html\">禁用展示</a></p>\n</li>\n<li>\n<p><a href=\"./encrypt.html\">加密展示</a></p>\n</li>\n</ul>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "项目主页",
      "url": "https://www.kaokei.com/home/",
      "id": "https://www.kaokei.com/home/",
      "content_html": "<p>这是普通主页的案例。你可以在这里放置你的主体内容。</p>\n<p>想要使用此布局，你需要在页面 front matter 中设置 <code>home: true</code>。</p>\n<p>配置项的相关说明详见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/layout/home/\" target=\"_blank\" rel=\"noopener noreferrer\">项目主页配置</a>。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "介绍页面",
      "url": "https://www.kaokei.com/intro/",
      "id": "https://www.kaokei.com/intro/",
      "content_html": "<h1 id=\"介绍页面\"> 介绍页面</h1>\n<p>这里放一些介绍自己的信息-001。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "自定义布局",
      "url": "https://www.kaokei.com/layout/",
      "id": "https://www.kaokei.com/layout/",
      "content_html": "<p>您可以使用带有 Markdown 支持的插槽来自定义页面布局。</p>\n<div><p>注意</p>\n<p>此处仅仅是一个演示，你应该自行根据需求添加样式。</p>\n\n\n</div>\n<template #page-top><p>页面顶部内容</p>\n</template><template #page-bottom><p>页面底部内容</p>\n</template><template #content-top><p>内容顶部内容</p>\n</template><template #content-bottom><p>内容底部内容</p>\n</template><template #navbar-start><p>导航栏起始内容</p>\n</template><template #navbar-center><p>导航栏中部内容</p>\n</template><template #navbar-end><p>导航栏末尾内容</p>\n</template><template #sidebar-top><p>侧边栏顶部内容</p>\n</template><template #sidebar-center><p>侧边栏中部内容</p>\n</template><template #sidebar-bottom><p>侧边栏底部内容</p>\n</template><p>更多详情，详见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/layout/custom/\" target=\"_blank\" rel=\"noopener noreferrer\">自定义布局</a>.</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "介绍页面",
      "url": "https://www.kaokei.com/note/git/guide/note1/",
      "id": "https://www.kaokei.com/note/git/guide/note1/",
      "content_html": "<h1 id=\"介绍页面\"> 介绍页面</h1>\n<p>guide use-git-service 001</p>\n<p>这里放一些介绍自己的信息-001。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "介绍页面",
      "url": "https://www.kaokei.com/note/git/guide/note2/",
      "id": "https://www.kaokei.com/note/git/guide/note2/",
      "content_html": "<h1 id=\"介绍页面\"> 介绍页面</h1>\n<p>guide use-git-service 002</p>\n<p>这里放一些介绍自己的信息-001。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "主要功能与配置演示",
      "url": "https://www.kaokei.com/note/git/guide/",
      "id": "https://www.kaokei.com/note/git/guide/",
      "content_html": "<h1 id=\"主要功能与配置演示\"> 主要功能与配置演示</h1>\n<ul>\n<li>\n<p><a href=\"./note1.html\">页面展示</a></p>\n</li>\n<li>\n<p><a href=\"./note2.html\">Markdown 展示</a></p>\n</li>\n</ul>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "介绍页面",
      "url": "https://www.kaokei.com/note/git/note1/",
      "id": "https://www.kaokei.com/note/git/note1/",
      "content_html": "<h1 id=\"介绍页面\"> 介绍页面</h1>\n<p>git 001</p>\n<p>这里放一些介绍自己的信息-001。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "介绍页面",
      "url": "https://www.kaokei.com/note/git/note2/",
      "id": "https://www.kaokei.com/note/git/note2/",
      "content_html": "<h1 id=\"介绍页面\"> 介绍页面</h1>\n<p>git 002</p>\n<p>这里放一些介绍自己的信息-001。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "主要功能与配置演示",
      "url": "https://www.kaokei.com/note/git/",
      "id": "https://www.kaokei.com/note/git/",
      "content_html": "<h1 id=\"主要功能与配置演示\"> 主要功能与配置演示</h1>\n<ul>\n<li>\n<p><a href=\"./note1.html\">页面展示</a></p>\n</li>\n<li>\n<p><a href=\"./note2.html\">Markdown 展示</a></p>\n</li>\n</ul>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "介绍页面",
      "url": "https://www.kaokei.com/note/guide/note1/",
      "id": "https://www.kaokei.com/note/guide/note1/",
      "content_html": "<h1 id=\"介绍页面\"> 介绍页面</h1>\n<p>note guide use-vue-service 001</p>\n<p>这里放一些介绍自己的信息-001。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "介绍页面",
      "url": "https://www.kaokei.com/note/guide/note2/",
      "id": "https://www.kaokei.com/note/guide/note2/",
      "content_html": "<h1 id=\"介绍页面\"> 介绍页面</h1>\n<p>note guide use-vue-service 002</p>\n<p>这里放一些介绍自己的信息-001。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "主要功能与配置演示",
      "url": "https://www.kaokei.com/note/guide/",
      "id": "https://www.kaokei.com/note/guide/",
      "content_html": "<h1 id=\"主要功能与配置演示\"> 主要功能与配置演示</h1>\n<ul>\n<li>\n<p><a href=\"./note1.html\">页面展示</a></p>\n</li>\n<li>\n<p><a href=\"./note2.html\">Markdown 展示</a></p>\n</li>\n</ul>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "介绍页面",
      "url": "https://www.kaokei.com/note/linux/guide/note1/",
      "id": "https://www.kaokei.com/note/linux/guide/note1/",
      "content_html": "<h1 id=\"介绍页面\"> 介绍页面</h1>\n<p>guide use-linux-service 001</p>\n<p>这里放一些介绍自己的信息-001。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "介绍页面",
      "url": "https://www.kaokei.com/note/linux/guide/note2/",
      "id": "https://www.kaokei.com/note/linux/guide/note2/",
      "content_html": "<h1 id=\"介绍页面\"> 介绍页面</h1>\n<p>guide use-linux-service 002</p>\n<p>这里放一些介绍自己的信息-001。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "主要功能与配置演示",
      "url": "https://www.kaokei.com/note/linux/guide/",
      "id": "https://www.kaokei.com/note/linux/guide/",
      "content_html": "<h1 id=\"主要功能与配置演示\"> 主要功能与配置演示</h1>\n<ul>\n<li>\n<p><a href=\"./note1.html\">页面展示</a></p>\n</li>\n<li>\n<p><a href=\"./note2.html\">Markdown 展示</a></p>\n</li>\n</ul>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "介绍页面",
      "url": "https://www.kaokei.com/note/linux/note1/",
      "id": "https://www.kaokei.com/note/linux/note1/",
      "content_html": "<h1 id=\"介绍页面\"> 介绍页面</h1>\n<p>linux 001</p>\n<p>这里放一些介绍自己的信息-001。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "介绍页面",
      "url": "https://www.kaokei.com/note/linux/note2/",
      "id": "https://www.kaokei.com/note/linux/note2/",
      "content_html": "<h1 id=\"介绍页面\"> 介绍页面</h1>\n<p>linux 002</p>\n<p>这里放一些介绍自己的信息-001。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "主要功能与配置演示",
      "url": "https://www.kaokei.com/note/linux/",
      "id": "https://www.kaokei.com/note/linux/",
      "content_html": "<h1 id=\"主要功能与配置演示\"> 主要功能与配置演示</h1>\n<ul>\n<li>\n<p><a href=\"./note1.html\">页面展示</a></p>\n</li>\n<li>\n<p><a href=\"./note2.html\">Markdown 展示</a></p>\n</li>\n</ul>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "介绍页面",
      "url": "https://www.kaokei.com/note/note1/",
      "id": "https://www.kaokei.com/note/note1/",
      "content_html": "<h1 id=\"介绍页面\"> 介绍页面</h1>\n<p>随笔 001</p>\n<p>这里放一些介绍自己的信息-001。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "介绍页面",
      "url": "https://www.kaokei.com/note/note2/",
      "id": "https://www.kaokei.com/note/note2/",
      "content_html": "<h1 id=\"介绍页面\"> 介绍页面</h1>\n<p>随笔 002</p>\n<p>这里放一些介绍自己的信息-001。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "主要功能与配置演示",
      "url": "https://www.kaokei.com/note/",
      "id": "https://www.kaokei.com/note/",
      "content_html": "<h1 id=\"主要功能与配置演示\"> 主要功能与配置演示</h1>\n<ul>\n<li>\n<p><a href=\"./note1.html\">页面展示</a></p>\n</li>\n<li>\n<p><a href=\"./note2.html\">Markdown 展示</a></p>\n</li>\n</ul>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "介绍页面",
      "url": "https://www.kaokei.com/project/use-react-service/guide/note1/",
      "id": "https://www.kaokei.com/project/use-react-service/guide/note1/",
      "content_html": "<h1 id=\"介绍页面\"> 介绍页面</h1>\n<p>guide use-react-service 001</p>\n<p>这里放一些介绍自己的信息-001。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "介绍页面",
      "url": "https://www.kaokei.com/project/use-react-service/guide/note2/",
      "id": "https://www.kaokei.com/project/use-react-service/guide/note2/",
      "content_html": "<h1 id=\"介绍页面\"> 介绍页面</h1>\n<p>guide use-react-service 002</p>\n<p>这里放一些介绍自己的信息-001。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "主要功能与配置演示",
      "url": "https://www.kaokei.com/project/use-react-service/guide/",
      "id": "https://www.kaokei.com/project/use-react-service/guide/",
      "content_html": "<h1 id=\"主要功能与配置演示\"> 主要功能与配置演示</h1>\n<ul>\n<li>\n<p><a href=\"./note1.html\">页面展示</a></p>\n</li>\n<li>\n<p><a href=\"./note2.html\">Markdown 展示</a></p>\n</li>\n</ul>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": [
        "使用指南"
      ]
    },
    {
      "title": "介绍页面",
      "url": "https://www.kaokei.com/project/use-react-service/note1/",
      "id": "https://www.kaokei.com/project/use-react-service/note1/",
      "content_html": "<h1 id=\"介绍页面\"> 介绍页面</h1>\n<p>use-react-service 001</p>\n<p>这里放一些介绍自己的信息-001。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "介绍页面",
      "url": "https://www.kaokei.com/project/use-react-service/note2/",
      "id": "https://www.kaokei.com/project/use-react-service/note2/",
      "content_html": "<h1 id=\"介绍页面\"> 介绍页面</h1>\n<p>use-react-service 002</p>\n<p>这里放一些介绍自己的信息-001。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "项目主页",
      "url": "https://www.kaokei.com/project/use-react-service/",
      "id": "https://www.kaokei.com/project/use-react-service/",
      "content_html": "<p>这是普通主页的案例。你可以在这里放置你的主体内容。</p>\n<p>想要使用此布局，你需要在页面 front matter 中设置 <code>home: true</code>。</p>\n<p>配置项的相关说明详见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/layout/home/\" target=\"_blank\" rel=\"noopener noreferrer\">项目主页配置</a>。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "API 文档",
      "url": "https://www.kaokei.com/project/use-vue-service/api/",
      "id": "https://www.kaokei.com/project/use-vue-service/api/",
      "content_html": "<h2 id=\"简介\"> 简介</h2>\n<p>当前一共有 8 个 API，具体如下：</p>\n<h4 id=\"提供依赖注入能力\"> 提供依赖注入能力</h4>\n<p>这些 api 是从<code>@kaokei/di</code>中导出的，是用来定义服务的。而且还可以在类组件中使用（除了 Injectable）。</p>\n<ul>\n<li>Inject</li>\n<li>Self</li>\n<li>Skip</li>\n<li>Optional</li>\n<li>Injectable</li>\n</ul>\n<h4 id=\"类组件专用\"> 类组件专用</h4>\n<ul>\n<li>Component</li>\n</ul>\n<h4 id=\"option-组件专用\"> Option 组件专用</h4>\n<p>因为在 Option 组件中不能使用@Inject 的方式来注入服务。只能手动调用 useService 来获取服务实例。\n同样在类组件中可以使用 Component 来定义 providers，但是在 Option 组件中不能使用装饰器。所以也提供了一个方法 declareProviders。</p>\n<ul>\n<li>declareProviders</li>\n<li>useService</li>\n</ul>\n<h2 id=\"inject-装饰器函数\"> Inject 装饰器函数</h2>\n<div><pre><code><span>import</span> <span>{</span> Injectable <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n<span>import</span> <span>{</span> LoggerService <span>}</span> <span>from</span> <span>\"./logger.service.ts\"</span><span>;</span>\n\n<span><span>@</span><span>Injectable</span></span><span>(</span><span>)</span>\n<span>export</span> <span>class</span> <span>CountService</span> <span>{</span>\n  <span><span>@</span><span>Inject</span></span><span>(</span>LoggerService<span>)</span>\n  <span>private</span> logger1<span>:</span> LoggerService<span>,</span>\n\n  <span>constructor</span><span>(</span>\n    <span><span>@</span><span>Inject</span></span><span>(</span>LoggerService<span>)</span> <span>private</span> logger2<span>:</span> LoggerService<span>,</span>\n  <span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>装饰器目前只能用在类上面，所以可以在类组件和类服务上使用。</p>\n<p>参考示例代码，可以看出来<code>@Inject</code>装饰器可以在<code>实例属性</code>以及类的<code>构造函数的参数</code>上使用。</p>\n<p>@Inject 的作用是在当前类实例化的时候，Injector 会自动帮助我们注入相应的<code>实例属性</code>和<code>构造函数参数</code>。</p>\n<p>@Inject 有一个必填的参数，作为需要注入的服务标识符。</p>\n<p>在实例属性上，@Inject 是必须的。如果没有这个装饰器，那么就是一个普通的属性。</p>\n<p>在构造函数的参数上，如果参数类型是类，比如这里的 logger2 的类型是 LoggerService 是一个类。那么这里其实是可以不使用@Inject 的。代码如下：</p>\n<div><pre><code><span>constructor</span><span>(</span>\n  <span>private</span> logger2<span>:</span> LoggerService<span>,</span>\n<span>)</span> <span>{</span><span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>注意</strong>：最初的设计在实例属性上，如果属性的类型是一个类，@Inject 的参数是可以省略的，因为装饰器是可以获取到正确的类型的。最终为了代码一致性，把这个特性去掉了，强制要求@Inject 必须指定参数。总结起来就是只有构造函数中可以不使用@Inject，但是如果使用@Inejct 都必须指定参数。还有一点需要注意，实例属性和构造函数的参数的类型可以是<code>interface</code>，但是@Inject 的参数不能是<code>interface</code>。</p>\n<h2 id=\"skip-装饰器函数\"> Skip 装饰器函数</h2>\n<div><pre><code><span>import</span> <span>{</span> Injectable<span>,</span> Skip <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n<span>import</span> <span>{</span> LoggerService <span>}</span> <span>from</span> <span>\"./logger.service.ts\"</span><span>;</span>\n\n<span><span>@</span><span>Injectable</span></span><span>(</span><span>)</span>\n<span>export</span> <span>class</span> <span>CountService</span> <span>{</span>\n  <span><span>@</span><span>Skip</span></span><span>(</span><span>)</span>\n  <span><span>@</span><span>Inject</span></span><span>(</span>LoggerService<span>)</span>\n  <span>private</span> logger1<span>:</span> LoggerService<span>,</span>\n\n  <span>constructor</span><span>(</span>\n    <span><span>@</span><span>Skip</span></span><span>(</span><span>)</span>\n    <span><span>@</span><span>Inject</span></span><span>(</span>LoggerService<span>)</span>\n    <span>private</span> logger2<span>:</span> LoggerService<span>,</span>\n  <span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>同样是属于装饰器函数，配合@Inject 一起使用。</p>\n<p>@Skip 主要是控制@Inject 的行为，在没有@Skip 时，@Inject 会从当前的 Injector 中获取对应的服务，如果找不到则会自动从其父级 Injector 中寻找对应的服务，最终一直到根 Injector 中寻找服务。那么@Skip 的作用就是默认从当前的 Injector 的父级 Injector 开始寻找服务，即跳过当前 Injector。</p>\n<p>这样的场景不是很多见，比如当前组件中有一个 Student 服务，代表某个学生，显然我们可以直接@Inject 获取一个 Student 服务。假设其父组件中维护也维护着一个 Student 服务，并且父组件中已经有一个服务实例代表该班级最优秀的学生。那么如果在当前的子组件中想要获取这个最优秀的学生就需要用到@Skip 功能了。</p>\n<p>我知道有些同学的脑洞比较大，假设有一个更加复杂的场景，在班级最优秀的学生上面还有年级最优秀、学校最优秀、全市最优秀、全国最优秀、全球最优秀。。。那么如何在最底层的组件中获取以上服务实例呢？答案就是<code>做不到</code>。应该说只是借助@Skip 是做不到这个功能的。具体方法可以<a href=\"\">参考这里</a>。</p>\n<p>其实一开始我是有实现@Skip(number)这个功能的，比如@Skip(5)就是向上跳过 5 层。最终考虑到这样的场景毕竟不是很常见的场景，反而因为实现这个功能降低了整个代码的效率。所以最终是去掉了这个功能。</p>\n<p>@Skip 有一个缺点，它可能不是从像你理解的那样跳过当前的 Injector。<a href=\"\">参考这里</a></p>\n<h2 id=\"self-装饰器函数\"> Self 装饰器函数</h2>\n<div><pre><code><span>import</span> <span>{</span> Injectable<span>,</span> Self <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n<span>import</span> <span>{</span> LoggerService <span>}</span> <span>from</span> <span>\"./logger.service.ts\"</span><span>;</span>\n\n<span><span>@</span><span>Injectable</span></span><span>(</span><span>)</span>\n<span>export</span> <span>class</span> <span>CountService</span> <span>{</span>\n  <span><span>@</span><span>Self</span></span><span>(</span><span>)</span>\n  <span><span>@</span><span>Inject</span></span><span>(</span>LoggerService<span>)</span>\n  <span>private</span> logger1<span>:</span> LoggerService<span>,</span>\n\n  <span>constructor</span><span>(</span>\n    <span><span>@</span><span>Self</span></span><span>(</span><span>)</span>\n    <span><span>@</span><span>Inject</span></span><span>(</span>LoggerService<span>)</span>\n    <span>private</span> logger2<span>:</span> LoggerService<span>,</span>\n  <span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>同样是属于装饰器函数，配合@Inject 一起使用。</p>\n<p>根据函数名应该已经猜到其作用了。它控制了@Inject 只会从当前所属的 Injector 中获取服务实例。\n咋一看似乎没什么实际用处。仔细一分析还真是没什么实际作用。</p>\n<p>因为是借鉴的 Angular 的 API，所以就给实现了。</p>\n<p>我的理解它最大的作用应该是起到警告的作用。比如我只想从当前 Injector 中获取 LoggerService，那么我必须要保证当前 Injector 中已经配置了 LoggerService 的 provider。如果我们手动已经保证了这一点，那么有没有@Self 是没有什么影响的。但是如果无意间我们删除了这个 provider，那么@Self 就会报错找不到服务。如果没有@Self 就有可能自动从更父级的 Injector 中寻找到 LoggerService，使得程序没有抛出异常，但是这可能不是我们想要的业务逻辑。</p>\n<h2 id=\"optional-装饰器函数\"> Optional 装饰器函数</h2>\n<div><pre><code><span>import</span> <span>{</span> Injectable<span>,</span> Optional<span>,</span> Self<span>,</span> Skip <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n<span>import</span> <span>{</span> LoggerService <span>}</span> <span>from</span> <span>\"./logger.service.ts\"</span><span>;</span>\n\n<span><span>@</span><span>Injectable</span></span><span>(</span><span>)</span>\n<span>export</span> <span>class</span> <span>CountService</span> <span>{</span>\n  <span><span>@</span><span>Optional</span></span><span>(</span><span>)</span>\n  <span><span>@</span><span>Inject</span></span><span>(</span>LoggerService<span>)</span>\n  <span>private</span> logger1<span>:</span> LoggerService<span>,</span>\n\n  <span><span>@</span><span>Optional</span></span><span>(</span><span>)</span>\n  <span><span>@</span><span>Self</span></span><span>(</span><span>)</span>\n  <span><span>@</span><span>Inject</span></span><span>(</span>LoggerService<span>)</span>\n  <span>private</span> logger2<span>:</span> LoggerService<span>,</span>\n\n  <span><span>@</span><span>Optional</span></span><span>(</span><span>)</span>\n  <span><span>@</span><span>Skip</span></span><span>(</span><span>)</span>\n  <span><span>@</span><span>Inject</span></span><span>(</span>LoggerService<span>)</span>\n  <span>private</span> logger3<span>:</span> LoggerService<span>,</span>\n\n  <span>constructor</span><span>(</span>\n    <span><span>@</span><span>Optional</span></span><span>(</span><span>)</span>\n    <span><span>@</span><span>Inject</span></span><span>(</span>LoggerService<span>)</span>\n    <span>private</span> logger4<span>:</span> LoggerService<span>,</span>\n\n    <span><span>@</span><span>Optional</span></span><span>(</span><span>)</span>\n    <span><span>@</span><span>Self</span></span><span>(</span><span>)</span>\n    <span><span>@</span><span>Inject</span></span><span>(</span>LoggerService<span>)</span>\n    <span>private</span> logger5<span>:</span> LoggerService<span>,</span>\n\n    <span><span>@</span><span>Optional</span></span><span>(</span><span>)</span>\n    <span><span>@</span><span>Skip</span></span><span>(</span><span>)</span>\n    <span><span>@</span><span>Inject</span></span><span>(</span>LoggerService<span>)</span>\n    <span>private</span> logger6<span>:</span> LoggerService<span>,</span>\n  <span>)</span> <span>{</span><span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>同样是属于装饰器函数，配合@Inject 一起使用。</p>\n<p>之前我们有提到当 Injector 找不到对应的服务的 provider 时，会抛出异常。如果认为某个属性可以是非必须的，就可以使用@Optional，这时如果找不到 provider，就会返回<code>undefined</code>。</p>\n<p><strong>注意</strong>：因为实例属性可能是 undefined，那么在调用实例属性的方法时就应该判空，像这样<code>this.logger1?.log('hello world');</code></p>\n<p><strong>注意</strong>：默认情况下，如果服务的标识符是一个类，那么在找不到这个服务的 provider 时，就会直接实例化这个类当作服务实例。当然如果有@Self 控制@Inject 的话，就不会自动实例化类了。</p>\n<p><strong>注意</strong>：上面提到的@Self 控制@Inject，所以就不会自动实例化类了。这在本库中是没有问题的。因为本库提供了一个默认的 Injector 作为根 Injector。实际上在<code>@kaokei/di</code>这个库中的实现要稍微复杂一些，当你手动实例时一个 Injector，并且没有指定父级 Injector 时，它自己就会作为根 Injector，而根 Injector 则又会自动实例化类了。具体代码可以<a href=\"\">参考这里</a>。</p>\n<h2 id=\"injectable-装饰器函数\"> Injectable 装饰器函数</h2>\n<div><pre><code><span>import</span> <span>{</span> Injectable <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n\n<span><span>@</span><span>Injectable</span></span><span>(</span><span>)</span>\n<span>export</span> <span>class</span> <span>LoggerService</span> <span>{</span>\n  <span>public</span> <span>log</span><span>(</span><span>...</span>msg<span>:</span> <span>any</span><span>[</span><span>]</span><span>)</span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span>\"from logger service ==>\"</span><span>,</span> <span>...</span>msg<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>Injectable 这个 api 是最简单的 api，只需要在定义服务类的时候，作为类的装饰器使用即可。</p>\n<p>Injectable 内部的实现是非常简单的，只是利用了 reflect-metadata 库简单的记录了服务类的构造函数的参数的类型信息。以便在后续实例化服务类的时候需要使用这些类型信息。</p>\n<p>可以理解为在构造函数的参数如果是类的时候，就可以不使用@Inject 的原因就在于@Injectable 已经收集到这些类的信息了。</p>\n<p><strong>注意</strong>：虽然对于没有构造函数的类可以不使用@Injectable，但是为了保持一致性，还是尽量所有的服务类都使用@Injectable。</p>\n<h2 id=\"component-装饰器函数\"> Component 装饰器函数</h2>\n<div><pre><code><span><span>@</span><span>Component</span></span><span>(</span><span>{</span>\n  providers<span>:</span> <span>[</span>\n    <span>{</span>\n      provide<span>:</span> <span>COUNTER_THEME</span><span>,</span>\n      useValue<span>:</span> <span>\"red\"</span>\n    <span>}</span><span>,</span>\n    CounterService\n  <span>]</span>\n<span>}</span><span>)</span>\n<span>export</span> <span>default</span> <span>class</span> <span>Person</span> <span>extends</span> <span>Vue</span><span>.</span><span>with</span><span>(</span>Props<span>)</span> <span>{</span>\n  <span>// ...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>从示例代码中可以看出，@Component 作为类的装饰器，其参数是和<a href=\"\">vue-class-component@8.x</a>中的@Options 函数基本是一致的。</p>\n<p>只不过在@Options 的基础上，@Component 还增加了一个参数，就是 providers，其效果就是 declareProviders 函数的作用，用于声明当前组件关联的 Injector 所需要的 providers。</p>\n<p>如果当前组件不需要 providers 参数，就可以这样写：</p>\n<div><pre><code><span><span>@</span><span>Component</span></span><span>(</span><span>)</span>\n<span>export</span> <span>default</span> <span>class</span> <span>Person</span> <span>extends</span> <span>Vue</span><span>.</span><span>with</span><span>(</span>Props<span>)</span> <span>{</span>\n  <span>// ...</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>关于 Component 这个 api 则是特意给类组件用的。它有三个作用：</p>\n<ul>\n<li>第一个作用是对 vue-class-component@8.x 中的<code>@Options</code>的封装；</li>\n<li>第二个作用是通过参数 providers 实现了 declareProviders 函数的功能；</li>\n<li>第三个作用是实现了类组件具有依赖注入的能力。\n<ul>\n<li>当然这里的注入是有限制的，只能注入实例属性，而不能注入构造函数参数。</li>\n<li>类组件只能注入别的服务，而不能把类组件当作服务注入。这点在 Angular 中是被支持的，但是我觉得这个功能过于强大了，不符合数据驱动视图的原则。</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意</strong>：<code>vue-class-component</code>在之前版本中都是使用的<code>@Component</code>这个装饰器，只是在版本 8 中修改为<code>@Options</code>了，正好本库可以捡个漏。</p>\n<h2 id=\"declareproviders-函数\"> declareProviders 函数</h2>\n<p>只能在 setup 函数中使用。</p>\n<div><pre><code><span>declareProviders</span><span>(</span><span>[</span>\n  SomeService<span>,</span>\n  <span>{</span>\n    provide<span>:</span> SomeService<span>,</span>\n    useClass<span>:</span> SomeService\n  <span>}</span><span>,</span>\n  <span>{</span>\n    provide<span>:</span> SomeService<span>,</span>\n    useClass<span>:</span> SomeOtherService\n  <span>}</span><span>,</span>\n  <span>{</span>\n    provide<span>:</span> SomeService<span>,</span>\n    useValue<span>:</span> someServiceInstance\n  <span>}</span><span>,</span>\n  <span>{</span>\n    provide<span>:</span> SomeService<span>,</span>\n    useExisting<span>:</span> SomeOtherService\n  <span>}</span><span>,</span>\n  <span>{</span>\n    provide<span>:</span> SomeService<span>,</span>\n    <span>useFactory</span><span>:</span> <span>(</span>dependService1<span>,</span> dependService2<span>,</span> dependService3<span>)</span> <span>=></span> <span>{</span>\n      <span>return</span> someServiceInstance<span>;</span>\n    <span>}</span><span>,</span>\n    deps<span>:</span> <span>[</span>DependService1<span>,</span> DependService2<span>,</span> DependService3<span>]</span>\n  <span>}</span>\n<span>]</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>可以一次性定义多个服务的 provider。以上列出了所有 provide 的形式。</p>\n<p>在解释其作用之前，我们必须了解 Injector 是类似 dom 树一样的树状结构，每个 Injector 都有一个父级 Injector，直到根 Injector 的父级为 null。</p>\n<p>当我们在组件的 setup 函数中调用了 declareProviders，就意味着这个组件关联了一个新的 Injector，这个 Injector 会根据我们刚才配置的 providers 来生成服务实例。</p>\n<p>想象一下，如果整个应用中所有的服务都是不同的，都是全局单例的。那么我们可能不需要使用<code>declareProviders</code>，把所有服务都放到根 Injector 中即可。</p>\n<p>但是如果我们想要实现服务实例的生命周期和某个组件保持一致，最常见的场景就是路由组件。那么显然我们应该把服务定义在对应的路由组件中，而不是在根 Injector 中。</p>\n<p>除了控制服务实例的生命周期，另一个功能就是可以实现同一个服务的多例效果。显而易见如果我们在不同的组件中调用<code>declareProviders</code>，并且配置了同一个服务。那么在获取服务实例时就能得到同一个服务的不同实例。</p>\n<p><strong>注意</strong>：<code>declareProviders</code>在同一个 setup 中只能调用一次，而且应该在最顶部调用。</p>\n<h2 id=\"useservice-函数\"> useService 函数</h2>\n<p>只能在 setup 函数中使用。</p>\n<div><pre><code><span>const</span> someService <span>=</span> <span>useService</span><span>(</span>SomeService<span>)</span><span>;</span>\n\n<span>const</span> <span>[</span>someService1<span>,</span> someService2<span>,</span> someService3<span>]</span> <span>=</span> <span>useService</span><span>(</span><span>[</span>\n  SomeService1<span>,</span>\n  SomeService2<span>,</span>\n  SomeService3\n<span>]</span><span>)</span><span>;</span>\n\n<span>const</span> someService <span>=</span> <span>useService</span><span>(</span>SomeService<span>,</span> <span>{</span>\n  skip<span>:</span> <span>true</span><span>,</span>\n  optional<span>:</span> <span>true</span><span>,</span>\n  defaultValue<span>:</span> <span>\"somwService\"</span>\n<span>}</span><span>)</span><span>;</span>\n\n<span>const</span> someService <span>=</span> <span>useService</span><span>(</span>SomeService<span>,</span> <span>{</span>\n  self<span>:</span> <span>true</span><span>,</span>\n  optional<span>:</span> <span>true</span><span>,</span>\n  defaultValue<span>:</span> <span>\"somwService\"</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>我们可以一次获取单个服务的实例对象，也可以一次性获取多个服务的实例对象。而且可以指定第二个参数来控制 useService 的解析过程。</p>\n<p>useService 的作用非常类似<code>@Inject</code>。尤其是第二个参数，支持这些属性：</p>\n<ul>\n<li>self 对应@Self</li>\n<li>skip 对应@Skip</li>\n<li>optional 对应@Optional</li>\n<li>defaultValue 没有对应的装饰器函数，因为可以直接使用<code>=</code>来赋值默认值</li>\n</ul>\n<p>注意到 useService 非常优秀的一点就是返回值都是自带类型的，所以可以非常方便的使用<code>.</code>来知道这个类有哪些属性和方法。</p>\n<p>另外一点就是其返回值已经是 reactive 的，可以直接在 vue 模版中绑定。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "最佳实践指导",
      "url": "https://www.kaokei.com/project/use-vue-service/articles/best-practices/",
      "id": "https://www.kaokei.com/project/use-vue-service/articles/best-practices/",
      "content_html": "<h2 id=\"最佳实践\"> 最佳实践</h2>\n<p>declareProviders 一定要在 setup 的顶部使用。如果先调用了 useService，然后再调用 declareProviders，就会导致获取的服务可能不是我们期望的。</p>\n<p>虽然基于服务的依赖注入用起来很方便，但是也不应该滥用，还是需要考虑使用场景。我建议在容器组件中使用服务是比较适合的。但是在受控组件中还是推荐使用 props/emit 的方式进行交互。</p>\n<p>建议自己基于 axios/superagent 封装自己的 HttpClientService\n然后基于 HttpClientService 封装自己的 DaoService\n我个人建议是一个项目只需要一个 DaoService，并不需要按照模块划分成多个。当然你也可以按照领域划分成不同的 DaoService，只是我认为过于繁琐了。\n我理解一个项目大多数情况下很难超过 200 条接口。维护在一个服务中是可以接受的。\n再然后 StudentService，TeacherService，ClassService 这些业务 Service 直接注入 DaoService 即可。</p>\n<p>数据的生命周期应该和组件的生命周期一致，当组件销毁时，数据也应该跟着销毁。\n子组件的生命周期应该受到父组件的生命周期的约束。当父组件销毁时，子组件也要跟着销毁。\n如果子组件的销毁完全只受父组件控制，那么可以把所有数据都放在父组件中即可。因为这样也可以保证父子组件和数据的生命周期是一致的。\n如果子组件也会绑定到子路由，则相应的数据也可以绑定到该子组件。还是在保证子组件的数据和子组件的生命周期一致。\n目前来看，数据默认会绑定到全局。其他情况数据应该绑定到路由组件，以及子路由组件上。</p>\n<p>不建议通过 props 传递 service</p>\n<h2 id=\"skip-只能跳过一层-injector\"> @skip 只能跳过一层 Injector</h2>\n<p>目前我们只实现了@Skip 向上跳过一层 Injector。</p>\n<p>其实一开始我是打算实现@Skip(number)来指定向上跳过若干层。后来发现实现这个功能增加很多的复杂度，又考虑到这个功能的使用场景不是很多，所以给废弃了。</p>\n<p>那么如果确实需要跳过多层来获取服务呢？应该怎么实现呢？</p>\n<p>其实可以借助 useClass 来实现，比如现在有一个服务是 UserService。那么我们可以在各个组件中这样定义 provider。</p>\n<div><pre><code>//爷爷组件中\n{\n  provide: &#39;aUserService&#39;,\n  useClass: UserService\n}\n// 父亲组件中\n{\n  provide: &#39;bUserService&#39;,\n  useClass: UserService\n}\n// 儿子组件中\n{\n  provide: &#39;cUserService&#39;,\n  useClass: UserService\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>那么我们在最底层组件中随时可以获取任意的服务，因为他们的 provide 都不一样。比如这样：</p>\n<div><pre><code>// 孙子组件中可以直接获取到爷爷组件中的服务。\nconst aUserService = useService(&#39;aUserService&#39;);\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"skip-和-self-本身的缺陷\"> @Skip 和@Self 本身的缺陷</h2>\n<p>这个问题解释起来还比较复杂，主要是涉及到 provide/inject 的实现机制。也就是 vue 中 context 是如何工作的。最好是自己看源码，这里稍微解释一下。</p>\n<p>每个组件实例上都有一个属性是<code>provides</code>，这个对象默认是指向父组件的<code>provides</code>属性，根组件的<code>provides</code>属性是 null。</p>\n<p>当在某个组件中调用 provide 方法时，则会把其父组件的<code>provides</code>属性当作原型创建一个空对象<code>Object.create(parent.provides);</code>，然后给这个空对象设置刚才调用 provide 方法的数据。</p>\n<p>按照这个逻辑，其实整个 provides 对象是构成一条完整的原型链的。但是问题就在于，如果一个子组件中没有调用 provide 方法，那么其<code>provides</code>属性是直接等于父组件的<code>provides</code>属性的。</p>\n<p>翻译一下上面的话的含义就是，如果在父组件中调用了<code>declareProviders()</code>，但是子组件中没有调用这个方法，那么在子组件中通过<code>useService</code>获取服务时，是直接从父组件所关联的 Injector 开始查找服务的。这样就导致<code>@Skip</code>和<code>@Self</code>和我们正常理解的意思稍微有一些偏差。</p>\n<p>这里确实需要人为的注意一下，当你使用@Skip 和@Self 时，当前组件一定是调用了<code>declareProviders()</code>的，否则除非你明确的知道你在做什么。</p>\n<p><strong>注意</strong>：declareProviders 是依赖 provide 实现的，useService 是依赖 inject 来实现的。</p>\n<h2 id=\"kaokei-di-支持默认值\"> @kaokei/di 支持默认值</h2>\n<p>依赖注入框架并没有单独实现一个@DefaultValue 这样的装饰器，因为可以直接使用赋值语句来设置默认值。</p>\n<p>但是需要注意默认值只有在设置@Optional 装饰器，并且确实没有找到该服务时才会生效，其余情况下是不会起作用的。</p>\n<h2 id=\"useexisting-vs-useclass\"> useExisting vs useClass</h2>\n<p><a href=\"https://angular.cn/guide/dependency-injection-providers\" target=\"_blank\" rel=\"noopener noreferrer\">参考 Angular 的文档</a>，可以更好的了解他两的区别。</p>\n<p>解释 useExisting 和 useClass 的区别。</p>\n<p>使用 useClass，只要 provide 的名字不一样，就算 useClass 指向的服务相同。那么也算是不同的服务，最终相当于得到了同一个服务的多个实例。</p>\n<p>useExisting 则是刚好相反，即使 provide 不相同，但是只要 useExisting 指向的服务是存在的，则立即返回这个服务实例。并不会创建一个新的实例。</p>\n<h2 id=\"使用-injectionkey-保留类型信息\"> 使用 InjectionKey 保留类型信息</h2>\n<p><a href=\"https://angular.cn/guide/dependency-injection-providers#using-an-injectiontoken-object\" target=\"_blank\" rel=\"noopener noreferrer\">参考 Angular 的文档</a></p>\n<p>只不过语法稍微有些区别。</p>\n<div><pre><code><span>import</span> <span>{</span> InjectionKey <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n<span>type</span> <span>SomeServiceKey</span> <span>=</span> InjectionKey<span>&lt;</span>SomeService<span>></span><span>;</span>\n<span>const</span> someServiceKey<span>:</span> SomeServiceKey <span>=</span> <span>symbol</span><span>(</span><span>)</span><span>;</span>\n\n<span>// someService的类型就是SomeService</span>\n<span>// 这就是InjectionKey所起到的作用</span>\n<span>// 如果SomeService是一个类的话，其实是没有必要这样做的</span>\n<span>// 但是如果SomeService是一个接口的话，则只能这样做才能保留类型信息</span>\n<span>const</span> someService <span>=</span> <span>useService</span><span>(</span>someServiceKey<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id=\"根组件和根-injector-的关系\"> 根组件和根 Injector 的关系</h2>\n<p>前面的文章中一直有说到根组件和根 Injector 是绑定的，实际上这么描述是不够准确的。</p>\n<p>本库自带了一个全局唯一的根 Injector，如果整个应用只有一个根组件，可以理解为根组件和根 Injector 是绑定的。</p>\n<p>但是整个应用是可能有多个根组件的，在 vue 中，我们可以多次调用 createApp 来创建多个根组件。每个根组件都是独立的。这样就导致根 Injector 还是处在最顶层。我们可以手动调用</p>\n<div><pre><code>app1.use(本库);\napp2.use(本库);\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>上面的代码的作用是手动给每个根组件绑定一个 Injector。这样就能做到某些服务只给某个 app 使用。</p>\n<p>实际上我到现在都没有遇到过一个应用中有多个根组件的场景。所以也不用太关心这个问题。</p>\n<h2 id=\"禁止使用-watch\"> 禁止使用 watch</h2>\n<p>watch 有两个优势。</p>\n<p>第一，watch 某个属性，属性变化时更新 10 个属性。如果通过 computed 来实现的话，就需要重复 10 遍代码。</p>\n<p>第二，watch 某个属性，属性变化时执行某些副作用，比如请求某个 api、输出日志等。这种功能显然是不能通过 computed 来实现的。</p>\n<p>既然如此，为什么还是不建议使用 watch 呢？</p>\n<p>因为第一点出现的场景不会特别夸张，就算有 2，3 个属性共同依赖某个属性，那也是建议都写成 computed，而不是把更新逻辑放在 watch 中。</p>\n<p>第二点我建议是在触发事件的地方去手动调用更新逻辑，而不是依赖数据驱动副作用。</p>\n<p>总结以上两点的本质原因在于，我们可以利用数据驱动模版更新，但是我们不应该利用数据驱动其他副作用。</p>\n<p>这涉及到心智模型的问题，我期望的心智模型是数据驱动模版，模版响应事件，在事件中修改数据，数据反过来又驱动模版更新。</p>\n<p>这中间最多可以接受 computed 对数据层做一层聚合，但是仍然可以看作是数据层的一部分。</p>\n<p>但是如果引入了 watch 就不一样了。因为它破坏了这个简单的心智模型。</p>\n<p>第一点、数据变化了不仅仅会驱动模版更新，还会触发 watch 中定义的副作用，谁也不知道这个副作用最终又是怎么影响数据和模版的。</p>\n<p>第二点、原本的逻辑是模版响应事件，我们直接在事件中更新数据，数据再反应到模版上。但是引入 watch 之后，我们可能会写出这样的代码：我们在事件中只会更新某个数据，然后在 watch 中观察这个数据，然后执行相应的副作用，最终修改了我们想要的数据，数据驱动模版更新。</p>\n<p>很明显我们发现心智模型不一样了，变得更加复杂了。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "组件间通信方式",
      "url": "https://www.kaokei.com/project/use-vue-service/articles/communication-between-components/",
      "id": "https://www.kaokei.com/project/use-vue-service/articles/communication-between-components/",
      "content_html": "<h1 id=\"组件间通信方式\"> 组件间通信方式</h1>\n<h2 id=\"父子组件\"> 父子组件</h2>\n<p>父组件通过 props 传递数据给子组件\n父组件监听子组件 emit 出来的事件，接受子组件的数据</p>\n<p><strong>注意点一</strong>\n父组件不仅仅可以传递数据给子组件，也可以传递函数给子组件，然后在子组件中调用该函数，从而修改父组件中的数据。这种方式也是可以的，而且这也是 react 中的常规操作。</p>\n<p><strong>注意点二</strong>\n子组件 emit 事件，如果是自定义事件，那么只会传递给父组件。父组件的父组件是接受不到该事件的。但是如果是原生事件，那么就能接收到。</p>\n<h2 id=\"爷孙组件\"> 爷孙组件</h2>\n<p>注意这里的爷孙并不是特指爷爷和孙子，而是指那些组件层级大于等于 2 层的组件。</p>\n<p>对于这种组件关系，我们仍然可以通过 props 一层层地去传递数据到最底层组件，也可以通过一层层的 emit 事件传递到最顶层组件。</p>\n<p>但是这显然加大了工作量，而且不利于代码维护。</p>\n<h2 id=\"兄弟组件\"> 兄弟组件</h2>\n<p>通常需要考虑把兄弟组件都需要的数据提升到最近的公共父组件中，这样每个兄弟组件都只需要和父组件进行沟通即可，即通过 props 和 emit 来转化为爷孙组件/父子组件的通信方式。这样只要父组件中的数据变化了，那么两个兄弟组件都会得到更新。</p>\n<p>还有一种场景，就是 A 组件 emit 事件到父组件中，父组件监听该事件，然后通过 ref 直接调用 B 组件中的方法。反过来也可以实现 B 组件触发 A 组件中的方法。</p>\n<h2 id=\"事件总线\"> 事件总线</h2>\n<p>还有一种方式则是通过公共事件总线来传递消息。<code>const bus = new Vue();</code>\n在任意组件中可以</p>\n<div><pre><code>bus.$on(&#39;eventName&#39;, eventHandler);\nbus.$emit(&#39;eventName&#39;);\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>这是一种功能非常强大的手段，可以做到整个页面中任意组件之间的通信，但是同时也是非常糟糕的一种设计。因为我们只能通过全局搜索才能找到哪些组件会触发事件，哪些组件会接受事件。</p>\n<h2 id=\"redux-or-vuex\"> redux or vuex</h2>\n<p>redux 和 vuex 都是全局唯一数据源。然后通过 dispatch 一个字符串来更新数据。</p>\n<p>和事件总线一样，通过字符串来触发更新逻辑对于开发来说是非常效率低下的。</p>\n<p>但是相对于事件总线来说要友好一些，主要是因为 dispatch 之后的逻辑非常明确，就是修改 store 中的数据。至于有哪些组件依赖了 store 中的数据则不是我们需要关心的。但是事件总线方案中，我们是需要时刻关心有哪些组件中订阅了某个事件的，至少需要保证事件不重名，否则就乱套了。</p>\n<h2 id=\"本库的实现方式\"> 本库的实现方式</h2>\n<p>考虑 props 和 emit 的本质其实是把数据和方法分割开了。那么本库的实现方式正好与此相反。</p>\n<p>我们把数据和方法集合到一起变成一个对象，我们称之为服务。然后通过 provide/inject 的技术，可以方便的在任意组件中获取这个服务。只要我们获取到这个对象，我们可以在模版中渲染这个对象的数据，我们可以直接调用这个对象的方法。</p>\n<p>因为这个对象本身就是 reactive 的，所以只要数据变化了，所有依赖这个服务的组件都会自动更新。</p>\n<p>由于是通过 provide/inject 来获取的服务，所以是可以跨越多个组件层级直接获取服务对象的。</p>\n<p>因为服务对象是一个类的实例，所以数据类型是非常明确的，避免了上述<code>字符串</code>丢失类型的问题。</p>\n<p>我们还可以控制 provide 的位置，去控制服务对象的范围。因为服务是和组件关联的，当组件销毁的时候，服务也会跟着销毁，间接控制了服务的生命周期。</p>\n<p>虽然本库功能很强大，但是不意味着在整个项目中全部使用它，实际上本库还是比较适合那些容器组件。而对于那些受控组件则还是建议使用 props/emit 技术。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "组件与服务",
      "url": "https://www.kaokei.com/project/use-vue-service/articles/component-and-service/",
      "id": "https://www.kaokei.com/project/use-vue-service/articles/component-and-service/",
      "content_html": "<h2 id=\"option-组件-类组件和服务的关系\"> option 组件，类组件和服务的关系</h2>\n<p>option 组件本身就是一个对象，这个对象预定义了一套属性，比如 data、methods、components 等。</p>\n<p>类组件看起来像是一个类，只不过是把一部分 option 组件中的属性定义为类的成员属性。另一部分不支持的属性还是需要借助<code>vue-class-component</code>这个库来支持。比如 watch 属性，只能定义在<code>@Options</code>这个装饰器中。总之看上去会有点不伦不类。\n通过深入分析<code>vue-class-component</code>这个库，可以发现最终这个类还是被转化成 option 组件了，所以从性能上来看也并不推荐使用类组件。\n当然类组件也是有优势的，比如在 angular 中，组件只能是类，大多数服务也是类，而且都可以使用依赖注入，整体上来看是比较一致的。</p>\n<p>服务可以是任意数据或者任意方法或者数据和方法的集合。在依赖注入框架中，大多数服务被定义成类，因为类对依赖注入是最友好的。</p>\n<h2 id=\"为什么使用类来作为服务\"> 为什么使用类来作为服务</h2>\n<p>类是一种抽象，而类的实例化过程就是从抽象到具体的转变。正是因为存在这一实例化的过程，所以就存在干预这个过程的机会。</p>\n<p>类本身是一个语法糖，每个实例独享数据，但是共享方法。在存在多个实例时也是一种性能优化。</p>\n<p>而且类是支持装饰器的，装饰器则是提供了一种声明式语法。</p>\n<h2 id=\"类组件是如何收集数据的\"> 类组件是如何收集数据的</h2>\n<p>查看<code>vue-class-component</code>的<a href=\"https://github.com/vuejs/vue-class-component/blob/16433462b40aefecc030919623f17b0ec9afe61c/dist/vue-class-component.esm-browser.js#L160\" target=\"_blank\" rel=\"noopener noreferrer\">源码</a>可以知道，类组件会被转化为 Option 组件，而且会自动生成一个 setup 函数作为该组件的属性。setup 函数的返回值其实就是类组件的所有实例属性。\n而且注意到类会在 setup 中被实例化，才能收集到实例属性。\n还可以观察到<code>__s</code>属性，这个属性其实就是我们使用的<code>import { setup } from 'vue-class-component'</code>，这个<code>setup</code>函数的返回值的属性。其定义在<a href=\"https://github.com/vuejs/vue-class-component/blob/16433462b40aefecc030919623f17b0ec9afe61c/dist/vue-class-component.esm-browser.js#L252\" target=\"_blank\" rel=\"noopener noreferrer\">这里</a>。</p>\n<p>以上的介绍是指<code>vue-class-component</code>的正常工作逻辑。也就是<code>@Options</code>的工作逻辑。如果是使用了本库的<code>@Component</code>这个装饰器。则又有一些不同。</p>\n<p>在<code>@Component</code>中，会对上面生成的 setup 属性再次进行一次包装，再生成一个新的 setup 属性。在这个新的 setup 函数中实现我们自己的依赖注入逻辑。粗略的概括起来就是首先根据类来获取需要注入的数据 A，然后在计算出原属 setup 函数的返回值 B，最后合并数据 A 和数据 B 得到最终返回值 C。这个 C 就是新的 setup 函数的返回值。</p>\n<p>所以可以发现当前类组件的依赖注入是在 setup 执行完之后才注入的。</p>\n<p>这个目前还算不上是缺陷，因为类组件的 setup 函数是 vue-class-component 固定实现的，并不含有业务逻辑。</p>\n<p>意味着该原始 setup 函数中并不会访问类的实例属性。本质是 vue-class-component 提供的 setup 函数本身不能访问<code>this.$data</code>。</p>\n<p>它只能访问<code>this.$props $emit $attrs $slots</code>。</p>\n<p>需要注意 setup 不是类组件的合法方法，意味着我们不能在类组件中定义 setup 方法。</p>\n<p>注意虽然 option 组件中的 setup 函数虽然也是只能访问 props 和 ctx，但是一个组件只有一个 setup 函数，在该 setup 函数内部定义的数据，是可以衍生出新数据的。</p>\n<p>但是现在类组件中每个实例属性都对应一个 setup 函数，这些 setup 函数是互相独立的，没有办法做到数据之间的衍生。倒是可以通过定义 getter 方法来定义新数据。</p>\n<h2 id=\"如何在类组件中使用-setup\"> 如何在类组件中使用 setup</h2>\n<p>首先在 vue 中存在两种组件形式，一种是 Option 组件，即直接声明一个对象，然后配置固定的某些属性即代表一个组件。还有一种形式是类组件。</p>\n<p>类组件本身是不被 vue 支持的，需要借助 vue-class-component 才能工作。还好 vue-class-component 也是 vue 官方支持的。</p>\n<p>在 Option 组件中，我们可以直接配置 setup 属性。但是在类组件中，我们不能在类中直接写一个 setup 属性/或者 setup 函数。</p>\n<p>实际上在类组件的类中只能写特定的属性和方法。比如生命周期函数，其他函数都相当于 Option 组件中的 methods 中定义的方法。</p>\n<p>类组件中的属性则相当于 Option 组件中的 data 定义的数据。</p>\n<p>我们可以发现，在 Option 组件还有其他的属性或者方法似乎不知道在什么地方定义了。</p>\n<p>比如 watch 属性，computed 属性，setup 函数，props 属性，directives 属性，components 属性。</p>\n<p>对于 computed 属性应该定义为类的 getter 方法。</p>\n<p>对于 setup，则需要<code>import { setup } from 'vue-class-component'</code>，然后使用 setup 函数初始化类的属性。</p>\n<p>对于 props 属性，则需要<code>class MyComponent extends Vue.with(SomeProps) {}</code>，可以<a href=\"https://github.com/vuejs/vue-class-component/issues/465\" target=\"_blank\" rel=\"noopener noreferrer\">参考这里</a></p>\n<p>其他的属性和函数都需要在<code>@Options</code>装饰器中定义。可以<a href=\"https://github.com/vuejs/vue-class-component/issues/406\" target=\"_blank\" rel=\"noopener noreferrer\">参考这里</a></p>\n<p>顺便提一句，我本以为在类组件中使用 setup，就像在 Option 组件中一样简单，直接在类中定义 setup 方法就可以了。但是实际上这样是行不通的。</p>\n<p>如果我们在类组件中定义 setup 方法，那么最终会被 vue-class-component 覆盖掉。实际上 vue-class-component 内部会自动生成一个 setup 函数来收集数据。</p>\n<p>所以需要使用 vue-class-component 提供的 setup 函数来延迟初始化类的属性。</p>\n<p>根据官方 issue 来看，不能在类中定义 setup 方法的原因是，我们不能根据 setup 方法的返回值类型来修改类的类型。这里的意思是指 setup 的返回值应该设置为类的成员属性，我们可以在运行时做到这一点，但是在类型提示方面做不到。</p>\n<h2 id=\"如何使用-declareproviders\"> 如何使用 declareProviders</h2>\n<p>可以说在 99%的场景中我们都不需要使用 declareProviders，除非业务足够复杂。</p>\n<p>当我们不使用 declareProviders 时，意味着所有的服务都是全局的，那么所有的服务的生命周期都是全局的。</p>\n<p>如果我们的业务稍微复杂一点，我们可以在页面路由层面使用 declareProviders，这样这些服务的生命周期就是路由级别的，当切换路由的时候，这些服务也会被卸载。</p>\n<p>如果我们的业务更加复杂，可以在 2 级路由，3 级路由都这样操作。</p>\n<p>上面提到的都是针对路由的操作，之所以首先提到路由，是因为路由的切换，我们可以非常明显的感受到页面的更新，也就是某些组件的卸载和某些组件的创建。这同时也是生命周期的体现。</p>\n<p>那么在有生命周期的地方，我们都是可以使用 declareProviders 的。比如复杂的弹窗，tabs 切换。但是实际上我觉得没有必要把服务的生命周期卡的这么死，稍微把服务的生命周期提升一点也是无伤大雅的。</p>\n<p>还有一种场景就是某个组件本身需要使用 declareProviders，即我们希望每个组件实例都有自己的服务实例，而不是所有的组件共享服务。比如 Table 组件我们可以提供一个选择了 table 的哪些行的、以及全选/取消全选这种服务。显然我们希望这个服务是每个 table 组件独享的。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "依赖注入",
      "url": "https://www.kaokei.com/project/use-vue-service/articles/dependency-injection/",
      "id": "https://www.kaokei.com/project/use-vue-service/articles/dependency-injection/",
      "content_html": "<h2 id=\"什么是依赖注入\"> 什么是依赖注入</h2>\n<p>关于依赖注入的概念可以参考 Angular 的文档，<a href=\"https://angular.cn/guide/dependency-injection\" target=\"_blank\" rel=\"noopener noreferrer\">Angular 中的依赖注入</a>。</p>\n<p>首先不得不提到的一点是什么是依赖注入，我在网上搜索了很多文章，专业术语也有很多，看的我迷迷糊糊的。我尝试记录一下我自己的理解。</p>\n<p>首先从名字入手，依赖注入可以分成依赖和注入。</p>\n<h4 id=\"什么是依赖\"> 什么是依赖？</h4>\n<p>在讨论依赖之前，必须先了解什么是服务，不考虑边界情况下，可以把服务理解为数据和方法的集合，即一个对象既包含数据又包含方法就可以称为为服务。</p>\n<p>一般我们会通过实例化一个类来得到这个对象。我们可以想象的到这个类的某个实例属性有可能又是另一个类的实例对象。这个过程可以一直进行下去。比如这样的依赖关系图：</p>\n<div><pre><code>A --&gt; B、C、D\nB --&gt; C、D\nC --&gt; D、E\nD --&gt; E、F\nE --&gt; F\nF 没有依赖\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面的依赖图代表 A 这个类有三个实例属性<code>b、c、d</code>分别是<code>B、C、D</code>这三个类的实例对象。意味着<code>A</code>类是依赖<code>B、C、D</code>这 3 个类的。\n而<code>B</code>类又是依赖<code>C、D</code>这两个类的。依次类推我们可以知道<code>C、D、E</code>这三个类的依赖，注意到<code>F</code>类是没有依赖的。</p>\n<p>具体从类的角度来讲，可以在 2 个地方来描述这种依赖关系。\n第 1 个地方是在实例属性上声明该属性是另一个类的实例。\n第 2 个地方就是在类的构造函数中声明参数是某个类的实例属性。\n示例代码如下：</p>\n<div><pre><code><span>import</span> <span>{</span> Injectable <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n\n<span><span>@</span><span>Injectable</span></span><span>(</span><span>)</span>\n<span>export</span> <span>class</span> <span>LoggerService</span> <span>{</span>\n  <span>public</span> <span>log</span><span>(</span><span>...</span>msg<span>:</span> <span>any</span><span>[</span><span>]</span><span>)</span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span>\"from logger service ==>\"</span><span>,</span> <span>...</span>msg<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span><span>@</span><span>Injectable</span></span><span>(</span><span>)</span>\n<span>export</span> <span>class</span> <span>CountService</span> <span>{</span>\n  <span>public</span> count <span>=</span> <span>0</span><span>;</span> <span>// 该属性是普通属性，不是依赖</span>\n\n  <span><span>@</span><span>Inject</span></span><span>(</span>LoggerService<span>)</span>\n  <span>public</span> logger<span>!</span><span>:</span> LoggerService<span>;</span> <span>// 该属性是依赖</span>\n\n  <span>constructor</span><span>(</span>\n    <span>private</span> logger2<span>:</span> LoggerService <span>// 该参数是依赖</span>\n  <span>)</span> <span>{</span><span>}</span>\n\n  <span>public</span> <span>addOne</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>count<span>++</span><span>;</span>\n    <span>this</span><span>.</span>logger<span>.</span><span>log</span><span>(</span><span>\"from logger addOne ==> \"</span><span>,</span> <span>this</span><span>.</span>count<span>)</span><span>;</span>\n    <span>this</span><span>.</span>logger2<span>.</span><span>log</span><span>(</span><span>\"from logger2 addOne ==> \"</span><span>,</span> <span>this</span><span>.</span>count<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h4 id=\"什么是注入呢\"> 什么是注入呢？</h4>\n<p>在谈论注入之前，我们先来看看，如果没有依赖注入框架，我们怎么实例化 CountService 呢？</p>\n<p>显然在我们调用构造函数之前，我们需要提前准备好参数。即<code>const logger = new LoggerService();</code>。</p>\n<p>然后就可以调用构造函数了，<code>const countService = new CountService(logger);</code>。此时我们就完成了 CountService 的实例化。</p>\n<p>但是似乎还有一个缺陷，就是现在这个实例仍然缺少一个实例属性<code>logger</code>。最简单的解决办法就是<code>countService.logger = logger;</code>。</p>\n<p>这样我们终于完成了全部的实例化过程。注意到这里我们复用了<code>logger</code>对象。即 logger 属性和 logger2 属性指向了同一个对象。</p>\n<p>这个例子只是演示实例化过程。实际业务中应该很少会有两个属性指向同一个对象。</p>\n<p>其实无意中我们已经介绍了两种注入服务的方式的手动实现版本，即<code>构造函数参数注入</code>和<code>属性注入</code>。</p>\n<p>这里再顺嘴提一句还存在另一种注入方式，就是<code>setter注入</code>，简单介绍就是在类中定义一个方法，在方法内设置属性值。然后再调用该方法。类似这样：<code>countService.setLogger(logger);</code>。在有些依赖注入框架中优先建议使用<code>setter注入</code>，而不建议使用<code>属性注入</code>。不过本库只是实现了<code>属性注入</code>，而不支持<code>setter注入</code>。</p>\n<p>书归正传，上面详细介绍了<code>依赖注入</code>的手动实现过程。那么依赖注入框架的作用就是把上面的过程自动化。</p>\n<p>通过依赖注入框架，我们可以这样来获取 countService 实例对象。</p>\n<div><pre><code><span>const</span> countService <span>=</span> <span>useService</span><span>(</span>CountService<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>和上面的手动的实例化过程对比，是不是发现这样写的代码就简单多了，这就是依赖注入框架的魅力，实际上依赖关系越复杂，依赖注入框架的优势就越明显。</p>\n<p>这里再多嘴说一句，从上面的分析来看，useService 这个函数是用来获取实例的，但却不一定是必须的。</p>\n<p>比如在 angular 中，就不需要这样一个函数来获取实例。因为 angular 应用中组件的形式只能是类，在这个组件类中就可以直接使用@Inject 来注入服务了。</p>\n<p>但是在 Vue 中，Vue 组件的形式有两种，一种是类组件，这种情况我们也可以不使用 useService，可以直接使用@Inject 来注入服务；另一种情况则是 Option 组件，因为 Option 组件不是类，所以不能使用装饰器。只能使用 useService 这种类似 hooks 的方法类获取实例对象。</p>\n<p>我的总结是依赖注入实在没有什么技术含量，也没有什么高大上的地方。不要被陌生的技术名词给吓到了。\n本质上就是 Key-Value 的魔法。比如：</p>\n<div><pre><code><span>defineKeyValue</span><span>(</span><span>\"tokenA\"</span><span>,</span> <span>\"valueA\"</span><span>)</span><span>;</span> <span>// 内部使用map来记录对应关系</span>\n<span>const</span> value <span>=</span> <span>getValueByKey</span><span>(</span><span>\"tokenA\"</span><span>)</span><span>;</span> <span>// 再通过map.get(key)获取数据即可</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>可以说这就是最简单的依赖注入的简单实现。但是它实在是太简单了，处理的场景有限，所以价值不大。至少要再加上类的实例化能力。</p>\n<div><pre><code><span>defineKeyValue</span><span>(</span><span>\"tokenA\"</span><span>,</span> ClassA<span>)</span><span>;</span> <span>// 内部使用map来记录对应关系</span>\n<span>const</span> value <span>=</span> <span>getValueByKey</span><span>(</span><span>\"tokenA\"</span><span>)</span><span>;</span> <span>// 再通过map.get(key)获取到ClassA，然后实例化一个实例返回</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>当然如果要处理 ClassA 依赖 ClassB 这种场景，就需要其他方面的支持。比如 typescript 以及 decorator。因为这属于技术问题，不属于概念问题，这里不再细述。</p>\n<p>现在我们这个简易的依赖注入库实现了两种能力，如果判断是类，则去实例化；否值直接返回。我们可以沿着这个思路继续添加新能力。比如如果是普通函数，那么就当作普通函数来执行，然后把这个函数的返回值当作服务返回，这样我们就有三种能力了。</p>\n<p>主要是介绍这种扩展的思路，只要有这种扩展的思路，我们就可以继续扩展更多的能力，无非就是添加一个<code>if-else</code>分支的事情。</p>\n<p>排除掉这种扩展思路本身，我们的依赖注入框架还有什么局限性吗？</p>\n<p>其实还有命名空间单一的问题。显然上面所有的数据都处于同一个全局命名空间下。因为<code>defineKeyValue</code>和<code>getValueByKey</code>是一个全局函数。那么所有的配置信息就只有一份。这种状况在大多数场景应该也没有什么问题。但是确实还可以继续提升一下。</p>\n<p>我们需要继续引入一个新的概念，就是<code>Injector</code>。通过下面的伪代码我们可以快速了解什么是 Injector。</p>\n<div><pre><code><span>const</span> parentInjector <span>=</span> <span>new</span> <span>Injector</span><span>(</span><span>)</span><span>;</span>\n<span>const</span> childInjector <span>=</span> <span>new</span> <span>Injector</span><span>(</span><span>)</span><span>;</span>\nchildInjector<span>.</span>parent <span>=</span> parentInjector<span>;</span>\n\nparentInjector<span>.</span><span>defineKeyValue</span><span>(</span><span>\"tokenA\"</span><span>,</span> ClassA<span>)</span><span>;</span>\nchildInjector<span>.</span><span>defineKeyValue</span><span>(</span><span>\"tokenB\"</span><span>,</span> ClassB<span>)</span><span>;</span>\n\n<span>// 注意到childInjector中并没有定义tokenA，但是仍然可以获取到服务实例</span>\n<span>const</span> serviceA <span>=</span> childInjector<span>.</span><span>getValueByKey</span><span>(</span><span>\"tokenA\"</span><span>)</span><span>;</span>\n<span>const</span> serviceB <span>=</span> childInjector<span>.</span><span>getValueByKey</span><span>(</span><span>\"tokenB\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>从以上伪代码中可以看出，之所以引入 Injector 这个概念主要是为了避免只有全局一份配置信息。我们可以做到每次实例化一个 Injector 对象，这个 Injector 对象就具有依赖注入的能力；除此之外我们还可以给 Injector 对象增加一个 parent 属性，从而可以把 Injector 对象关联起来，如果当前 Injector 对象中找不到某个服务，就会从其 parent Injector 对象中寻找服务，直到根 Injector 为空。</p>\n<p>以上是从依赖注入框架的角度来思考的，和具体业务是无关的。考虑到在前端的场景下，应该怎样去结合呢？</p>\n<p>本库参考 angular 把 Injector 绑定在组件上，默认根 Injector 是绑定在根组件上，可以理解为公共的全局的命名空间。</p>\n<p>如果在业务上认为某个数据和某个组件是绑定的，就需要用到 <code>declareProviders([CountService])</code>。这行代码意味着当前组件会关联一个 Injector，并且配置了一个 CountService 服务。同时也意味着，在当前组件及其子孙组件中调用 useService 时，一定会从这个 Injector 中获取到 CountService 服务实例（前提是子孙组件不再定义同样的服务<code>declareProviders([CountService])</code>）。</p>\n<p>这种寻找机制和原型链寻找属性的机制非常相似，也就是底层的命名空间中的同名属性会覆盖上层命名空间的同名属性。</p>\n<h2 id=\"依赖注入-vs-import-export\"> 依赖注入 vs import/export</h2>\n<ol>\n<li>import/export 适合单例</li>\n<li>import/export 强制依赖某个实例/具体的数据，不存在干预服务创建过程的可能性。</li>\n<li>依赖注入解藕了依赖声明和依赖的实例化。比如声明依赖 LoggerService，但是可以通过配置修改为 OtherLoggerService 的实例</li>\n<li><a href=\"https://www.zhihu.com/question/391394082/answer/1188254737\" target=\"_blank\" rel=\"noopener noreferrer\">Vue3 跨组件共享数据，为何要用 provide/inject？直接 export/import 数据行吗？</a></li>\n<li><a href=\"https://www.zhihu.com/question/374161373/answer/1034772082\" target=\"_blank\" rel=\"noopener noreferrer\">前端什么时候用 import 什么时候用依赖注入?</a></li>\n</ol>\n<h2 id=\"图解\"> 图解</h2>\n<p>通过图片中不同的颜色可以区分出 declareProviders 划分出来不同的命名空间，这也是本库的 logo 的来源。</p>\n<p><img src=\"/assets/image/project/demo.png\" alt=\"hello logo\" /></p>\n<h2 id=\"什么是-provider\"> 什么是 provider</h2>\n<p>因为本库的依赖注入的思想是来自于 angular，所以大家可以直接查看<a href=\"https://angular.cn/guide/dependency-injection-providers#using-an-injectiontoken-object\" target=\"_blank\" rel=\"noopener noreferrer\">angular 的官方文档</a>。这里我再说说我的理解。</p>\n<p>provider 字面意思就是提供者，这里具体一点就是服务的提供者。提到服务，我们必须了解两个概念：服务名字和服务来源。最常见的 provider 如下：</p>\n<div><pre><code><span>{</span>\n  provide<span>:</span> AppleService<span>,</span> <span>// 这是服务名字</span>\n  useClass<span>:</span> AppleService<span>,</span> <span>// 这是服务来源</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>服务提供者是用来解决一个问题：服务是怎么来的？</p>\n<p>最简单的场景就是配置的是什么，就把这个当作服务。还可以实例化一个类来当作服务，还可以执行某个函数，把返回值当作服务。这些在上面已经介绍过了。</p>\n<p>总结起来就是 provider 是一种规范，从 provider 中我们可以获取服务标识符、服务创建机制、创建服务所需要的东西。</p>\n<p>服务标识符意味着当我们获取服务时需要提供的标识符。</p>\n<p>服务创建机制也是必须的，因为我们可能是没有办法只从服务标识符中推导出如何创建一个服务的，比如我们没有办法准确区分一个类和一个普通函数，也就没有办法知道怎么去创建这个服务，是应该 new 这个函数，还是直接调用这个函数。</p>\n<p>当我们指定<code>useClass</code>时，显然是想要通过类的实例化来创建一个服务，虽然我们可以直接把服务标识符来当作类来使用，但是我们仍然支持<code>useClass:AnotherService</code>，从而达到实际提供服务的类和服务标识符的类的解耦。</p>\n",
      "image": "https://www.kaokei.com/assets/image/project/demo.png",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "前端常见库的理解",
      "url": "https://www.kaokei.com/project/use-vue-service/articles/frame-analysis/",
      "id": "https://www.kaokei.com/project/use-vue-service/articles/frame-analysis/",
      "content_html": "<h2 id=\"常见库的理解\"> 常见库的理解</h2>\n<p>简单记录一下常见库的个人理解，把这些库放在一起对比后可以比较方便的知道各个库的不同，以及凸显 <code>@kaokei/use-vue-service</code> 的差异点和必要性。</p>\n<p>可以从这几个方面来分析库的不同点。</p>\n<ul>\n<li>如何定义服务</li>\n<li>如何组织/组合/管理/注册服务</li>\n<li>如何获取服务</li>\n<li>数据如何驱动模板</li>\n</ul>\n<p>这里的服务的定义是：<strong>特定领域相关数据和方法的集合</strong>。</p>\n<h2 id=\"定义服务的方式\"> 定义服务的方式</h2>\n<ol>\n<li>class</li>\n</ol>\n<div><pre><code>// 定义服务\nclass Counter {\n  count: 0;\n}\n\nconst counter1 = new Counter(); // 获取服务实例\nconst counter2 = new Counter(); // 获取服务实例\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ol start=\"2\">\n<li>function</li>\n</ol>\n<div><pre><code>// 定义服务\nfunction getCounter() {\n  return {\n    count: 0\n  }\n}\n\nconst counter1 = getCounter(); // 获取服务实例\nconst counter2 = getCounter(); // 获取服务实例\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ol start=\"3\">\n<li>对象字面量</li>\n</ol>\n<div><pre><code>const Counter = {\n  count: 0\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意这里第 3 种方式是单例模式，如果想要多个实例，只能使用 deepClone 来复制数据了。实际上没有哪个库是采用这种方式。</p>\n<p>这里只是想明确一下服务声明和服务本身是两个不同的概念。服务定义可以有多种不同的形式，但是服务本身就是一个普通 js 对象。</p>\n<h2 id=\"redux-以及-react-redux\"> redux 以及 react-redux</h2>\n<p><a href=\"https://github.com/reduxjs/redux\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=reduxjs&repo=redux\" alt=\"redux\" /></a>\n<a href=\"https://github.com/reduxjs/react-redux\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=reduxjs&repo=react-redux\" alt=\"react-redux\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/reduxjs/redux\" target=\"_blank\" rel=\"noopener noreferrer\">reduxjs/redux</a></li>\n<li><a href=\"https://github.com/reduxjs/react-redux\" target=\"_blank\" rel=\"noopener noreferrer\">reduxjs/react-redux</a></li>\n<li><a href=\"https://www.redux.org.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">redux 中文文档</a></li>\n<li><a href=\"https://github.com/reduxjs/redux#examples\" target=\"_blank\" rel=\"noopener noreferrer\">官网 github demo</a></li>\n<li><a href=\"https://redux.js.org/introduction/examples#todomvc\" target=\"_blank\" rel=\"noopener noreferrer\">官网文档 examples</a></li>\n<li><a href=\"https://redux.js.org/faq/actions#what-async-middleware-should-i-use-how-do-you-decide-between-thunks-sagas-observables-or-something-else\" target=\"_blank\" rel=\"noopener noreferrer\">官网文档 中间件选择</a></li>\n</ul>\n<p>redux 本身的概念比较简单，而且是和具体 UI 框架无关的。所以必须要配合 react-redux 一起使用才能更好的在 react 中使用。</p>\n<div><pre><code>// 观察redux的主要API调用\nconst rootReducer = combineReducers({subReducer1, subReducer2});\nconst store = createStore(rootReducer);\nstore.subscribe(() =&gt; console.log(store.getState()));\nstore.dispatch({type: &#39;someType&#39;});\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>第一点需要弄明白的就是 reducer 的定义。reducer 本身是一个纯函数，是和 redux 无关的。</p>\n<p>但是函数签名必须满足：<code>(previousState = initialState, action) =&gt; newState</code>，其实这也是和类所表达的服务是一个东西，是数据和方法的封装。</p>\n<p>其中 state 部分就是数据，但是要注意这里的 state 部分，虽然说 reducer 是一个纯函数，但其实并不够纯，因为 initalState 必然属于闭包中的一个变量值。</p>\n<p>而 action 部分就是方法。只不过这里的 action 部分使用的是 type 字段，类型是字符串而已。</p>\n<p>再看 combineReducers 只是组合服务的一种方式而已。</p>\n<p>然后再通过 createStore 创建一个全局 store，通过 store 来管理这些服务，最重要的一种管理方式就是只能通过 store.dispatch 来修改数据。</p>\n<p>又因为 store 是全局的，我们可以通过单例模式，import 到需要的模块中，就达到获取服务的目的了。</p>\n<p>而 store.subscribe 则是实现数据驱动模板更新的最底层的机制。</p>\n<p>如果不使用 react-redux，可以参考这个<a href=\"https://codesandbox.io/s/github/reduxjs/redux/tree/master/examples/counter\" target=\"_blank\" rel=\"noopener noreferrer\">简单的例子</a>。</p>\n<p>这个例子中可以明显看出来如何通过 store.subscribe 来实现数据变化进而驱动模板更新。但是这样操作的性能太低了。</p>\n<p>再来看看 react-redux，它是基于 redux 的连接 react 和 redux 的库，基本特性和 redux 一致，主要是解决了 store 中数据变化时，模版也会自动更新。</p>\n<p>主要 api 是 connect 和 Provider。</p>\n<p>Provider 通过 context 提供了全局的 store，是为了 conenct 服务的。在 connect 中可以随时通过 context 获取到 store。从而读取数据。</p>\n<p>connect 本身是是一个函数，该函数返回值是一个高阶组件。注意高阶组件是一个函数，而不是组件。这个高阶组件函数可以包裹我们自己的组件，返回一个新组件。</p>\n<p>该高阶组件可以通过闭包拿到 connect 提供的 mapStateToProps 和 mapDispatchToProps，通过这两个函数再加上 context 中的 store，就可以获取到相应数据和方法了。</p>\n<p>其中数据部分是：<code>store+mapStateToProps=&gt;newState</code>，其中方法部分是：<code>store.dispatch+mapDispatchToProps=&gt;newActions</code>。</p>\n<p>目前为止还只能解决组件第一次渲染的时候获取数据的问题，关键还是要解决数据变化的时候，组件如何响应更新。</p>\n<p>实际上还是需要依赖 store.subscribe 这个 api，会在组件 mounted 时注册一个监听器，卸载组件时取消监听器。</p>\n<p>该监听器每次会重新从 store 获取数据，并和缓存中的数据做对比，如果数据有变化，那么执行 setState 操作，从而更新组件。</p>\n<p>redux 的缺点是模版代码很多，而且在 reducer 中已经定义了数据和方法了，在 connect 中还是需要再次定义数据和方法。再加上 action、actionCreator 等等。</p>\n<blockquote>\n<p>使用 reduce 表达服务，使用闭包中的 initialState 作为服务的初始值\n使用 combineReducers 来组合服务\n使用 createStore 来管理服务\n使用 Provider 提供全局的 store，组件使用 connect 来订阅 store 中的数据和方法\n组件通过 store.dispatch 来修改数据，当 store 中数据变化时，因为 connect 订阅了 store，所以会接收到 store.subscribe 的通知，从而可以更新组件</p>\n</blockquote>\n<h2 id=\"对比-vuex-和-redux-的区别-todo\"> 对比 vuex 和 redux 的区别 todo</h2>\n<p>mutable 和 immutable\n自顶向下\n直接触达</p>\n<h2 id=\"mobx-和-mobx-react\"> mobx 和 mobx-react</h2>\n<p><a href=\"https://github.com/mobxjs/mobx\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=mobxjs&repo=mobx\" alt=\"mobx\" /></a>\n<a href=\"https://github.com/mobxjs/mobx-react\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=mobxjs&repo=mobx-react\" alt=\"mobx-react\" /></a>\n<a href=\"https://github.com/mobxjs/awesome-mobx#examples\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=mobxjs&repo=awesome-mobx\" alt=\"awesome-mobx\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/mobxjs/mobx\" target=\"_blank\" rel=\"noopener noreferrer\">mobxjs/mobx</a></li>\n<li><a href=\"https://github.com/mobxjs/mobx-react\" target=\"_blank\" rel=\"noopener noreferrer\">mobxjs/mobx-react</a></li>\n<li><a href=\"https://github.com/mobxjs/awesome-mobx#examples\" target=\"_blank\" rel=\"noopener noreferrer\">mobx 官方例子</a></li>\n<li><a href=\"https://cn.mobx.js.org/intro/overview.html\" target=\"_blank\" rel=\"noopener noreferrer\">参考官方文档</a></li>\n</ul>\n<p>mobx 和 vue 非常像，可以说大部分能力 vue 已经天生支持了，剩下的就是如何组织代码的区别而已。</p>\n<p><strong>mobx 使用步骤</strong></p>\n<ol>\n<li>定义可观察数据，可以是对象或者类。这里依赖 mobx 的 observable 这个 API。</li>\n<li>定义组件。这里依赖 mobx-react 的 observer 这个 API。</li>\n<li>通过依赖注入 store 到组件，依赖 mobx-react 的 Provider 和 inject 两个 API</li>\n<li>然后我们只要改变了数据，组件就会自动更新。</li>\n</ol>\n<p>再对比 vue3 中的实现，第 1 步其实就是 reactive 这个 api，第 2 步中 vue 组件默认就是会观察 reactive 数据的，所以也不需要 observer 这个 API。至于第 3 步确实还没有比较好的复用数据的方式。这也就是 <code>@kaokei/use-vue-service</code> 主要做的事情。</p>\n<p>参考这个<a href=\"https://github.com/gothinkster/react-mobx-realworld-example-app\" target=\"_blank\" rel=\"noopener noreferrer\">demo</a>，分析如下：</p>\n<ol>\n<li>采用类来定义服务，但是需要具体声明各个属性和方法的性质，比如@observable @computed @action</li>\n<li>然后导出一个类的实例，这里就能看出来至少在这个项目中服务都是单例的，如果需要多例，就需要自己手动 new 多个实例。</li>\n<li>然后在根组件使用 Provider，这个 Provider 比较特殊，可以注入任意个值。</li>\n<li>然后在组件中就可以@inject('articlesStore')类似这样注入服务，然后就可以通过 this.props 获取到特定 store 数据。</li>\n<li>因为定义组件时，会将组件当作参数传递给 observer 函数，所以当数据有变化时，observer 函数就会更新组件。</li>\n</ol>\n<p>再参考这个<a href=\"https://github.com/mobxjs/mobx-react-todomvc\" target=\"_blank\" rel=\"noopener noreferrer\">demo</a></p>\n<p>这里没有使用 Provider，而是通过 props 从根组件一层层传递服务，这也是一种方式，但是就略显麻烦，但是证明了只要能获取到 store，就可以使用该 store 的数据和方法。而且能看出来，相比于 redux 和 react-redux，mobx 和 mobx-react 结合的更加紧密，完全不能独立分开使用。</p>\n<h2 id=\"mobx-state-tree\"> mobx-state-tree</h2>\n<p><a href=\"https://github.com/mobxjs/mobx-state-tree\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=mobxjs&repo=mobx-state-tree\" alt=\"mobx-state-tree\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/mobxjs/mobx-state-tree\" target=\"_blank\" rel=\"noopener noreferrer\">mobxjs/mobx-state-tree</a></li>\n</ul>\n<p>mobx-state-tree 虽然是基于 mobx 的，但是定位应该是和 mobx 是一样的，只不过在于组织代码方面有所区别。</p>\n<p>参考<a href=\"https://github.com/mobxjs/mobx-state-tree/tree/master/packages/mst-example-redux-todomvc\" target=\"_blank\" rel=\"noopener noreferrer\">这个例子</a></p>\n<p>可以发现居然还可以和 redux 相结合，虽然我觉得有点脱裤子放屁了。这里面有很多的重复性工作。</p>\n<p>依赖 redux 的 Provider 来提供全局单一数据源，然后依赖 connect 订阅数据源。</p>\n<p>在定义 mobx-state-tree 的模型的 actions 时，需要 actions 常量作为方法名。</p>\n<p>在 mapDispatchToProps 时也需要 actions 常量生成方法名，关键是组件中的 props 还是需要定义一摸一样的方法名来接受 props。</p>\n<p>总之就是非常繁琐，而且耦合非常严重，但是确实可以工作，而且能非常明确的看出来 mobx-state-tree 具体做了什么工作，没有做什么工作。</p>\n<p>注意 mobx-state-tree 非常明显的语法特征：</p>\n<p><code>const SomeStore = types.model(&quot;modelName&quot;).props({someProps}).views({someViews}).actions({someActions})</code></p>\n<p>看起来狂拽酷炫吊炸天，实际上就是一个类的换一种写法，也就是 mobx-state-tree 中服务的定义形式。</p>\n<p>需要注意的是 mobx-state-tree 自带一套类型系统，尤其是其中的 Model 类型，是可以嵌套的。从而可以形成一个 state-tree。</p>\n<p>还有一点就是实际使用 mobx-state-tree 时，还是需要我们手动初始化 Model 的。</p>\n<p><code>const someStore = SomeStore.create(initialState)</code></p>\n<p>参考<a href=\"https://github.com/mobxjs/mobx-state-tree/tree/master/packages/mst-example-bookshop\" target=\"_blank\" rel=\"noopener noreferrer\">这个例子</a></p>\n<p>这个例子可以明显看出来 mobx-state-tree 是代替了 mobx，并且配合 mobx-react 来工作的。</p>\n<p>上面有分析过，主要就是 Provider 和 inject 注入 store，并且 mobx-state-tree 是依赖 mobx 的，所以数据本身也是响应式的。</p>\n<p>可以明显看出来，mobx-state-tree 和 mobx 的区别在于组织代码的区别。</p>\n<ul>\n<li>mobx 是采用类来组织数据和方法。</li>\n<li>mobx-state-tree 是基于自带的类型定义采用链式方法调用来定义数据和方法。并且 Model 本身就是类型，也就意味着 Model 是可以嵌套的，所以这也是 mobx-state-tree 名称的来源，因为 Model 就是 state，嵌套之后就会形成一颗树。但是 mobx 中的类则不能相互嵌套形成复杂的“类树”。</li>\n</ul>\n<p>可以看出来 mobx-state-tree 这个库相比于 mobx 更加的 opinionated，它有一套自己的代码组织方式。但是我现在觉得单一数据源就是有原罪的。</p>\n<h2 id=\"redux-thunk\"> redux-thunk</h2>\n<p><a href=\"https://github.com/reduxjs/redux-thunk\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=reduxjs&repo=redux-thunk\" alt=\"redux-thunk\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/reduxjs/redux-thunk\" target=\"_blank\" rel=\"noopener noreferrer\">reduxjs/redux-thunk</a></li>\n</ul>\n<p>这个是 redux 的中间件，而且是官方的中间件。用来解决 redux 本身不支持异步更新的缺点。如果看了源代码会惊讶的发现只有十几行代码。</p>\n<p>原来的 store.dispatch 只支持对象作为参数，经过 redux-thunk 中间件的加持就可以额外支持 dispatch 一个函数了，而且函数的第一个参数还是 dispatch，意味着我们可以在函数内部再次调用 dispatch。在函数内部我们可以写条件判断逻辑，可以异步执行 dispatch。</p>\n<p>再加上 async/await 的加持，基本可以解决所有异步问题。而且可以避免深度回调的噩梦。</p>\n<p>再来说说问题的本质。redux 本身只是提供了 store 来保存数据，通过 store.dispatch 来更新数据。它本身并不支持异步更新和条件更新。</p>\n<p>实际上这只是客观描述这个现状，这本身并不是一个问题。问题在于我们非要把这些条件逻辑和异步逻辑放到 redux 中来管理而已。</p>\n<p>通过 redux-thunk 的加持，我们可以这样写代码：</p>\n<div><pre><code>store.dispatch((dispatch) =&gt; {\n  setTimeout(function() {\n    dispatch({\n      type: &#39;add&#39;,\n      payload: 1\n    });\n  }, 5000);\n})\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>但是实际上没有 redux-thunk 中间件，我们可以这样写代码：</p>\n<div><pre><code>setTimeout(function() {\n  store.dispatch({\n    type: &#39;add&#39;,\n    payload: 1\n  })\n}, 5000)\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>只不过缺点是没有纳入 redux 中被管理起来，我们可能需要把这些逻辑抽取出来，放到一个公共的模块中。然后 import 到当前模块中使用。</p>\n<h2 id=\"redux-saga\"> redux-saga</h2>\n<p><a href=\"https://github.com/redux-saga/redux-saga\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=redux-saga&repo=redux-saga\" alt=\"redux-saga\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/redux-saga/redux-saga\" target=\"_blank\" rel=\"noopener noreferrer\">redux-saga/redux-saga</a></li>\n<li><a href=\"https://github.com/superRaytin/redux-saga-in-chinese\" target=\"_blank\" rel=\"noopener noreferrer\">redux-saga 中文文档</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/53599723\" target=\"_blank\" rel=\"noopener noreferrer\">Vuex、Flux、Redux、Redux-saga、Dva、MobX</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/35437092\" target=\"_blank\" rel=\"noopener noreferrer\">Redux-Saga 漫谈</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/39452751\" target=\"_blank\" rel=\"noopener noreferrer\">彻彻底底教会你使用 Redux-saga(包含样例代码)</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/98870028\" target=\"_blank\" rel=\"noopener noreferrer\">redux-saga 实现原理及 umi, dva 设计思想解析</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/23012870\" target=\"_blank\" rel=\"noopener noreferrer\">redux-saga 实践总结</a></li>\n</ul>\n<p>saga 是英语 传奇 的意思。它的思想是 拦截。</p>\n<p>同样是 redux 的中间件，和 redux-thunk 一样都是为了解决 redux 解决不了的副作用的问题。</p>\n<p>据说是用来解决复杂异步场景下的问题。</p>\n<p>我没有 redux-saga 的使用经验，之前尝试入门过好几次，每次都是放弃了，是真正的从入门到放弃。这次因为要写总结，还是硬着头皮看了一些文章，大概弄明白了 saga 的原理。</p>\n<p>像 redux-thunk、redux-promise 这些中间件都是特别简单的，源代码都没有几行。总体思路都是增强 store.dispatch 函数的能力。</p>\n<p>原始 store.dispatch 只支持 dispatch 普通对象，redux-thunk 中间件则可以支持 dispatch 函数，redux-promise 中间件则可以 dispatch promise。</p>\n<p>针对 redux-thunk 分析 store.dispatch(action)，如果 action 是函数，那么就执行这个函数，而且函数参数就是 dispatch，这样在 action 内部可以再次使用 dispatch 去真正的 dispatch 一个普通对象，达到修改 store 中数据的效果。</p>\n<p>对比分析一下 redux-saga，它也是增强了 store.dispatch 能力，但是不像 redux-thunk 是判断 action 本身是不是函数来执行不同的策略。redux-saga 虽然增强了 store.dispatch 的能力，但是它还是只能 dispatch 普通对象，这就意味着我们很难从 store.dispatch 区分我们到底是 dispatch 一个普通 action，还是一个 saga action。因为它们的格式都是:</p>\n<div><pre><code>{\n  type: &#39;ACTION_NAME&#39;,\n  payload: some_data\n}\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>那么 redux-saga 是如何增强 store.dispatch 的呢？我的理解是基于字符串匹配的。因为在使用 redux-saga 时，第一步是定义 saga，然后是需要注册 saga，注册的时候，其实就是配置 ACTION_NAME 和 saga 的映射。</p>\n<p>那么当用户手动 store.dispatch 一个普通对象时，redux-saga 这个中间件会去自己注册的 saga 列表中去找有没有对应的 ACTION_NAME，如果找到了该 ACTION_NAME，那么就执行该 ACTION_NAME 对应的 saga 函数。剩下的逻辑和 redux-thunk 是一样的，thunk 本身就是一个普通函数，只是具有访问 dispatch 的能力，这样我们就可以随意在 thunk 函数中调用 dispatch 函数来更新 store 中的数据。saga 也是一个函数，它倒是不能直接访问 dispatch 函数，但是提供了更多更复杂的函数来帮助我们处理副作用、异步逻辑。其中的 put 函数就是类似 dispatch 的能力。还有一点需要注意，类似 put 这类的 effect function 是从从全局包导入的。<code>import { call, put, takeEvery, takeLatest } from 'redux-saga/effects'</code>，这意味着他们是全局唯一的，也意味着他们是单例的，也意味着全局 store 也是单例的，但是在 redux-thunk 是可以实现多例的。</p>\n<p>如果要是找不到对应的 ACTION_NAME，那么就走正常的 redux 原始的 store.dispatch 逻辑，也就是直接通过 reducer 来消费该 action，最终修改了 store 中的数据。这里还可以再强调一点，正常 redux 的逻辑是由多个 reducer 组合而成的，这些 reducer 内部会消费 action，隐含逻辑是所有 reducer 中的 ACTION_NAME 都是全局的，是不能同名的，否则可能会引起逻辑错误。</p>\n<p>总结就是 redux-thunk 是通过类型来判断当前 action 到底是函数，还是普通对象。redux-saga 则是通过字符串匹配来检查到底是 saga action，还是原来的普通的 action。</p>\n<p>还有一点区别是 redux-saga 是需要常驻内存的监听器的，redux-thunk 则不需要。</p>\n<p>有人说 redux-saga 是通过事件监听机制来实现的，或者说观察者订阅者模式实现的，但是底层还是依赖字符串匹配。</p>\n<h2 id=\"redux-observable\"> redux-observable</h2>\n<p><a href=\"https://github.com/redux-observable/redux-observable\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=redux-observable&repo=redux-observable\" alt=\"redux-observable\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/redux-observable/redux-observable\" target=\"_blank\" rel=\"noopener noreferrer\">redux-observable/redux-observable</a></li>\n</ul>\n<p>看名字就知道是基于 rxjs 的 redux 的中间件。我没有使用过该库，只是看了看文档。</p>\n<p>因为我有过 angular 的开发经验，所以对 rxjs 还算比较熟悉。当我在熟悉 redux-saga 的过程中，我就发现其 api 的设计和 rxjs 非常相似。这里的相似是指操作符部分。</p>\n<p>rxjs 中提供了很多的操作符函数来帮助我们操作流，redux-saga 中提供了很多 effect function 来帮助我们操作副作用。</p>\n<p>再来看 redux-observable 的 api，我发现 redux-saga 和 redux-observable 非常相似。这里的相似是指架构设计部分。</p>\n<p>redux-saga 中主要概念是 saga，对应 redux-observable 中主要概念是 epic。通过声明式的语句定义好这些 saga 或者 epic，然后在通过 combine 函数组合成 rootSaga 或者 rootEpic。</p>\n<p>在注册完 redux 中间件后，即 applyMiddle 后，还需要 run(rootSaga)或者 run(rootEpic)。</p>\n<p>不管是 saga 还是 epic，他们的思想都是通过 store.dispatch(plain action)来触发异步调用，并调用另一些 store.dispatch(plain action)。</p>\n<p>本质都是要根据字符串匹配找到对应的 saga 或者 epic，然后执行相应的异步逻辑。该异步逻辑又会通过 dispatch(plain action)来修改 store 中的数据。</p>\n<h2 id=\"dva\"> dva</h2>\n<p><a href=\"https://github.com/dvajs/dva\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=dvajs&repo=dva\" alt=\"dva\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/dvajs/dva\" target=\"_blank\" rel=\"noopener noreferrer\">dvajs/dva</a></li>\n<li><a href=\"https://www.yuque.com/flying.ni/the-tower/tvzasn\" target=\"_blank\" rel=\"noopener noreferrer\">一图胜千言, 何况是四图? 图解 DVA</a></li>\n<li><a href=\"https://dvajs.com/guide/source-code-explore.html#%E9%9A%90%E8%97%8F%E5%9C%A8-package-json-%E9%87%8C%E7%9A%84%E7%A7%98%E5%AF%86\" target=\"_blank\" rel=\"noopener noreferrer\">Dva 源码解析</a></li>\n</ul>\n<p>dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。</p>\n<p>通过官方介绍，可以知道 dva 是通过组合 redux、redux-saga、react-router、fetch、antd 这些项目必须的常用库，以及采用约定大于配置的思想定义了自己的开发规范。并且提供了 dva-cli 脚手架快速初始化项目目录。</p>\n<div><pre><code>app.model({\n  namespace: &#39;count&#39;, // 全局store的一级属性\n  state: { // store.count的子属性\n    record: 0,\n    current: 0,\n  },\n  reducers: { // redux概念中的reducers\n    add(state) {},\n    minus(state) {},\n  },\n  effects: { // redux-saga概念中的saga\n    *add(action, { call, put }) {\n      yield call(delay, 1000);\n      yield put({ type: &#39;minus&#39; });\n    },\n  },\n  subscriptions: { // 新增加的概念，主要是帮助我们订阅其他事件\n    keyboardWatcher({ dispatch }) {\n      key(&#39;⌘+up, ctrl+up&#39;, () =&gt; { dispatch({type:&#39;add&#39;}) });\n    },\n  },\n});\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>可以看出主要特点是把 store 及 saga 统一为一个 model 的概念, 写在一个 js 文件里面，增加了一个 Subscriptions, 用于收集其他来源的 action, eg: 键盘操作</p>\n<p>可以把 dva 理解为换一种方式组织 react、redux、saga 代码。虽然看起来没有新东西，但是确实有助于管理代码，提升开发效率，所以又有人说 dva 只是 react 开发的一种最佳实践。</p>\n<p>再回过头看看上面的示例代码，其他属性都不用太关心，唯有 namespace 是必须要要关心的，目前我知道有两个作用：</p>\n<p>第一：自动作为全局 store 的一级属性，意味着在 connect 时，必须以 namespace 作为参数解构。\n第二：prefixNamespace 函数使用 reduce 对每一个 model 做处理，为 model 的 reducers 和 effects 中的方法添加了 namespace 的前缀。解决了 redux 中 action 重名的问题，以及 saga 中 action 重名的问题。</p>\n<div><pre><code>可以直接指定namespace来跨model通信\nyield call({ type: &#39;namespace/foo&#39; });\nyield take({ type: &#39;namespace/bar&#39; });\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"rematch\"> rematch</h2>\n<p><a href=\"https://github.com/rematch/rematch\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=rematch&repo=rematch\" alt=\"rematch\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/rematch/rematch\" target=\"_blank\" rel=\"noopener noreferrer\">rematch/rematch</a></li>\n<li><a href=\"https://rematch.netlify.app/#/\" target=\"_blank\" rel=\"noopener noreferrer\">rematch 官方文档</a></li>\n</ul>\n<h2 id=\"composition-api\"> composition-api</h2>\n<p><a href=\"https://github.com/vuejs/composition-api\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=vuejs&repo=composition-api\" alt=\"composition-api\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/vuejs/composition-api\" target=\"_blank\" rel=\"noopener noreferrer\">vuejs/composition-api</a></li>\n</ul>\n<h2 id=\"rxjs\"> rxjs</h2>\n<p><a href=\"https://github.com/ReactiveX/rxjs\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=ReactiveX&repo=rxjs\" alt=\"rxjs\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/ReactiveX/rxjs\" target=\"_blank\" rel=\"noopener noreferrer\">ReactiveX/rxjs</a></li>\n</ul>\n<p>有人说 rxjs 和 promise 非常像，确实如此。但是随着学习的深入，就会发现差别越来越大。</p>\n<ul>\n<li>promise 只有单个值，observable 则可以有多个值。</li>\n<li>promise 函数是立即执行的，observable 则是订阅后才执行的。</li>\n<li>promise 不能被取消，observable 则可以取消订阅。</li>\n<li>promise 没有提供便利的操作符函数，observable 则提供了一系列强大的操作符函数。</li>\n<li>以上这些差异最终导致 promise 是需要使用的时候才去使用的，是命令式的；observable 则容易上瘾，我自己容易把所有的业务逻辑变成 observable 的衍变逻辑，是声明式的。</li>\n</ul>\n<h2 id=\"vue-rx\"> vue-rx</h2>\n<p><a href=\"https://github.com/vuejs/vue-rx\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=vuejs&repo=vue-rx\" alt=\"vue-rx\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/vuejs/vue-rx\" target=\"_blank\" rel=\"noopener noreferrer\">vuejs/vue-rx</a></li>\n</ul>\n<div><pre><code>new Vue({\n  // requires `Rx` passed to Vue.use() to expose `Subject`\n  domStreams: [&#39;plus$&#39;],\n  subscriptions () {\n    // use this.plus$\n  }\n})\n\n&lt;button v-stream:click=&quot;{ subject: plus$, data: someData }&quot;&gt;+&lt;/button&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>作为 Vue 的插件，我们可以通过 subscriptions 属性声明 observable 属性，可以通过 domStreams 属性声明流式事件。</p>\n<p>唯一不习惯的是 subscriptions 声明的属性一般没有$后缀，因为在模版中使用的时候确实不是 observable 对象，但是有时候我们确实又想知道这个变量到底是不是流。</p>\n<p>总之没有在 angular 使用的这么舒服，并且和 vue 本身的配合还是有一些不和谐的地方。subscriptions 对象本身每个属性都是流，但是我们实际使用的时候，已经变成普通数据了，就像 data 属性声明的那些属性一样。这就导致一些问题。</p>\n<p>第一、认知方面的转变，我们定义的是流，使用的时候却是数据，只不过该数据会被流驱动修改。</p>\n<p>第二、所有流式 api 都只能在 subscriptions 内部使用，其他地方都不能（不建议）使用流相关的 api。</p>\n<p>第三、官网中有说到，因为初始化顺序问题，导致不能直接在 watch 中观察 subscriptions。这也是 subscriptions 和 data 的区别。</p>\n<p>第四、新增加了很多概念以及 api，有上手成本。</p>\n<h2 id=\"recoil-todo\"> Recoil todo</h2>\n<p><a href=\"https://github.com/facebookexperimental/Recoil\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=facebookexperimental&repo=Recoil\" alt=\"Recoil\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/facebookexperimental/Recoil\" target=\"_blank\" rel=\"noopener noreferrer\">Recoil 仓库</a></li>\n<li><a href=\"https://www.recoiljs.cn/docs/introduction/getting-started\" target=\"_blank\" rel=\"noopener noreferrer\">Recoil 官方文档</a></li>\n<li><a href=\"https://www.zhihu.com/question/394899726/answer/1264322654\" target=\"_blank\" rel=\"noopener noreferrer\">如何评价 Facebook 的 React 状态管理库 Recoil？</a></li>\n</ul>\n<h2 id=\"immer\"> immer</h2>\n<p><a href=\"https://github.com/immerjs/immer\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=immerjs&repo=immer\" alt=\"immer\" /></a>\n<a href=\"https://github.com/immutable-js/immutable-js\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=immutable-js&repo=immutable-js\" alt=\"immutable-js\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/immerjs/immer\" target=\"_blank\" rel=\"noopener noreferrer\">immerjs/immer</a></li>\n<li><a href=\"https://github.com/immutable-js/immutable-js\" target=\"_blank\" rel=\"noopener noreferrer\">immutable-js/immutable-js</a></li>\n<li><a href=\"https://immerjs.github.io/immer/docs/introduction\" target=\"_blank\" rel=\"noopener noreferrer\">官方文档</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/122187278\" target=\"_blank\" rel=\"noopener noreferrer\">immer.js:也许更适合你的 immutable js 库</a></li>\n</ul>\n<p>immerjs 和 immutable-js 都是用来实现 immutable 效果的库。我自己之前一直没有意识到我在写代码的时候，也会不自觉的使用了 immutable 特性。比如：</p>\n<div><pre><code>const baseArray = [1, 2, 3];\nconst baseObj = { name: &#39;zhangsan&#39;, age: 12 };\n\nconst newArray = baseArray.map(val =&gt; val + 1);\nconst newArray = [...baseArray];\nconst newObj = {...baseObj, age: 13};\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>但是这些方式都属于浅拷贝，有时候我们需要处理复杂的 json 数据，就需要用到深拷贝，比如<code>lodash.deepClone</code>。</p>\n<p>但是每次修改都需要深拷贝的话，性能方面比较差，所以就有了 immerjs 和 immutable-js，他们的实现原理都是只会拷贝修改部分的数据，没有修改过的数据则不会拷贝。</p>\n<p>immutable-js 的特点是采用 fromJS 和 toJS，可以将普通 js 类型和 immutable-js 自带的类型之间转化，所有的修改都需要嗲用 immutable-js 自带的类型的特定方法去修改数据，但是最终消费数据的时候，还是需要采用 toJS 转化为普通对象。</p>\n<p>这种转换来转换去的操作，我不是很喜欢，而且 api 众多，上手成本过高。但是优点是兼容性比较好。</p>\n<p>反果类 immerjs 这个库只是提供了 produce 这个函数来实现 immutable 特性。参考如下代码：</p>\n<div><pre><code>import produce from &quot;immer&quot;\n\nconst baseState = [\n    {\n        todo: &quot;Learn typescript&quot;,\n        done: true\n    },\n    {\n        todo: &quot;Try immer&quot;,\n        done: false\n    }\n]\n\nconst nextState = produce(baseState, draftState =&gt; {\n    draftState.push({todo: &quot;Tweet about it&quot;})\n    draftState[1].done = true\n})\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>观察示例代码，使用 produce 函数，可以通过 reducer 的处理 baseState，得到一个新的对象 nextState。说实话，我光看这个示例代码没有办法想出来它底层原理是如何实现的。当然最简单的实现肯定是先把 baseState 深拷贝一份，然后当作参数传递给 draftState，然后返回值就是 nextState 了。但是显然这么做完全不需要 immerjs 了，用户只需要一个深拷贝函数就行了。因为这并没有实现只拷贝修改的部分。上面参考文章中有提到它内部其实是用到了 Proxy 来实现的，具体可以看那篇文章。</p>\n<h2 id=\"concent\"> concent</h2>\n<p><a href=\"https://github.com/concentjs/concent\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=concentjs&repo=concent\" alt=\"concent\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/concentjs/concent\" target=\"_blank\" rel=\"noopener noreferrer\">concentjs/concent</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/114655336\" target=\"_blank\" rel=\"noopener noreferrer\">concent 知乎专栏</a></li>\n<li><a href=\"https://github.com/concentjs/concent#minimal-example\" target=\"_blank\" rel=\"noopener noreferrer\">concent minimal-example</a></li>\n<li><a href=\"https://github.com/concentjs/concent#complete-example\" target=\"_blank\" rel=\"noopener noreferrer\">concent complete-example</a></li>\n</ul>\n<p>从服务的角度来理解就非常容易理解 concent 的思路，当然有些细节不看源码还是不太了解。</p>\n<p>观察官网的示例代码，通过对象的形式定义服务，并且通过 run 函数注册服务。需要注意这里的服务可以包含数据 state，computed，也有方法 reducer，甚至还有 watch 和 lifecycle。</p>\n<p>注意官网一直说的是 module，我这里说的是服务，虽然名词不一样，但是指的是一个东西。需要注意这里的服务的标识符号是字符串。那么在使用服务的时候。\n在类组件上使用<code>@register(&quot;counter&quot;)</code>，在函数组件上使用<code>useConcent(&quot;counter&quot;);</code>。可以明显看出来服务的标识符就是字符串。</p>\n<p>另外@register 和 useConcent 这两个 api 不仅仅是只能接受一个字符串来代表一个服务，或者说 module。</p>\n<p>在知乎专栏这篇文章中有展示其他使用方式，比如：</p>\n<div><pre><code>useConcent(&#39;login&#39;);\nuseConcent({connect: [&#39;login&#39;]});\nuseConcent({module: &quot;login&quot;, state: spState});\nuseConcent({module: &quot;login&quot;, state: spState, setup});\nuseConcent({setup, state: iState, props});\nuseConcent({state: iState});\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>可以看出来目前就有 connect，module，state，setup，props 这些属性，注意到 module 本身也是有 state 的，组件本身也是有 state 的；connect 和 module 的区别是什么？setup 又是做什么的？ 总体来说还是太复杂了。</p>\n<p>不清楚服务，或者说 module 是否支持多例，主要是看到示例代码中有关生命周期部分的注释有提到多例，但是不清楚如何实现的。</p>\n<h2 id=\"dob\"> dob</h2>\n<p><a href=\"https://github.com/dobjs/dob\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=dobjs&repo=dob\" alt=\"dob\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/dobjs/dob\" target=\"_blank\" rel=\"noopener noreferrer\">dobjs/dob</a></li>\n<li><a href=\"https://www.zhihu.com/question/63726609/answer/212605476\" target=\"_blank\" rel=\"noopener noreferrer\">要不要支持一下国产的 dob?</a></li>\n</ul>\n<p>理念与 mobx 相同，使用 proxy 让使用过程更流畅，数组不会搞成纯对象，有依赖注入最佳实践，还能配合 redux。</p>\n<p>只是看了看官网的示例代码，感觉和 mobx 非常像，api 一样，代码组织方式都基本是一样的。</p>\n<h2 id=\"xreact\"> xreact</h2>\n<p><a href=\"https://github.com/reactive-react/xreact\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=reactive-react&repo=xreact\" alt=\"xreact\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/reactive-react/xreact\" target=\"_blank\" rel=\"noopener noreferrer\">reactive-react/xreact</a></li>\n<li><a href=\"https://www.zhihu.com/question/63726609/answer/212818893\" target=\"_blank\" rel=\"noopener noreferrer\">FP, FRP, observable, declarative, monadic, composable, reactivex, fantasyland</a></li>\n</ul>\n<p>这个项目应该类似 vue-rx，但是对于这种项目我个人理解价值不大。我的理解是像 rxjs 这种库，就像 jquery、lodash 一样，就是一种工具库。我们使用这些工具库也不需要专门的 react-jquery，react-lodash。\n像 xreact，vue-rx 这种库，一般都是 opinionated library，提供自己的开发规范。当然如果认可这种开发规范，对开发效率应该是有提升的。但是我还是更愿意自己手写 rxjs 代码，就像在 angular 中一样。</p>\n<p>我硬着头皮看了看官方文档，比我想的要复杂得多，并没有像 vue-rx 那样是在 vue 基础上增加了很少的概念，xreact 增加的概念就比较多了。官方文档介绍了如何使用 xreact，一共分成 3 步：</p>\n<p>第一步：定义视图组件，也叫受控组件、展示组件、无状态组件</p>\n<p>这里还是 react 的概念，只不过对 props 有固定的要求，即必须含有 props.actions 属性，该属性包含了改变数据的所有方法。</p>\n<p>第二步：定义 Plan</p>\n<p>这里开始出现 xreact 特有的概念了，plan 本身就是一个函数，只不过对入参和出参有固定的要求。</p>\n<p>入参是 <code>intent$</code>, 本身是一个流，其中的值就是 action。</p>\n<p>出参是一个对象，包含 <code>update$</code> 和 <code>actions</code> 两个属性。<code>update$</code> 类似于 redux 中的 <code>reducer</code>，<code>actions</code> 属性则是类似于 redux 中的 <code>action creator</code></p>\n<p>这里需要注意第一步中定义组件时也有一个 actions，我的理解是这两个 actions 虽然有关联，但是不完全一致，其中 props.actions 更加像 redux 中的 <code>store.dispatch(action)</code></p>\n<p>我看了一下项目的 package.json，本身是不依赖 redux 的，所以应该是自己实现了类似的 api，但是似乎没有发现类似 combineReducers 的函数。</p>\n<p>目前我看到的示例代码都是一个 plan 对应一个组件，似乎没有类似 combinePlan 这样的函数来组合 plan。</p>\n<p>第三步：我认为就是链接 plan 和组件</p>\n<p>但是命名有点过于简约了。比如 X、 x。</p>\n<div><pre><code>&lt;X x={rx}&gt;\n  &lt;Counter /&gt;\n&lt;/X&gt;,\n\n猜测功能应该类似于\n\n&lt;Provider store={store}&gt;\n  &lt;Counter /&gt;\n&lt;/Provider&gt;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>还有一点也需要注意：</p>\n<div><pre><code>import {x, X} from &#39;xreact/lib/x&#39;\nconst Counter = x(plan)(CounterView)\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>这里的 x 是一个函数，但是<code>&lt;X x={rx}&gt;</code>中的 x 只是一个 props 属性</p>\n<h2 id=\"stamen\"> stamen</h2>\n<p><a href=\"https://github.com/forsigner/stamen\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=forsigner&repo=stamen\" alt=\"stamen\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/forsigner/stamen\" target=\"_blank\" rel=\"noopener noreferrer\">forsigner/stamen</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/45789975\" target=\"_blank\" rel=\"noopener noreferrer\">简洁的 React 状态管理库 - Stamen - 该文档太旧了，和最新版本的 api 不太一致</a></li>\n<li><a href=\"http://forsigner.com/stamen-zh-cn/\" target=\"_blank\" rel=\"noopener noreferrer\">Stamen 文档</a></li>\n</ul>\n<p>Stamen 是一个 immutable React 状态管理库。api 非常简洁，内部采用 immer 实现 immutable 特性。</p>\n<p>我刚开始看的是知乎的文章，后来才看的是 github 主页，发现知乎的文章是 2018 年的，最新版本已经有很大变化了。</p>\n<p>只看最新版本的话，api 变得特别像 redux 和 dva 了。</p>\n<p>通过 createStore 返回 useStore 和 dispatch，其中 useStore 可以获取数据，dispatch 可以修改数据。</p>\n<p>多 store 的实现，依赖 import/export 来手动导入导出。</p>\n<p>组件依赖多个 store 的场景，需要重命名 useStore 和 dispatch。</p>\n<h2 id=\"redux-arena\"> redux-arena</h2>\n<p><a href=\"https://github.com/hapood/redux-arena\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"https://github-readme-stats.vercel.app/api/pin?username=hapood&repo=redux-arena\" alt=\"redux-arena\" /></a></p>\n<ul>\n<li><a href=\"https://github.com/hapood/redux-arena/blob/master/README.zh-CN.MD\" target=\"_blank\" rel=\"noopener noreferrer\">hapood/redux-arena</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28690716\" target=\"_blank\" rel=\"noopener noreferrer\">全新的 redux 模块化框架，redux-arena</a></li>\n</ul>\n<p>我的理解 redux-arena 的特点是依赖 react、redux、redux-saga、immutable 实现 state、saga、action、Component 在组件级别可复用。</p>\n<p>如果把 state、saga、action 理解为服务的一种形式，这句话可以解释为实现服务在组件层面可复用。是不是有 angular 的味道了。</p>\n<h2 id=\"各个库的特性总结\"> 各个库的特性总结</h2>\n<ul>\n<li>如何定义服务\n<ul>\n<li>类</li>\n<li>工厂函数</li>\n<li>函数链式调用</li>\n<li>reducer</li>\n</ul>\n</li>\n<li>如何组织/组合服务\n<ul>\n<li>依赖注入</li>\n<li>combineReducers</li>\n<li>单例还是多例</li>\n</ul>\n</li>\n<li>如何获取服务\n<ul>\n<li>自动初始化还是手动初始化</li>\n<li>全局 Provider+connect 还是手动 import 还是依赖注入</li>\n</ul>\n</li>\n<li>数据如何驱动模板</li>\n</ul>\n<h2 id=\"vue-和-react-的数据驱动的区别\"> vue 和 react 的数据驱动的区别</h2>\n<p>immutable 和 mutable\nreact 是修改完数据后再次执行函数组件或者 render 函数来更新视图\nvue 是视图订阅数据，数据变更后通知视图更新。\nxxx 场景下，理论上 vue 的效率要比 react 高。</p>\n<h2 id=\"其他参考文章\"> 其他参考文章</h2>\n<ul>\n<li><a href=\"https://www.cnblogs.com/vvjiang/p/9505646.html\" target=\"_blank\" rel=\"noopener noreferrer\">Redux 与它的中间件：redux-thunk，redux-actions，redux-promise，redux-saga</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_50076551/article/details/108751709\" target=\"_blank\" rel=\"noopener noreferrer\">redux 异步处理之 redux-thunk 和 redux-saga—阿楠</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/126481634\" target=\"_blank\" rel=\"noopener noreferrer\">redux-thunk 和 redux-saga 的区别？</a></li>\n<li><a href=\"https://blog.csdn.net/liwusen/article/details/79677827\" target=\"_blank\" rel=\"noopener noreferrer\">异步方案选型 redux-saga 和 redux-thunk（async/await）</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/321362823\" target=\"_blank\" rel=\"noopener noreferrer\">Redux 源码解析</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/35894511\" target=\"_blank\" rel=\"noopener noreferrer\">Rectx - 通过引入基类提供默认的 setState 方式管理数据</a></li>\n<li><a href=\"https://www.zhihu.com/question/63726609/answer/212562463\" target=\"_blank\" rel=\"noopener noreferrer\">除 Redux 外，目前还有哪些状态管理解决方案？1</a></li>\n<li><a href=\"https://www.zhihu.com/question/63726609/answer/212270561\" target=\"_blank\" rel=\"noopener noreferrer\">除 Redux 外，目前还有哪些状态管理解决方案？2</a></li>\n<li><a href=\"https://www.zhihu.com/question/63726609/answer/1284469580\" target=\"_blank\" rel=\"noopener noreferrer\">除 Redux 外，目前还有哪些状态管理解决方案？3</a></li>\n<li><a href=\"https://www.zhihu.com/question/63726609/answer/212357616\" target=\"_blank\" rel=\"noopener noreferrer\">除 Redux 外，目前还有哪些状态管理解决方案？4</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/271170805\" target=\"_blank\" rel=\"noopener noreferrer\">两种状态管理模型</a></li>\n<li><a href=\"https://www.zhihu.com/question/277623017/answer/396056598\" target=\"_blank\" rel=\"noopener noreferrer\">Redux 数据流管理架构有什么致命缺陷,未来会如何改进？1</a></li>\n<li><a href=\"https://www.zhihu.com/question/277623017/answer/395056100\" target=\"_blank\" rel=\"noopener noreferrer\">Redux 数据流管理架构有什么致命缺陷,未来会如何改进？2</a></li>\n<li><a href=\"https://www.zhihu.com/question/277623017/answer/1517983092\" target=\"_blank\" rel=\"noopener noreferrer\">Redux 数据流管理架构有什么致命缺陷,未来会如何改进？3</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/227953759\" target=\"_blank\" rel=\"noopener noreferrer\">鬼才！我居然把 Vue3 的原理用到了 React 上？</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/94964868\" target=\"_blank\" rel=\"noopener noreferrer\">Vue 3 核心原理 -- reactivity 自己实现</a></li>\n<li><a href=\"https://www.zhihu.com/question/378861485/answer/1127598769\" target=\"_blank\" rel=\"noopener noreferrer\">React Hooks 是否可以改为用类似 Vue 3 Composition API 的方式实现？1</a></li>\n<li><a href=\"https://www.zhihu.com/question/378861485/answer/1080453929\" target=\"_blank\" rel=\"noopener noreferrer\">React Hooks 是否可以改为用类似 Vue 3 Composition API 的方式实现？2</a></li>\n<li><a href=\"https://www.zhihu.com/question/378861485/answer/1153717028\" target=\"_blank\" rel=\"noopener noreferrer\">React Hooks 是否可以改为用类似 Vue 3 Composition API 的方式实现？3</a></li>\n</ul>\n",
      "image": "https://github-readme-stats.vercel.app/api/pin?username=reduxjs&repo=redux",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "前端框架浅显对比",
      "url": "https://www.kaokei.com/project/use-vue-service/articles/framework-comparison/",
      "id": "https://www.kaokei.com/project/use-vue-service/articles/framework-comparison/",
      "content_html": "<h2 id=\"vue、react-以及-angular-对比\"> vue、react 以及 Angular 对比</h2>\n<p>我第一个接触的框架是 vue，在 vue 之前我用的是 jquery。</p>\n<p>这里可以先对比一下 jquery 是如何写代码的。其实关键还是数据和视图的同步工作。</p>\n<p>比如某个变量的值改变了（先暂时不管是怎么改变的），现在要把这个数据反应到视图上，就必须首先使用 jquery 获取到相应的 dom，然后修改 dom 的属性。如果是大范围的视图变化，可能还需要相应的前端模版技术配合，比如 underscore 或者 handlebars。</p>\n<p>如果用户点击了某个按钮，我们需要响应用户的点击事件。\n前提是我们先要使用 jquery 注册 click 事件。\n然后在事件内部，我们先获取 input 的数据，然后按照业务逻辑更新内存中的变量。\n更新完变量同时后可能还需要更新其他依赖这个变量的 dom。</p>\n<p>综上，可以看出来前端的主要工作一直都是保持数据和视图的一致性。</p>\n<p>后来我开始使用 vue 来开发页面。整个过程完全不一样了。\n我们定义初始数据，然后开发模版，并把数据和模版绑定。\n同时在模版上监听事件。在事件处理器内部我们还是只需要更新数据即可。\n整个过程完全不需要操作 dom。只要我们更新了数据，视图会自动更新。</p>\n<p>人们常说 vue 是数据驱动的。这里非常明显的能感觉到和 jquery 不一样的地方，并且大大提升了开发效率。可以非常明显的感受到数据驱动的优势。</p>\n<p>后来我又接触了 react，刚开始接触 react，最难的莫过于 jsx，搞不懂 jsx 和 js 之间的关系。后来理解之后就逐渐喜欢上 react 了。</p>\n<p>可以这样理解 jsx <code>React.createElement(type, props, children);</code>\n这是一个函数调用，返回一个对象，就是一个普通的 js 对象，了解到这些就够了。\n之后我就发现 jsx 代码就自动变成 js 代码了。该怎么写代码，就怎么写代码。\nReact 中没有新的概念，没有新的语法，完全就是在写 js 代码。</p>\n<p>在使用 vue 和 react 的过程中，不可避免的要使用到 vuex 和 redux。这种全局单一数据源的想法根深蒂固。\n直到我接触到 angular。一开始我就在寻找 angular 中类似的单一数据源。但是我在项目中居然没有找到，接着我又去网上找到了 ngrx。\n当然我还没有开始用上它，就发现了单一数据源完全不是必须的，我只需要定义好相应的 service，然后把该 service 注册到相应的组件上即可。\n因为服务中是带有数据的。在组件中是可以直接获取到服务中的数据的。\n所以如果我想要在全局所有组件中都使用该服务，那么就把该 service 注册到根组件；\n如果是某个页面需要该 service，那么就注册到该路由组件即可；\n如果只是某个表格组件需要该 service，那么就注册到该表格组件即可；\n总之服务本身的定义是服务自己的事；至于服务具体的访问范围则完全取决于注册服务的位置。\n而且服务也不一定就是单例的，在不同的地方多次注册，就意味着可以有多个实例。\n更方便的是服务和服务之间也是可以互相注入的。</p>\n<p>再然后就是我想着能不能在 vue 和 react 中也实现一下依赖注入的能力，于是就有了 <code>@kaokei/use-vue-service</code>。至于 use-react-service 则还在开发中。</p>\n<p>类和函数</p>\n<p>我之前是非常喜欢函数，而不喜欢类的。有很多原因，比如函数在 js 中是第一位的。\n没有什么是函数解决不了的，比如模块化 amd 和 commonjs 都依赖函数的闭包。\n再一个就是函数可以很纯粹，没有副作用。\n类的底层实现也不过是函数的语法糖。</p>\n<p>后来我发现某些场景还是类比较适合。甚至是唯一的选择。\n比如我想要封装一些数据和方法。当然我可以采用工厂函数来生产新对象，该对象包含所有的数据和方法。\n但是缺点是这些方法没有必要重复生产。\n当然我们可以把这些方法提出来作为新生产的对象的原型，这样就可以复用这些方法了。\n但是我们想要依赖装饰器的能力时，则只能使用类了。</p>\n<p>SOA</p>\n<p>先来看看什么是 soa，翻译过来就是面向服务的体系架构。关键的一个名词是服务。服务又是什么呢？</p>\n<p>服务是数据和方法的集合，并且数据和方法都是可选的。意味着可以是类，函数，字符串，数字，布尔值等等。</p>\n<p>但是在当前 ts 环境下，数据和方法的封装最好的方式还是类，再加上装饰器只支持类。所以在 ts 中类是服务最好的表现形式。\n当然如果你只需要数据或者只需要方法，是不一定非得需要类。\n关于<a href=\"https://github.com/microsoft/TypeScript/issues/7318\" target=\"_blank\" rel=\"noopener noreferrer\">函数装饰器</a>，目前基本毫无希望了。</p>\n<p>类还有一个好处，在依赖注入中，我们需要 Key-Value，类可以既当作 Key，也可以当作 Value。\n可以直接使用<code>const countService = useService(CountService)</code>获取服务。</p>\n<p>如果我们想要注入一个字符串<code>http://test.com/</code>，那么我们还要同时定义一个 Key，比如是<code>const publicPath = 'PUBLIC_PATH'</code>。\n然后使用<code>declareProviders([{provide: publicPath, useValue: 'http://test.com/'}])</code>注册服务，\n再使用<code>const publicPathValue = useService(publicPath)</code>获取服务</p>\n<p><a href=\"https://www.zhihu.com/question/376817427/answer/1069081450\" target=\"_blank\" rel=\"noopener noreferrer\">领域驱动设计</a>\n可以参考这篇文章，非常有深度，虽然我也不能完全理解到位，但是我觉的非常有共鸣。</p>\n<p>注意一下数据驱动这个术语的不同含义，上面有提到 vue 是数据驱动的，我的理解是 vue 的组件是数据驱动模版的，数据变化了，模板会跟着更新。\n而知乎文章里提到的数据驱动设计是相对于领域驱动设计的，说的不是一回事。\n我的简单的理解是数据驱动设计是全局单一数据源，然后组件订阅该数据源部分数据。领域驱动设计重点区别在于不是全局的。而是聚焦于特定领域。\n所谓特定领域则是特定的一些数据和方法的集合。比如学生服务 StudentService 是学生相关的数据和方法的集合。</p>\n<p>顺便再提一句我认为 angular 中 ngModule 绝对不是必需的。只不过是 angular 团队的一种选择而已，还是目前的一种选择。最新版的 angular11 已经开始支持可以不使用 ngModule 了。\n只要分析一下 ngModule 的 3 个属性就能大概理解 ngModule 的作用了：\ndeclarations 声明当前 module 有哪些组件，指令，管道\nexports 导出当前 module 的部分组件，指令，管道\nimports 导入其它 module 导出的组件，指令，管道</p>\n<p>这些内容<a href=\"https://angular.io/guide/ngmodule-api\" target=\"_blank\" rel=\"noopener noreferrer\">angular 官网</a>上都有，每个字都能看的懂，但是却还是不太理解有什么用。\n实际上可以简单的理解为 angular 在编译模板的时候，需要知道模板中出现的那些标签（准确的叫做选择器）到底对应哪个组件、指令或者管道。\n只要参考一下 vue 中是怎么做的就更容易理解了，vue 中需要在组件中 components 属性注册当前组件依赖的其它组件。所以 vue 中的做法是在每一个组件上注册自己依赖的其他组件。</p>\n<p>但是在 angular 中则是在一个 module 中注册需要的组件。</p>\n<p>再来看看<a href=\"https://zhuanlan.zhihu.com/p/70148492\" target=\"_blank\" rel=\"noopener noreferrer\">这篇文章</a>，这里提供了一种思路可以做到自动化全局注册组件。全局注册也是有缺点的，比如没有使用到的组件也会被加载，组件重名问题。</p>\n<p>所以声明组件依赖有三种方式：组件本身，module，全局。只不过 angular 选择了 module 而已。然后 angular 又在 module 的基础上附加了其他功能，比如声明服务的 providers。回到问题本身，答案就是这是 angular 团队的选择而已，并不是必不可少的，也不是毫无缺点的。</p>\n<p>再对比一下 vue 和 react 中声明组件的区别，在 vue 中首先需要 import 组件，然后在 components 属性中注册组件。总共需要两步。\n但是在 react 中则只需要 import 组件即可以使用了，这是因为 jsx 和 js 是作用域是一致的。所以我一直觉得 vue 中局部注册组件是毫无必要的，因为我都已经 import 了，为什么模板不能从当前作用域中寻找对应的组件呢？</p>\n<p>具体原因没有研究过，期待有人能告诉我一下。我个人猜测是和 vue 中组件名称比较混乱有关，有好几种格式。导致模板编译的时候不知道应该编译成那种形式的变量名？\n比如在 react 的 jsx 中遇到标签 UserInfo，那么组件名一定就是 UserInfo，而且 react 强制要求组件名首字母必须大写。但是在 vue 中则不一定了。导致编译成 render 函数时不能直接编译过来，现在还是通过标签名在 components 对象中去查找，而且会按照优先级依次判断各种格式的组件名，直到查找到组件为止。\n<a href=\"https://github.com/vuejs/vue/blob/861aea16615a9736eab6af6d05fa5500ae4d6c37/src/core/vdom/create-element.js#L111\" target=\"_blank\" rel=\"noopener noreferrer\">createElement 源码链接</a>\n<a href=\"https://github.com/vuejs/vue/blob/7912f75c5eb09e0aef3e4bfd8a3bb78cad7540d7/src/core/util/options.js#L442\" target=\"_blank\" rel=\"noopener noreferrer\">resolveAsset 源码链接</a></p>\n<p>但是都无所谓了，因为借助<a href=\"https://github.com/vuejs/rfcs/pull/227\" target=\"_blank\" rel=\"noopener noreferrer\">setup 提案</a>，现在我们也不需要手动在 components 中注册组件了，只需要 import 相应的组件即可。</p>\n<p>当然在 vuex 中也是可以划分 module 的，此 module 和 angular 中的 module 不是一回事，它更像是 angular 中的 service。所以也可以说 vuex 也具有部分领域驱动的特性。\n但是相比于 angular 中 service 的依赖注入的特点，显得不够灵活。</p>\n<p>vue 缺点</p>\n<p>vue 中注册局部 components 比较麻烦\nvue 中 api 和语法比较多，总是记不住。=</p>\n<p>template 和 jsx 区别？\n第一层：template 相比于拼接字符串有了很大的提升\n第二层：jsx 是什么玩意？完全看不懂为啥能在模版里直接写 js\n第三层：jsx 真香，template 显得太不灵活了\n第四层：jsx 过于灵活了，导致代码逻辑混乱，完全没有做到 UI 和逻辑的分离。相反 template 只是做了它该做的事情。\n第五层：jsx 和 template 都有它的优点。看个人喜好以及场景决定使用哪个。</p>\n<p>computed 和 watch 的区别</p>\n<p>这个在 mobx 中叫做 computed 和 reactions。\ncomputed 是多个值计算出一个新的值，watch 则是观察一个值，然后触发一些副作用，这些副作用可以修改多个值。\n说到这里不得不提的就是 rxjs 了，可以理解为 rxjs 就是 computed 和 reactions 的集合，但是更加强大。\n比如 rxjs 中的流可以衍生出新的流，也可以多个流衍生出新的流。每个流都可以 subscribe 自己的副作用。</p>\n<h2 id=\"常见库的实现对比\"> 常见库的实现对比</h2>\n<p><a href=\"https://github.com/reduxjs/redux\" target=\"_blank\" rel=\"noopener noreferrer\">reduxjs/redux</a></p>\n<p>redux 本身的概念比较简单，但是复杂的地方在于很难单独使用它，必须结合 react-redux 这样的连接库才能比较方便的工作。\n这就意味着必须要同时掌握 redux 和 react-redux 才能顺利使用。</p>\n<div><pre><code>const store = createStore(someReducer);\nstore.subscribe(() =&gt; console.log(store.getState()));\nstore.dispatch({type: &#39;someType&#39;});\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>最核心的 api 就是这三个了，当然比较关键的还有一点是 reducer 的定义。reducer 本身是一个纯函数，是和 redux 无关的。但是函数签名必须满足：\n<code>(previousState, action) =&gt; newState</code>，其实这也是和类所表达的服务是一个东西。是数据和方法的封装。其中 state 部分就是数据。action 部分就是方法。只不过这里的 action 部分使用的是 type，类型是字符串而已。</p>\n<p>尤其要注意其中的 state 部分，虽然说 reducer 是一个纯函数，但其实并不够纯，以为 initalState 必然属于闭包中的一个变量值。</p>\n<p>如果不使用 react-redux，可以参考这个<a href=\"https://codesandbox.io/s/github/reduxjs/redux/tree/master/examples/counter\" target=\"_blank\" rel=\"noopener noreferrer\">简单的例子</a>。\n这里还有 redux 官网<a href=\"https://github.com/reduxjs/redux#examples\" target=\"_blank\" rel=\"noopener noreferrer\">其他例子</a>。</p>\n<p>使用 reduce 表达服务\n使用 combineReducers 来组合服务\n可以读取 store 中的数据，以及通过 dispatch 修改数据，但是数据并不会自动更新模板</p>\n<p><a href=\"https://github.com/reduxjs/react-redux\" target=\"_blank\" rel=\"noopener noreferrer\">reduxjs/react-redux</a></p>\n<p>基于 redux 的链接 react 和 redux 的库，基本特性和 redux 一致，主要是解决了 store 中数据变化时，模版也会自动更新。</p>\n<p>主要 api 是 connect 和 Provider。\nProvider 通过 context 提供了全局的 store，是为了 conenct 服务的。在 connect 中可以随时通过 context 获取到 store。从而读取数据。\nconnect 本身是是一个函数，该函数返回值是一个高阶组件。注意高阶组件是一个函数，而不是组件。这个函数可以包裹我们自己的组件。\n该高阶组件可以通过闭包拿到 connect 提供的 mapStateToProps 和 mapDispatchToProps，通过这两个函数再加上 context 中的 store，就可以获取到相应数据和方法了。\n其中数据部分是：<code>store+mapStateToProps=&gt;newState</code>，其中方法部分是：<code>store.dispatch+mapDispatchToProps=&gt;newActions</code>。\n目前为止还只能解决组件第一次渲染的时候获取数据的问题，关键还是要解决数据变化的时候，组件如何响应更新。</p>\n<p>实际上还是需要依赖 store.subscribe 这个 api，会在组建 mounted 时注册一个监听器，卸载组件时取消监听器。\n该监听器每次会重新从 store 获取数据，并和缓存中的数据做对比，如果数据有变化，那么执行 setState 操作，从而更新组件。</p>\n<p>缺点是模版代码很多，而且在 reducer 中已经定义了数据和方法了，在 connect 中还是需要再次定义数据和方法。</p>\n<p><a href=\"https://github.com/mobxjs/mobx\" target=\"_blank\" rel=\"noopener noreferrer\">mobxjs/mobx</a>\n<a href=\"https://github.com/mobxjs/mobx-react\" target=\"_blank\" rel=\"noopener noreferrer\">mobxjs/mobx-react</a>\n<a href=\"https://github.com/mobxjs/awesome-mobx#examples\" target=\"_blank\" rel=\"noopener noreferrer\">mobx 官方例子</a></p>\n<p>mobx 和 vue 非常像，可以说大部分能力 vue 已经天生支持了，剩下的就是如何组织代码而已。<a href=\"https://cn.mobx.js.org/intro/overview.html\" target=\"_blank\" rel=\"noopener noreferrer\">参考官方文档</a>。</p>\n<ol>\n<li>第一步：定义可观察数据，可以是对象或者类。这里依赖 mobx 的 observable 这个 API。</li>\n<li>第二步：定义组件。这里依赖 mobx-react 的 observer 这个 API。</li>\n<li>第三步其实和 mobx 就没有关系了，我们只要改变了数据，组件就会自动更新。</li>\n</ol>\n<p>再对比 vue3 中的实现，第一步其实就是 reactive 这个 api，第二步中 vue 组件默认就是会观察 reactive 数据的，所以也不需要 observer 这个 API。</p>\n<p>参考这个<a href=\"https://github.com/gothinkster/react-mobx-realworld-example-app\" target=\"_blank\" rel=\"noopener noreferrer\">demo</a></p>\n<ol>\n<li>采用类来定义服务，但是需要具体声明各个属性和方法的性质，比如@observable @computed @action</li>\n<li>然后导出一个类的实例，这里就能看出来至少在这个项目中服务都是单例的，如果需要多例，就需要自己手动 new 多个实例。</li>\n<li>然后在根组件使用 Provider</li>\n<li>然后在组件中就可以@inject('articlesStore')类似这样注入服务</li>\n</ol>\n<p>参考这个<a href=\"https://github.com/mobxjs/mobx-react-todomvc\" target=\"_blank\" rel=\"noopener noreferrer\">demo</a>\n这里没有使用 Provider，而是通过 props 从根组件一层层传递服务</p>\n<p><a href=\"https://github.com/mobxjs/mobx-state-tree\" target=\"_blank\" rel=\"noopener noreferrer\">mobxjs/mobx-state-tree</a></p>\n<p>mobx-state-tree 虽然是基于 mobx 的，但是定位应该是和 mobx 是一样的，只不过在于组织代码方面有所区别。</p>\n<p>参考<a href=\"https://github.com/mobxjs/mobx-state-tree/tree/master/packages/mst-example-redux-todomvc\" target=\"_blank\" rel=\"noopener noreferrer\">这个例子</a></p>\n<p>可以发现居然还可以和 redux 相结合，虽然我觉得有点脱裤子放屁了。这里面有很多的重复性工作。\n依赖 redux 的 Provider 来提供全局单一数据源，然后依赖 connect 订阅数据源。\n在定义 mobx-state-tree 的模型的 actions 时，需要 actions 常量作为方法名。\n在 mapDispatchToProps 时也需要 actions 常量生成方法名，关键是组件中的 props 还是需要定义一摸一样的方法名来接受 props。\n总之就是非常繁琐，而且耦合非常严重，但是确实可以工作，而且能非常明确的看出来 mobx-state-tree 具体做了什么工作，没有做什么工作。\n还有一点就是 mobx-state-tree 首先是定义了模型（model），这里的 model 可以看作服务，数据和方法的集合。但是实际使用时，还是需要我们手动初始化的。\n<code>const someStore = SomeStore.create(initialState)</code></p>\n<p>参考<a href=\"https://github.com/mobxjs/mobx-state-tree/tree/master/packages/mst-example-bookshop\" target=\"_blank\" rel=\"noopener noreferrer\">这个例子</a>\n这个例子可以明显看出来 mobx-state-tree 是代替了 mobx，并且配合 mobx-react 来工作的。\n上面有分析过，主要就是 Provider 和 inject 注入 store，并且 mobx-state-tree 是依赖 mobx 的，所以数据本身也是响应式的。\n可以明显看出来，mobx-state-tree 和 mobx 的区别在于组织代码的区别。\nmobx 是采用类来组织数据和方法。\nmobx-state-tree 是基于自带的类型定义采用链式方法调用来定义数据和方法。并且 Model 本身就是类型，也就意味着 Model 是可以嵌套的，所以这也是 mobx-state-tree 名称的来源，因为 Model 就是 state，嵌套之后就会形成一颗树。但是 mobx 中的类则不能相互嵌套形成复杂的“类树”。</p>\n<p><a href=\"https://github.com/reduxjs/redux-thunk\" target=\"_blank\" rel=\"noopener noreferrer\">reduxjs/redux-thunk</a>\n<a href=\"https://github.com/redux-saga/redux-saga\" target=\"_blank\" rel=\"noopener noreferrer\">redux-saga/redux-saga</a>\n<a href=\"https://github.com/redux-observable/redux-observable\" target=\"_blank\" rel=\"noopener noreferrer\">redux-observable/redux-observable</a></p>\n<p><a href=\"https://github.com/dvajs/dva\" target=\"_blank\" rel=\"noopener noreferrer\">dvajs/dva</a></p>\n<p><a href=\"https://github.com/vuejs/composition-api\" target=\"_blank\" rel=\"noopener noreferrer\">vuejs/composition-api</a>\n<a href=\"https://github.com/concentjs/concent\" target=\"_blank\" rel=\"noopener noreferrer\">concentjs/concent</a>\n<a href=\"https://zhuanlan.zhihu.com/p/114655336\" target=\"_blank\" rel=\"noopener noreferrer\">concent 知乎专栏</a>\n<a href=\"https://github.com/yisar/doux\" target=\"_blank\" rel=\"noopener noreferrer\">yisar/doux</a></p>\n<p><a href=\"https://github.com/ReactiveX/rxjs\" target=\"_blank\" rel=\"noopener noreferrer\">ReactiveX/rxjs</a>\n<a href=\"https://github.com/vuejs/vue-rx\" target=\"_blank\" rel=\"noopener noreferrer\">vuejs/vue-rx</a></p>\n<p><a href=\"https://github.com/immerjs/immer\" target=\"_blank\" rel=\"noopener noreferrer\">immerjs/immer</a></p>\n<p>这个库不是做状态管理的，只是提供了 produce 这个函数来实现 immutable 特性。</p>\n<h2 id=\"需要解决的问题\"> 需要解决的问题</h2>\n<p>单例和多例\n服务的边界-数据和方法\n类\nreducer+connect\n数据驱动模版/组件\nProvider\n服务如何管理/组合\n依赖注入\ncombineReducers</p>\n<h2 id=\"vue-和-react-的数据驱动的区别\"> vue 和 react 的数据驱动的区别</h2>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "前端发展各个阶段",
      "url": "https://www.kaokei.com/project/use-vue-service/articles/frontend-stage/",
      "id": "https://www.kaokei.com/project/use-vue-service/articles/frontend-stage/",
      "content_html": "<h2 id=\"前端的-4-个阶段\"> 前端的 4 个阶段</h2>\n<p><img src=\"/assets/image/project/history.png\" alt=\"前端的4个阶段\" /></p>\n<h2 id=\"jquery-阶段\"> jquery 阶段</h2>\n<p>jquery 时代，以及 jquery 之前的时代，是完全命令式的编程。没有模块化，没有工程化，只不过可以通过 jquery 实现跨浏览器的兼容性，以及基于 jquery 生态的插件化开发。</p>\n<h2 id=\"组件阶段\"> 组件阶段</h2>\n<p>由上图可知组件自带状态和逻辑，当然还有视图。当我们定义好一个组件时，该组件是可以在多个地方使用的，这是组件在代码复用层面的优势。</p>\n<p>组件的另一个优势则是响应式编程。这是与命令式编程相对应的另一种编程模式。响应式编程又可以理解为数据驱动式编程。</p>\n<p>在 jquery 时代，当用户点击了某个按钮，在监听事件中，我们需要自己做两件事，第一件事是根据用户点击行为修改内存中的某些数据。第二件事是根据修改后的数据，再次修改网页上的视图部分。目的是为了保证数据和视图的一致性。</p>\n<p>但是在组件时代，我们不需要自己来做这两件事了。我们只需要修改数据即可。前端框架会帮我们保证数据和视图的一致性。也就是当数据修改了，页面视图部分会自动更新。</p>\n<p>除了组件本身的优势以外，我们还可以借助 babel 来实现前端的模块化和工程化，从而提升开发体验以及效率。</p>\n<h2 id=\"hooks-阶段\"> hooks 阶段</h2>\n<p>组件时代看起来已经很完美了。但是依然还是有缺陷的。就是组件和组件之间不能共享逻辑代码。</p>\n<p>比如在 A 组件中有一个功能是展示当前用户的 name，已经可以编辑该 name。在另一个 B 组件中也有类似的功能。</p>\n<p>在没有 hooks 之前，我们可能会把这个功能抽象成一个组件 NameComponent，然后分别在 A 组件和 B 组件中使用 NameComponent 即可。但是如果我们想要在 A 组件和 B 组件中的样式不一样。那么我们就需要给 NameComponent 增加 props，然后在 A 和 B 组件中分别传入不同的参数。</p>\n<p>现在这样做是不够解藕的。逻辑的归逻辑，视图的归视图。我们可以利用 hooks 函数做到逻辑和视图彻底的解藕。</p>\n<p>把状态和逻辑从组件中分离出来，主要依赖于 composition api，主要是封装成类似 react 中的 hooks 函数。这样的好处是，这个函数是可以在多个组件中复用的。</p>\n<h2 id=\"服务阶段\"> 服务阶段</h2>\n<p>在 hooks 阶段 中，组件已经和逻辑分离了，但是，还是强耦合的。这里的强耦合是相对的。是需要一定的视角去理解的。</p>\n<p>那么如何理解服务呢？其实从大体上来理解是非常简单的。hooks 就是服务的实例化，服务是 hooks 的抽象。实例化和抽象可以参考类的实例和类的关系。</p>\n<p>从代码使用风格上来看，我们之前是直接在组件内调用 hooks 函数。现在我们是在组件内调用服务类来获取服务实例，也就是通过服务类来获取 hooks 实例。</p>\n<p>尤其要注意这里的差别，以前是直接就使用 hooks 了，现在是通过中间的服务才能使用 hooks。所以说以前是强依赖 hooks 的，现在则是面向抽象编程、面向接口编程。</p>\n<p>面向抽象编程、面向接口编程这些有逼格的文案其实没什么意思。如果只看以上的介绍，其实也看不出来直接调用 hooks 函数和通过服务获取 hooks 的差别是什么。其实真的没什么差别，如果我们什么也不做的话。</p>\n<p>最关键的地方在于直接调用 hooks 函数，我们没有办法干预这个 hooks 执行的过程。但是通过服务来获取 hooks 的过程我们是可以干预的。从而实现以下这样的效果。</p>\n<ul>\n<li>本来通过 AService 应该获取的是 AService 的实例，实际上通过配置可以对使用方透明的替换成 BService 的实例。</li>\n<li>在以前 hooks 时代，hooks 执行后，hooks 的状态是一定和当前组件强制绑定的。但是现在可以统一管理服务，服务的状态不是强制和当前组件绑定的，而是可以选择和某个组件绑定，并且在其他组件中也可以获取同一个服务实例，从而方便的实现跨组件通信。</li>\n</ul>\n<p>回过头来看，可以清楚的看到 hooks 时代，组件是强制依赖 hooks 的，但是服务时代，则需要通过服务这个概念来间接的使用 hooks，从而可以方便的实现跨组件通信以及状态管理。</p>\n<p>很久之前就看过一句话，react 和 vue 迟早有一天会变成 angular。</p>\n",
      "image": "https://www.kaokei.com/assets/image/project/history.png",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "依赖注入",
      "url": "https://www.kaokei.com/project/use-vue-service/articles/reactive-analysis/",
      "id": "https://www.kaokei.com/project/use-vue-service/articles/reactive-analysis/",
      "content_html": "<h2 id=\"doux\"> doux</h2>\n<p>该库似乎已经被删除了，但是历史代码还存在，代码实现比较简单，非常方便入门分析。</p>\n<p>observable 相当于 reactive\nobserve 相当于 watch\nobserver 相当于 watchEffect</p>\n<p>其实 observable 和另外两个是比较独立的，可以独立分析。</p>\n<p>observable 在 get/ownKeys/has 三个方法中会调用 track 方法来收集依赖。在 set/deleteProperty 这个两个方法中会调用 trigger 方法来触发副作用。</p>\n<p>对比 track 和 trigger 的参数部分，主要是通过 target+key 这两个参数作为链接的桥梁。简单的理解为在 track 时，把 activeEffect 存储到 target+key 对应的 map 中，当 trigger 发生时就可以通过 target+key 来获取曾经保存的 activeEffect，然后执行它。关键点在于 activeEffect 是一个运行时产生的，observable 本身是不依赖它的。</p>\n<p>提到 activeEffect，它是怎么产生的呢？其实就是由 observe 产生的。observe 的返回值就是 effect。\n其中这段代码说明了 activeEffect 是怎么产生的：</p>\n<div><pre><code>effectStack<span>.</span><span>push</span><span>(</span>effect<span>)</span><span>;</span>\nactiveEffect <span>=</span> effect<span>;</span>\n<span>return</span> <span>Reflect</span><span>.</span><span>apply</span><span>(</span>fn<span>,</span> ctx<span>,</span> args<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>其中<code>fn</code>就是我们想要观察的代码，想要收集依赖的代码。所以在执行该代码之前，我们提前准备好 activeEffect。</p>\n<p>observer 主要是实现了对组件的观察，主要是判断 effect 是否有 cb 属性。</p>\n<div><pre><code>effects<span>.</span><span>forEach</span><span>(</span><span>(</span>e<span>:</span> Effect<span>)</span> <span>=></span> <span>(</span><span>isFn</span><span>(</span>e<span>.</span>cb<span>)</span> <span>?</span> e<span>.</span><span>cb</span><span>(</span>e<span>)</span> <span>:</span> <span>e</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"dob\"> dob</h2>\n<p>首先查看最简单的例子。</p>\n<div><pre><code><span>import</span> <span>{</span> observable<span>,</span> observe <span>}</span> <span>from</span> <span>\"dob\"</span><span>;</span>\n\n<span>const</span> obj <span>=</span> <span>observable</span><span>(</span><span>{</span> a<span>:</span> <span>1</span> <span>}</span><span>)</span><span>;</span>\n\n<span>observe</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>\n  <span>debugger</span><span>;</span>\n  <span>console</span><span>.</span><span>log</span><span>(</span><span>\"obj.a has changed to\"</span><span>,</span> obj<span>.</span>a<span>)</span><span>;</span>\n<span>}</span><span>)</span><span>;</span> <span>// &lt;· obj.a has changed to 1</span>\n\nobj<span>.</span>a <span>=</span> <span>2</span><span>;</span> <span>// &lt;· obj.a has changed to 2</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>首先 observable 会把一个普通对象转变为 Proxy 对象。主要是 get/set/deleteProperty 这三个属性。这种转变只是为了后续作服务的。</p>\n<p>当执行 observe 函数时，类似于 vue-next 中的 watchEffect，它是立即执行的。关键在于 Reaction 中有一段代码是这样的。</p>\n<div><pre><code>global_state_1<span>.</span>globalState<span>.</span>currentReaction <span>=</span> <span>this</span><span>;</span> <span>// Clear bindings first.</span>\n\n<span>this</span><span>.</span><span>clearBinding</span><span>(</span><span>)</span><span>;</span>\n\n<span>try</span> <span>{</span>\n  <span>callback</span><span>(</span><span>{</span>\n    debugId<span>:</span> global_state_1<span>.</span>globalState<span>.</span>currentDebugId\n  <span>}</span><span>)</span><span>;</span>\n<span>}</span> <span>finally</span> <span>{</span>\n  global_state_1<span>.</span>globalState<span>.</span>currentReaction <span>=</span> <span>null</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这段代码是非常经典的，首先设置当前的依赖项 currentReaction，然后执行 callback，再清除 currentReaction。这样在执行 callback 的过程中，会触发 observable 中设置的 getter 函数。会把 currentReaction 当作所有数据的依赖。关键代码在<code>bindCurrentReaction</code>中实现。</p>\n<p>相应的当我们执行<code>obj.a = 2</code>时，会触发 Proxy 的 setter 函数，会调用 queueRunReactions 从而找到刚才保存下来的 currentReaction，然后就可以<code>runReaction(currentReaction)</code>。</p>\n<p>重点需要关注<code>Reaction</code>的实现，类似于 vue-next 中的<code>effect</code>的实现。</p>\n<p>另一个比较重要的点是这个库非常依赖全局状态管理，主要集中在 global-state.ts 文件中，尤其是其中的 objectReactionBindings 这个对象。它全局保存了数据和 Reaction 的依赖关系。</p>\n<p>依赖<code>dependency-inject</code>实现依赖注入的功能。</p>\n<h2 id=\"dob-react\"> dob-react</h2>\n<p>主要是提供了 Provider 和 Connect 这两个方法。可以在 Provider 这个组件上声明任意多个 props，这些 props 数据都会被注入到<code>@Connect</code>装饰的组件中。</p>\n<p>也就是说我们自己写的组件如果使用了<code>@Connect</code>装饰器，那么组件内<code>this.props</code>就会自动被注入一些属性，这些属性就是 Provider 上声明的属性。</p>\n<p>目前发现的唯一路径是这样的。<code>observe</code>调用<code>new Reaction</code>调用<code>设置currentReaction</code>，然后在访问 getter 时，就会把数据和 currentReaction 绑定起来，也就是<code>bindCurrentReaction</code>。</p>\n<p>在 dob 中只能通过<code>observe</code>才能实现依赖收集。在<code>dob-react</code>中，有以下流程：\n<code>@connect</code>调用<code>mixinAndInject</code>调用<code>mixinLifecycleEvents</code>调用<code>patch</code>调用<code>reactiveMixin</code>调用<code>initialRender</code>调用<code>new Reaction</code>，从而把组件的 render 函数和数据绑定起来。</p>\n<p>当然最终的实现部分还是需要注意<code>baseRender</code>和<code>initialRender</code>和<code>reactiveRender</code>之间的关系。</p>\n<h2 id=\"concent\"> concent</h2>\n<p>这是一个框架，而且功能非常强大，并且更新非常活跃。同时支持类组件和函数组件。唯一我不太喜欢的地方可能就是过于复杂了，上手成本有点高，再加上使用字符串来区分模块也是一个原罪。不过它仍然是一个非常优秀的框架。</p>\n<p>我这里重点关注一下 register 和 useConcent 是如何实现组件的响应式更新的。</p>\n<p>参考官方文档中<a href=\"https://concentjs.github.io/concent-doc/api-much-used/useConcent\" target=\"_blank\" rel=\"noopener noreferrer\">最简单的例子</a></p>\n<div><pre><code><span>function</span> <span>Demo</span><span>(</span><span>)</span> <span>{</span>\n  <span>const</span> <span>{</span> state<span>,</span> setState <span>}</span> <span>=</span> <span>useConcent</span><span>(</span><span>{</span> module<span>:</span> <span>\"foo\"</span> <span>}</span><span>)</span><span>;</span>\n  <span>const</span> <span>changeName</span> <span>=</span> e <span>=></span> <span>setState</span><span>(</span><span>{</span> name<span>:</span> e<span>.</span>target<span>.</span>value <span>}</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>可以猜测到 useConcent 本身是不需要做依赖收集的。因为我们还是需要手动调用<code>setState</code>方法去更新数据，这时可以强制调用<code>forseUpdate</code>方法去更新组件。</p>\n<p>分析源码可知，useConcent 返回值是一个<code>CcHook</code>的实例对象。这个实例对象的 state 和 setState\b 就是<code>React.useState</code>的返回值。综上 useConcent 就是对<code>React.useState</code>的封装，说明我猜测的没有错。</p>\n<p>我还发现 useConcent 是不支持直接 mutable 修改 state 数据的，只能通过 setState 来修改数据。make-ob-state.js 中的 setter 中是没有 trigger 方法的，说明确实没有实现 mutable 响应式。</p>\n<p>当然 useConcent 是需要做到多个组件共享数据的，也就是一个组件修改了数据，可能会影响到别的组件。</p>\n<p>useConcent 调用 buildRef 调用 buildRefCtx，其中 buildRefCtx 会修改 ref.state 属性，该属性会合并当前组件的 state 和 moduleState。这就是 useConcent 从全局获取 moduleState 的过程。</p>\n<p>至于 moduleState 状态的改变，是如何改变所有依赖这个 moduleState 所有组件的稍微复杂一些。</p>\n<p>build-ref-ctx.js 中使用了 makeObState 处理了 state\b 数据，\b 从而利用 Proxy 的 getter 收集依赖。收集依赖的逻辑在 updateDep 函数中。主要是以下代码。</p>\n<div><pre><code><span>// 这个key代表着refCtx，从而可以利用这个refCtx来更新组件</span>\n<span>const</span> ccUniqueKey <span>=</span> refCtx<span>.</span>ccUniqueKey<span>;</span>\n<span>// 这个key代表着数据foo/count</span>\n<span>const</span> waKey <span>=</span> <span>makeWaKey</span><span>(</span>module<span>,</span> key<span>)</span><span>;</span>\n<span>// 最终在wakey-ukey-map.js文件中把这两个key通过waKey2uKeyMap关联起来。</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>当用户点击某个按钮，触发点击事件，然后调用 setState 去修改数据时，这个 setState 其实是在 build-ref-ctx.js 文件中定义的，最终会调用 changeState 调用 changeRefState。\nchangeRefState 会调用 triggerBroadcastState 会调用 broadcastState，其中有个重要的函数是 findUpdateRefs，这个函数会返回所有依赖了变更数据的 ref 的 key。有了这个 key，再加上我们还有全局的 ref 对象池。</p>\n<div><pre><code><span>// 获取全局ref对象池，是一个Record&lt;string, Ref>的对象</span>\n<span>const</span> ccUKey2ref <span>=</span> ccContext<span>.</span>ccUKey2ref<span>;</span>\n<span>// 通过key和全局ref对象池，就能获取到ref对象</span>\n<span>const</span> ref <span>=</span> ccUKey2ref<span>[</span>refKey<span>]</span><span>;</span>\n<span>// 有了ref对象，就能触发这个ref上的setState方法，从而\b更新组件</span>\n<span>triggerReactSetState</span><span>(</span>ref<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>以上分析我是通过 debug 代码观察到 \b 的整个过程。当然我只是观察了最简单的两个组件依赖同一个 module 的过程。</p>\n<p>我观察到的最大的结论是 useConcent\b 没有实现 Proxy 中的 setter 的响应式触发，也就是不支持 mutable 更新数据。第二点就是 concent 在保存数据和视图的依赖关系时，是通过保存 key 与 key 之间的依赖关系，而且还保存了全局的 ref 对象池。从而实现当某个数据变化时，多个依赖该数据的视图都能得到更新。相对应的在很多别的 \b 库中，都是直接通过 map 来保存数据和 Dep 之间的依赖关系。</p>\n<p>register 作为一个装饰器，会包装一个类组件，然后返回一个新的类组件。只需要知道这一行代码即可。</p>\n<div><pre><code><span>buildRefCtx</span><span>(</span><span>this</span><span>,</span> params<span>,</span> lite<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>上面有提到的 useConcent 的核心代码就是<code>buildRefCtx(hookRef, params, lite);</code>，这行代码内部会重新包装 state 和 setState，从而可以支持 module 等特性。</p>\n<h2 id=\"nx-js-observer-util\"> @nx-js/observer-util</h2>\n<p>observable 方法对应的是 reactive 方法，实现原理和 doux 比较一致，只是封装的更好一些。也是在不同的 handler 中处理 track 和 trigger。当然 track 和 trigger 需要处理的是 reaction，相当于 doux 中的 effect。</p>\n<p>observe 和 unobserve 则分别对应的是 watch 和 stopWatch 方法。注意这里使用<code>reaction.scheduler</code>代替了<code>reaction</code>。从而实现了从组件收集依赖和更新组件的分离。这一点和 doux 的<code>cb</code>属性是比较相似的。</p>\n<h2 id=\"preact-nx-observer\"> preact-nx-observer</h2>\n<p>observer 方法支持类组件，这里比较取巧的地方就是在 componentDidMount 中替换了 render 方法。</p>\n<div><pre><code><span>this</span><span>.</span>render <span>=</span> <span>observe</span><span>(</span><span>this</span><span>.</span>render<span>,</span> <span>{</span>\n  <span>scheduler</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span><span>}</span><span>)</span><span>,</span>\n  lazy<span>:</span> <span>true</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这一段代码还是比较巧妙的，但就是不知道兼容性如何。而且也没有支持函数组件。</p>\n<h2 id=\"react-easy-state\"> react-easy-state</h2>\n<p>store，以及 createStore 都是对 observable 的封装。只是增加了对<code>unstable_batchedUpdates</code>的支持。<a href=\"https://zhuanlan.zhihu.com/p/78516581\" target=\"_blank\" rel=\"noopener noreferrer\">参考这片文章</a></p>\n<p>view 则是对组件的封装。支持函数组件和类组件。</p>\n<p>注意类组件中是在构造函数中替换掉的 render 方法，对比<code>preact-nx-observer</code>是在 componentDidMount 中替换的。我认为在构造函数中替换更符合直觉。</p>\n<div><pre><code><span>// 针对函数组件的封装</span>\n<span>const</span> render <span>=</span> <span>useMemo</span><span>(</span>\n  <span>(</span><span>)</span> <span>=></span>\n    <span>observe</span><span>(</span>Comp<span>,</span> <span>{</span>\n      <span>scheduler</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>setState</span><span>(</span><span>{</span><span>}</span><span>)</span><span>,</span>\n      lazy<span>:</span> <span>true</span>\n    <span>}</span><span>)</span><span>,</span>\n  <span>// Adding the original Comp here is necessary to make React Hot Reload work</span>\n  <span>// it does not affect behavior otherwise</span>\n  <span>[</span>Comp<span>]</span>\n<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>// 针对类组件的封装</span>\n<span>this</span><span>.</span>render <span>=</span> <span>observe</span><span>(</span><span>this</span><span>.</span>render<span>,</span> <span>{</span>\n  <span>scheduler</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span><span>}</span><span>)</span><span>,</span>\n  lazy<span>:</span> <span>true</span>\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"mobx\"> mobx</h2>\n<div><pre><code><span>// 相当于vue-next中的reactive</span>\n<span>makeObservable</span><span>(</span>target<span>,</span> annotations<span>?</span><span>,</span> options<span>?</span><span>)</span>\n<span>makeAutoObservable</span><span>(</span>target<span>,</span> overrides<span>?</span><span>,</span> options<span>?</span><span>)</span>\n<span>observable</span><span>(</span>source<span>,</span> overrides<span>?</span><span>,</span> options<span>?</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>需要指定<code>@observable</code>,<code>@action</code>,<code>@computed</code>等来指定各个属性的性质。</p>\n<div><pre><code><span>// 相当于vue-next中的watch</span>\n<span>reaction</span><span>(</span><span>(</span><span>)</span> <span>=></span> value<span>,</span> <span>(</span>value<span>,</span> previousValue<span>,</span> reaction<span>)</span> <span>=></span> <span>{</span> sideEffect <span>}</span><span>,</span> options<span>?</span><span>)</span><span>.</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>// 相当于vue-next中的watchEffect</span>\n<span>autorun</span><span>(</span><span>effect</span><span>:</span> <span>(</span>reaction<span>)</span> <span>=></span> <span>void</span><span>)</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>// 对组件的封装</span>\n<span>import</span> <span>{</span> observer <span>}</span> <span>from</span> <span>\"mobx-react-lite\"</span><span>;</span> <span>// Or \"mobx-react\".</span>\n<span>const</span> MyComponent <span>=</span> <span>observer</span><span>(</span>props <span>=></span> ReactElement<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这里的 observer 功能非常强大，只要组件依赖了 observable 数据，不管这个<a href=\"https://mobx.js.org/react-integration.html#local-and-external-state\" target=\"_blank\" rel=\"noopener noreferrer\">数据的来源</a>是什么，都能触发组件重新渲染。</p>\n<p>尤其是对各种情况都考虑的非常周全，值得学习。</p>\n<h2 id=\"vue-next\"> vue-next</h2>\n<p>整个流程比较像<code>@nx-js/observer-util</code>，reactive 也是借助的 Proxy 来实现的，关键是 baseHandler 的实现。然后利用 track 来收集依赖。依赖被转为 effect，又有 activeEffect 和 effectStack 这些概念。</p>\n<p>可惜我只想依赖其中的@vue/reactivity 这个库。但是 watch/watchEffect 这两个方法都不包含在内，因为 watch 和 watchEffect 都是和 vue 深度绑定的。</p>\n<p>所以如果想要在 react 中使用，则必须实现自己的 watch/watchEffect 方法。</p>\n<p>我理解广义 watch 的 api 形式有这 3 种场景：</p>\n<ol>\n<li>指定需要 watch 的数据，可以是对象、数组、函数形式指定依赖数据，当数据有变化时，执行 callback</li>\n<li>指定一个 effect，第一次立即执行时会收集依赖，后续当这些依赖数据有变化的时候，会再次执行这个 effect</li>\n<li>指定 effect 和 callback，当 effect 对应的依赖有变化的时候，会执行 callback</li>\n</ol>\n<p>很容易发现在 vue-next 中已经实现了<code>watch</code>和<code>watchEffect</code>方法，但是实际上在 dowatch 中，又一个细节实现：</p>\n<div><pre><code><span>const</span> runner <span>=</span> <span>effect</span><span>(</span>getter<span>,</span> <span>{</span>\n  lazy<span>:</span> <span>true</span><span>,</span>\n  onTrack<span>,</span>\n  onTrigger<span>,</span>\n  scheduler\n<span>}</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>这段代码可以理解为观察 getter 返回的数据是否有变化，如果有变化就执行 scheduler。这就是上面提到的第 3 中 api。而且 1 和 2 就是依赖 3 来实现的。\n当 watch 的数据本身看作是一个 getter 时，1 就变成 3 了。\n当 effect 等于 callback 时，2 就是 3 的一种特殊形式。\n需要注意这里的 3 中的 effect 和 callback 不是完全独立的。如果是完全独立的，应该采用 1 这种形式以 getter 的形式提供观察的数据，而不是以 effect 的形式提供依赖数据。观察如下代码：</p>\n<div><pre><code><span>// 这里的本意是当state.count变化时，输出state.name</span>\n<span>// 但是这里不应该这么写</span>\n<span>watch</span><span>(</span>\n  <span>(</span><span>)</span> <span>=></span> <span>console</span><span>.</span><span>log</span><span>(</span>state<span>.</span>count<span>)</span><span>,</span>\n  <span>(</span><span>)</span> <span>=></span> <span>console</span><span>.</span><span>log</span><span>(</span>state<span>.</span>name<span>)</span>\n<span>)</span><span>;</span>\n<span>// 这里明确以getter的形式提供依赖数据</span>\n<span>watch</span><span>(</span>\n  <span>(</span><span>)</span> <span>=></span> state<span>.</span>count<span>,</span>\n  <span>(</span><span>)</span> <span>=></span> <span>console</span><span>.</span><span>log</span><span>(</span>state<span>.</span>name<span>)</span>\n<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>3 的场景可能是这样的。</p>\n<div><pre><code><span>// renderView是渲染试图的函数，也是我们观察的effect，当其依赖的数据有变化时，我们可能没有办法直接调用renderView这个函数</span>\n<span>// 我们只能通过另一个函数forceUpdate来触发视图更新</span>\n<span>watch</span><span>(</span>\n  <span>(</span><span>)</span> <span>=></span> <span>renderView</span><span>(</span>someView<span>)</span><span>,</span>\n  <span>(</span><span>)</span> <span>=></span> <span>forceUpdate</span><span>(</span>someView<span>)</span>\n<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"constate\"> constate</h2>\n<p><a href=\"https://github.com/diegohaz/constate\" target=\"_blank\" rel=\"noopener noreferrer\">github 网址</a></p>\n<p>我想实现的库可以看作是 constate 的升级版。现在 constate 只是把 hooks 都放到一个全局的空间中。然后达到所有组件可以共享这个 hooks 的状态。</p>\n<p>缺点是只有一个全局命名空间。而且服务的形式只能是 hooks，没有依赖注入，没有 mutable 响应式。</p>\n<p>优点是简单，而且只依赖 hooks 和 context，应该是兼容并发模式的。</p>\n<h2 id=\"react-类组件-vs-vue-类组件\"> react 类组件 vs vue 类组件</h2>\n<p>react 类组件是官方原生支持的，实例属性不是 reactive 的，只有通过 this.setState 修改 this.state 才会 re-render。</p>\n<p>vue 类组件必须借助 vue-class-component 才能工作，其原理也是转化为 Option 组件。其中所有实例属性都是 reactive 的。</p>\n<h2 id=\"总结\"> 总结</h2>\n<p>doux 使用函数组件包裹业务组件，也可以看作是<code>observe</code>函数的返回值作为 this.render\npreact-nx-observer 是<code>observe</code>直接返回新的 render 函数替换 this.render\nreact-easy-state 也是直接替换的 this.render\ndob-react 是需要自己构建新的 render 函数去替换 this.render\nconcent 主要是对<code>setState</code>的封装，而且不支持 mutable 响应式\nmobx 再看看\nvue-next 中的 render 函数默认就会收集依赖的，而且会把 render 函数当作一个 watchEffect 来对待</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "参考文章",
      "url": "https://www.kaokei.com/project/use-vue-service/articles/",
      "id": "https://www.kaokei.com/project/use-vue-service/articles/",
      "content_html": "<p>这里记录一些我对前端某些知识点的理解</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "进阶教程",
      "url": "https://www.kaokei.com/project/use-vue-service/guide/advance/",
      "id": "https://www.kaokei.com/project/use-vue-service/guide/advance/",
      "content_html": "<h2 id=\"简介\"> 简介</h2>\n<p>本教程继续介绍下面 2 个 api，可以用来支持更加复杂场景的需求。</p>\n<ul>\n<li>declareProviders</li>\n<li>Inject</li>\n</ul>\n<h2 id=\"解答问题\"> 解答问题</h2>\n<p>上篇文章中，即<a href=\"./base.html\">基础教程</a>中提到的三个问题，如下：</p>\n<ul>\n<li>为什么我们不自己 new CountService()，而要通过 useService 获取实例对象？</li>\n<li>useService(CountService) 这里并没有传递 LoggerService，那么这里是如何初始化 LoggerService 的？</li>\n<li>在不同的组件中调用 useService(CountService)，获取到的实例是不是同一个对象？</li>\n</ul>\n<p>其实这三个问题可以用一个名词来解答，就是<code>依赖注入</code>。</p>\n<p>第一个问题的答案就是，因为我们要使用依赖注入，我们要通过依赖注入来获取实例对象，而不是通过手动 new 来获取实例对象。至于为什么需要依赖注入，这是因为依赖注入相对于手动 new 更具有优势。</p>\n<p>第二个问题的答案就是，useService 会自动帮我们实例化一个 LoggerService 的实例，并且传递给 CountService 构造函数。这也是依赖注入其中一个最重要的优势的体现。依赖注入框架会自动帮助我们实现依赖的注入，包括依赖的依赖的注入，这是一个递归的注入过程。</p>\n<p>第三个问题的答案就是，useService 有一个非常重要的特性，在<code>同一个Injector</code>中<code>同一个服务</code>一定是<code>单例</code>的。\n所以默认情况下，在不同的组件中调用 useService(CountService)，获取到的实例是同一个对象，这种默认的特性正好完美的解决了跨组件通信的问题。具体体现在当任意一个组件内修改了 <code style=\"white-space: nowrap;\">countService.count</code> 属性，两个组件都会重新渲染。</p>\n<p>当然，针对特定的复杂场景我们可能需要实现一个服务可以有多个实例，我们可以有两种做法。第一种是使用不同的 Injector，不同 Injector 中的服务都是互相独立的。第二种就是在同一个 Injector 中，可以针对同一个服务取不同的名字，这样让 Injector 以为是不同的服务，从而得到多个实例。</p>\n<h2 id=\"给组件绑定-injector\"> 给组件绑定 Injector</h2>\n<p>默认情况下，本库提供了一个全局的根 Injector，它的生命周期是和应用一致的。所以如果是用户信息这类全局性质的数据，那么默认的 Injector 就能满足需求了。</p>\n<p>但是如果是某个页面的业务数据，我们期望进入页面的时候初始化数据，离开页面的时候应该销毁数据。那么就应该把这个服务关联到这个页面对应的组件上。这样服务的生命周期就和页面的生命周期一致了。</p>\n<p>我们可以借助 declareProviders 来关联组件和 Injector。</p>\n<div><pre><code><span>import</span> <span>{</span> declareProviders <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>在介绍如何使用 declareProviders 函数之前，我们必须弄清楚 useService 是如何工作的。前面已经介绍过 useService 是一个 hooks 函数，是只能在 setup 函数中使用的。</p>\n<p>我们还知道一个 vue 项目，最终的产出物就是一棵 vue 组件树，然后 vue 框架会通过 vue 组件树渲染成 dom 树。这个渲染细节我们暂时不用去关心，这里只需要关注 vue 组件树，在这棵树中，任意一个组件节点都有它的父节点，直到根结点。</p>\n<p>当我们在某个组件中调用 useService(CountService) 函数时，它会首先从当前组件关联的 Injector 中寻找是否存在 CountService 服务的 provider。如果没有找到，则进入到父组件关联的 Injector 中寻找 CountService 的 provider。如果还没有找到，则继续到更上一层父组件中寻找，直到找到相应服务的 provider，那么就通过这个 provider 获取一个对象出来。这个对象就是 useService(CountService)的返回值。当然还有一种情况就是直到根组件都没有找到 provider，针对这种情况，useService 做了一层 fallbak 机制，就是把 CountService 类当作默认 provider，然后用这个默认的 provider 来获取实例对象。</p>\n<p>通过上面简单的介绍，我们应该对 useService 解析机制有一个大概的认识，它和 js 中的原型链的解析机制以及 nodejs 中的 node_modules 解析机制都是非常相似的，应该不是很难理解。</p>\n<p>通过上面的介绍，我们知道默认情况下，在不同的组件中调用 useService(CountService)时，肯定是都找不到对应的 provider 的，最终都会冒泡到根组件上，在根组件对应的 Injector 中使用 CountService 类作为默认的 provider 获取实例对象，又因为同一个 Injector 中，同一个服务只有一个实例，所以不同的组件中获取到的是同一个 countService 实例对象。</p>\n<p>接下来介绍如何通过 declareProviders 函数来关联组件和 Injector。</p>\n<blockquote>\n<p><strong>注意</strong>：有关根组件和根 Injector 的关系上面的介绍在某些细节上存在一些瑕疵，但是不妨碍理解整体的工作机制。具体细节差别可以<a href=\"\">参考这里</a></p>\n</blockquote>\n<h3 id=\"定义-a-组件-没有-declareproviders\"> 定义 A 组件-没有 declareProviders</h3>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>\n    <span><span><span>&lt;</span>span</span><span>></span></span>{{ countService.count }}<span><span><span>&lt;/</span>span</span><span>></span></span>\n    <span><span><span>&lt;</span>button</span> <span>type</span><span><span>=</span><span>\"</span>button<span>\"</span></span> <span>@click</span><span><span>=</span><span>\"</span>countService.addOne()<span>\"</span></span><span>></span></span>+1<span><span><span>&lt;/</span>button</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n<span><span><span>&lt;</span>script</span> <span>lang</span><span><span>=</span><span>\"</span>ts<span>\"</span></span><span>></span></span><span><span>\n<span>import</span> <span>{</span> defineComponent <span>}</span> <span>from</span> <span>\"vue\"</span><span>;</span>\n<span>import</span> <span>{</span> useService <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n<span>import</span> <span>{</span> CountService <span>}</span> <span>from</span> <span>\"../services/count.service\"</span><span>;</span>\n\n<span>export</span> <span>default</span> <span>defineComponent</span><span>(</span><span>{</span>\n  <span>setup</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 返回的就是CountService类的实例</span>\n    <span>// 并且是reactive的</span>\n    <span>const</span> countService <span>=</span> <span>useService</span><span>(</span>CountService<span>)</span><span>;</span>\n    <span>return</span> <span>{</span>\n      <span>// 可以在模板中直接绑定数据和事件</span>\n      countService\n    <span>}</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>;</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id=\"定义-b-组件-使用-declareproviders\"> 定义 B 组件-使用 declareProviders</h3>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>\n    <span><span><span>&lt;</span>span</span><span>></span></span>{{ countService.count }}<span><span><span>&lt;/</span>span</span><span>></span></span>\n    <span><span><span>&lt;</span>button</span> <span>type</span><span><span>=</span><span>\"</span>button<span>\"</span></span> <span>@click</span><span><span>=</span><span>\"</span>countService.addOne()<span>\"</span></span><span>></span></span>+1<span><span><span>&lt;/</span>button</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n<span><span><span>&lt;</span>script</span> <span>lang</span><span><span>=</span><span>\"</span>ts<span>\"</span></span><span>></span></span><span><span>\n<span>import</span> <span>{</span> defineComponent <span>}</span> <span>from</span> <span>\"vue\"</span><span>;</span>\n<span>import</span> <span>{</span> useService <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n<span>import</span> <span>{</span> CountService <span>}</span> <span>from</span> <span>\"../services/count.service\"</span><span>;</span>\n\n<span>export</span> <span>default</span> <span>defineComponent</span><span>(</span><span>{</span>\n  <span>setup</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 手动定义CountService服务的provider</span>\n    <span>// 这里就是在当前组件上关联了一个新的Injector</span>\n    <span>declareProviders</span><span>(</span><span>[</span>CountService<span>]</span><span>)</span><span>;</span>\n    <span>// 返回的就是CountService类的实例</span>\n    <span>// 并且是reactive的</span>\n    <span>const</span> countService <span>=</span> <span>useService</span><span>(</span>CountService<span>)</span><span>;</span>\n    <span>return</span> <span>{</span>\n      <span>// 可以在模板中直接绑定数据和事件</span>\n      countService\n    <span>}</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>;</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>对比上面的 A 组件和 B 组件，我们发现唯一的差别就是 B 组件中调用了<code>declareProviders([CountService]);</code>，这行代码的功能就是在 B 组件关联了一个新的 Injector，并且配置了 CountService 这个服务的 provider。</p>\n<p>这行代码其实是一种简写，完整的代码应该是这样的：</p>\n<div><pre><code><span>declareProviders</span><span>(</span><span>[</span>\n  <span>{</span>\n    provide<span>:</span> CountService<span>,</span>\n    useClass<span>:</span> CountService\n  <span>}</span>\n<span>]</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>从完整的代码里，我们应该可以明确的看出来，其中<code>provide</code>属性定义了服务的名字，也就是指定了是哪个服务，一般称之为服务标识符。<code>useClass</code>属性则是指定了如何生成服务的实例。provide 和 useClass 所在的对象被称为 provider。关于具体的 provider 解释，具体可以<a href=\"\">参考这里</a>。</p>\n<p>我们还能发现 declareProviders 函数的参数是一个数组，其实是一个 provider 数组，这是很好理解的，因为一个组件是可以依赖多个不同的服务的，所以可以通过 declareProviders 函数一次性注册多个服务的 provider 的。</p>\n<p>接下来开始分析 A 组件和 B 组件中 useService 的差异了。</p>\n<p>在 A 组件中，因为没有使用 declareProviders，所以在当前组件以及父组件中都没有找到 CountService 服务的 provider，一直到根组件中都没有找到 provider，所以只能使用默认的 provider 获取实例对象。然后作为 useService 函数的返回值。</p>\n<p>在 B 组件中，因为 B 组件本身就已经定义了 CountService 服务的 provider，所以不用到父组件中去寻找了，更不需要到根组件中寻找了。直接在当前组件关联的 Injector 中获取服务的实例对象，然后作为 useService 函数的返回值。</p>\n<p>最后的总结就是 A 组件中的 countService 对象是在根组件关联的 Injector 中，B 组件中的 countService 对象是在 B 组件关联的 Injector 中。</p>\n<p>这样我们就达成了我扪想要的效果了，即通过 declareProviders 手动管理服务的位置，从而管理服务的生命周期，其实也是管理了该服务对哪个组件（及其子孙组件）可见，达到类似作用域的功能。同时我们也客观上实现了同一个服务可以具有多个实例对象，这里的意思是指根 Injector 和 B 组件关联的 Injector 中都有 CountService 实例对象。</p>\n<p>这里还是要多说一句，一开始我们一直强调同一个服务在同一个 Injector 下只有一个实例，这是默认行为。然后这里我们又花费了大篇文章介绍怎么实现同一个服务获取多个实例对象。看起来有些冲突，或者说是多此一举。实际上并不是这样的，这是因为业务的复杂性决定的，大多数简单的场景下我们是不需要 declareProviders 的，但是当业务场景足够复杂的时候，我们还是需要一种机制去实现多例的功能。为了满足不同的业务场景，我们肯定是需要提供这种基础能力的。</p>\n<h2 id=\"在服务中注入其他服务\"> 在服务中注入其他服务</h2>\n<p>在之前的介绍中我们一直用类来描述服务，但是实际上服务不仅仅只能是类来描述。</p>\n<p>本质上服务应该是数据和方法的集合体，极端场景也可以没有数据或方法，那么服务就退化为数据和方法了。所以有时候文档中会使用数据来代指服务。</p>\n<p>现在再反过来思考类和服务之间的关系，显然类本身是“不太能”直接作为服务来使用的，而应该是作为服务的工厂，通过类的实例化来生成服务对象。</p>\n<p>所以类只不过是生成服务对象的一种方式而已，我们还可以直接配置一个函数，然后把这个函数的返回值作为服务。</p>\n<p>最直接的情况就是我们不再需要一个生产服务的过程，而是直接配置服务本身。这个服务本身可以是对象、字符串、数字、布尔值、函数。甚至如果你愿意的话可以直接配置一个类作为服务本身（虽然我暂时还没有遇到这个场景）。</p>\n<p>还有另外一个问题也需要考虑，现在我们回归到使用类来描述服务，如果这个服务并不是象我们之前所举的例子 LoggerService 那么简单，没有任何依赖，而是具有非常复杂的依赖结构。比如这样的：</p>\n<div><pre><code>A --&gt; B、C、D\nB --&gt; C、D\nC --&gt; D、E\nD --&gt; E、F\nE --&gt; F\nF 没有依赖\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>考虑到这样复杂的场景，当我们使用<code>useService(A)</code>的时候，显然依赖注入框架本身是需要分析这种依赖关系的，然后依次实例化 F、E、D、C、B，最后才是实例化 A。</p>\n<p>而且这个例子中也特意规避了循环依赖的场景，本库已经支持了部分循环依赖，对于不支持的循环依赖也会有准确的异常报错。</p>\n<p>让我们再回归一下话题，不考虑依赖入住背后复杂的实现，我们现在需要做的应该是如何在代码成面来描述这种依赖关系。这里就需要借助<code>@Inject</code>这个装饰器了。</p>\n<h3 id=\"没有依赖的服务\"> 没有依赖的服务</h3>\n<div><pre><code><span>import</span> <span>{</span> Injectable <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n\n<span><span>@</span><span>Injectable</span></span><span>(</span><span>)</span>\n<span>export</span> <span>class</span> <span>LoggerService</span> <span>{</span>\n  <span>public</span> <span>log</span><span>(</span><span>...</span>msg<span>:</span> <span>any</span><span>[</span><span>]</span><span>)</span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span>\"from logger service ==>\"</span><span>,</span> <span>...</span>msg<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>很显然这是最简单的场景，这个服务没有任何的依赖，只需要使用<code>@Injectable()</code>这个装饰器声明一下这个服务可注入即可。</p>\n<blockquote>\n<p>实际上这里可以不用<code>@Injectable()</code>也是没问题的，只不过为了一致性，所有的服务都使用<code>@Injectable()</code>声明一下是一个良好的习惯。</p>\n</blockquote>\n<h3 id=\"通过构造函数注入依赖\"> 通过构造函数注入依赖</h3>\n<div><pre><code><span>import</span> <span>{</span> Injectable<span>,</span> Inject <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n<span>import</span> <span>{</span> LoggerService <span>}</span> <span>from</span> <span>\"./logger.service.ts\"</span><span>;</span>\n\n<span>const</span> someStringServiceToken <span>=</span> <span>\"stringServiceToken\"</span><span>;</span>\n<span>const</span> someNumberServiceToken <span>=</span> <span>\"numberServiceToken\"</span><span>;</span>\n\n<span><span>@</span><span>Injectable</span></span><span>(</span><span>)</span>\n<span>export</span> <span>class</span> <span>CountService</span> <span>{</span>\n  <span>public</span> count <span>=</span> <span>0</span><span>;</span>\n  <span>constructor</span><span>(</span>\n    <span>private</span> logger<span>:</span> LoggerService<span>,</span>\n    <span><span>@</span><span>Inject</span></span><span>(</span>LoggerService<span>)</span> <span>private</span> logger2<span>:</span> LoggerService<span>,</span>\n    <span><span>@</span><span>Inject</span></span><span>(</span>someStringServiceToken<span>)</span> <span>private</span> someStringService<span>:</span> <span>string</span><span>,</span>\n    <span><span>@</span><span>Inject</span></span><span>(</span>someNumberServiceToken<span>)</span> <span>private</span> someNumberService<span>:</span> <span>number</span>\n  <span>)</span> <span>{</span><span>}</span>\n\n  <span>public</span> <span>addOne</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>count<span>++</span><span>;</span>\n    <span>this</span><span>.</span>logger<span>.</span><span>log</span><span>(</span><span>\"addOne ==> \"</span><span>,</span> <span>this</span><span>.</span>count<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>这里展示了常见的几种注入方式。</p>\n<p>第一种方式：不使用<code>@Inject</code>，直接使用<code>private logger: LoggerService</code>。我们会得到一个 logger 实例属性，logger 的类型是 LoggerService。</p>\n<p>第二种方式：使用了<code>@Inject</code>，其效果是和第一种完全一致的。第一种方式可以看作第二种方式的简写。\n第二种方式中有两个 LoggerService，第一个出现在<code>@Inject(LoggerService)</code>，功能是指定了具体是哪个服务，起到服务标识符的作用。\n第二个出现在<code>private logger2: LoggerService</code>，功能是指定了 logger2 的类型是 LoggerService。</p>\n<p>第三种和第四种方式是一致的，只不过分别是 string 类型和 number 类型而已。但是这里是一定需要使用@Inject 了。因为如果不通过@Inject 来指定是哪个服务，就会导致使用<code>string</code>来作为服务标识符，最终得到 string 的实例，即<code>new String()</code>得到一个空字符串。这显然不是我们想要的。对于 number 类型也是同理，我们会得到数字 0。但是我们使用了@Inject 就不一样了。我们已经指定了这里的服务就是<code>someStringServiceToken</code>，然后就会通过这个 token 找到对应的服务，并且我们也同时指定了 someStringService 的类型是 string。唯一需要注意的是因为我们注入的不是类服务，而是字符串/数字类型的服务，是没有办法提供默认的 provider 的，也就是说我们必须要手动调用 declareProviders 来指定 provider。</p>\n<div><pre><code><span>declareProviders</span><span>(</span><span>[</span>\n  <span>{</span>\n    provide<span>:</span> someStringServiceToken<span>,</span>\n    useValue<span>:</span> <span>\"hello world\"</span>\n  <span>}</span><span>,</span>\n  <span>{</span>\n    provide<span>:</span> someNumberServiceToken<span>,</span>\n    useValue<span>:</span> <span>123456</span>\n  <span>}</span>\n<span>]</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>如果没有明确指定服务，则会直接导致注入服务的过程找不到服务而抛出异常。</p>\n<h3 id=\"通过实例属性注入依赖\"> 通过实例属性注入依赖</h3>\n<div><pre><code><span>import</span> <span>{</span> Injectable<span>,</span> Inject <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n<span>import</span> <span>{</span> LoggerService <span>}</span> <span>from</span> <span>\"./logger.service.ts\"</span><span>;</span>\n\n<span>const</span> someStringServiceToken <span>=</span> <span>\"stringServiceToken\"</span><span>;</span>\n<span>const</span> someNumberServiceToken <span>=</span> <span>\"numberServiceToken\"</span><span>;</span>\n\n<span><span>@</span><span>Injectable</span></span><span>(</span><span>)</span>\n<span>export</span> <span>class</span> <span>CountService</span> <span>{</span>\n  <span>public</span> count <span>=</span> <span>0</span><span>;</span>\n\n  <span><span>@</span><span>Inject</span></span><span>(</span>LoggerService<span>)</span>\n  <span>public</span> logger<span>!</span><span>:</span> LoggerService<span>;</span>\n\n  <span><span>@</span><span>Inject</span></span><span>(</span>someStringServiceToken<span>)</span>\n  <span>public</span> someStringService<span>!</span><span>:</span> <span>string</span><span>;</span>\n\n  <span><span>@</span><span>Inject</span></span><span>(</span>someNumberServiceToken<span>)</span>\n  <span>public</span> someNumberService<span>!</span><span>:</span> <span>number</span><span>;</span>\n\n  <span>public</span> <span>addOne</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>count<span>++</span><span>;</span>\n    <span>this</span><span>.</span>logger<span>.</span><span>log</span><span>(</span><span>\"addOne ==> \"</span><span>,</span> <span>this</span><span>.</span>count<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>这个例子的效果是和上面通过构造函数注入依赖是一致的。有几点需要注意一下。</p>\n<p>第一点：所有待注入的属性都必须明确使用<code>@Inject</code>，比如 count 属性就不是注入属性，那么就不需要使用@Inject 了。</p>\n<p>第二点：@Inject 的参数是必填项，必须手动指定服务标识符。</p>\n<p>第三点：可以给实例属性赋值默认值，但是正常情况下是没有意义的，因为一定会被注入的数据覆盖掉，除非指定了服务是@Optional 的，而且确实没有找到该服务才会使用这个默认值。如果没有指定默认值，那么我们应该使用<code>!:</code>来强制指定该属性是非空的。</p>\n<p>第四点：和上方的构造函数的注入依赖是同样的道理，我们也必须给字符串/数字类型的服务手动声明 provider。</p>\n<h2 id=\"参考文章\"> 参考文章</h2>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/425602814/answer/1536553256\" target=\"_blank\" rel=\"noopener noreferrer\">依赖注入 和 new 一个实例有什么区别吗？</a></li>\n<li><a href=\"https://www.zhihu.com/question/31536981/answer/53082706\" target=\"_blank\" rel=\"noopener noreferrer\">不使用依赖注入到处 new 的优缺点？</a></li>\n<li><a href=\"https://www.zhihu.com/question/441680476/answer/1707567779\" target=\"_blank\" rel=\"noopener noreferrer\">自动注入到底比 new 好在哪？</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/57747179\" target=\"_blank\" rel=\"noopener noreferrer\">为什么我们需要依赖注入？</a></li>\n<li><a href=\"https://www.zhihu.com/question/305800762/answer/552939404\" target=\"_blank\" rel=\"noopener noreferrer\">为什么前端会出现依赖注入这种东西，什么场景下会用到？</a></li>\n</ul>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "基础教程",
      "url": "https://www.kaokei.com/project/use-vue-service/guide/base/",
      "id": "https://www.kaokei.com/project/use-vue-service/guide/base/",
      "content_html": "<h2 id=\"简介\"> 简介</h2>\n<p>本教程介绍最基础的两个 api，通过这两个 api 来大概认识一下怎么使用本库。</p>\n<ul>\n<li>Injectable</li>\n<li>useService</li>\n</ul>\n<h2 id=\"使用步骤\"> 使用步骤</h2>\n<h3 id=\"定义服务\"> 定义服务</h3>\n<div><pre><code><span>import</span> <span>{</span> Injectable <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n\n<span><span>@</span><span>Injectable</span></span><span>(</span><span>)</span>\n<span>export</span> <span>class</span> <span>LoggerService</span> <span>{</span>\n  <span>public</span> <span>log</span><span>(</span><span>...</span>msg<span>:</span> <span>any</span><span>[</span><span>]</span><span>)</span> <span>{</span>\n    <span>console</span><span>.</span><span>log</span><span>(</span><span>\"from logger service ==>\"</span><span>,</span> <span>...</span>msg<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\n<span><span>@</span><span>Injectable</span></span><span>(</span><span>)</span>\n<span>export</span> <span>class</span> <span>CountService</span> <span>{</span>\n  <span>public</span> count <span>=</span> <span>0</span><span>;</span>\n  <span>constructor</span><span>(</span><span>private</span> logger<span>:</span> LoggerService<span>)</span> <span>{</span><span>}</span>\n\n  <span>public</span> <span>addOne</span><span>(</span><span>)</span> <span>{</span>\n    <span>this</span><span>.</span>count<span>++</span><span>;</span>\n    <span>this</span><span>.</span>logger<span>.</span><span>log</span><span>(</span><span>\"addOne ==> \"</span><span>,</span> <span>this</span><span>.</span>count<span>)</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>从上面的代码可以看出来，我们采用类来描述服务。服务就是 typescript 中普通的类，并没有引入新的概念。\n所以这里是非常简单易上手的，只要记住使用<code>@Injectable</code>标记该类是可注入的服务即可。</p>\n<p>另一点需要注意的是注意到上面 LoggerService 是没有依赖的，但是 CountService 是依赖 LoggerService 的。\n因为 LoggerService 出现在 CountService 的构造函数中。最终 CountService 就会有一个 logger 实例属性，且logger 的类型就是 LoggerService。</p>\n<h3 id=\"获取服务\"> 获取服务</h3>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>\n    <span><span><span>&lt;</span>span</span><span>></span></span>{{ countService.count }}<span><span><span>&lt;/</span>span</span><span>></span></span>\n    <span><span><span>&lt;</span>button</span> <span>type</span><span><span>=</span><span>\"</span>button<span>\"</span></span> <span>@click</span><span><span>=</span><span>\"</span>countService.addOne()<span>\"</span></span><span>></span></span>+1<span><span><span>&lt;/</span>button</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n<span><span><span>&lt;</span>script</span> <span>lang</span><span><span>=</span><span>\"</span>ts<span>\"</span></span><span>></span></span><span><span>\n<span>import</span> <span>{</span> defineComponent <span>}</span> <span>from</span> <span>\"vue\"</span><span>;</span>\n<span>import</span> <span>{</span> useService <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n<span>import</span> <span>{</span> CountService <span>}</span> <span>from</span> <span>\"../services/count.service\"</span><span>;</span>\n\n<span>export</span> <span>default</span> <span>defineComponent</span><span>(</span><span>{</span>\n  <span>setup</span><span>(</span><span>)</span> <span>{</span>\n    <span>// 返回的就是CountService类的实例</span>\n    <span>// 并且是reactive的</span>\n    <span>const</span> countService <span>=</span> <span>useService</span><span>(</span>CountService<span>)</span><span>;</span>\n    <span>return</span> <span>{</span>\n      <span>// 可以在模板中直接绑定数据和事件</span>\n      countService\n    <span>}</span><span>;</span>\n  <span>}</span>\n<span>}</span><span>)</span><span>;</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>注意这里是一个 vue 组件的源代码，我们使用 defineComponent 定义组件。很明显最关键的一行代码就是<code>const countService = useService(CountService);</code>。本库提供了一个方法<code>useService</code>，该方法从名字可以看出来是一个 hooks 方法，只能用在<code>setup</code>函数中。</p>\n<p>在这个例子中，我们传入参数<code>CountService</code>，返回一个对象<code>countService</code>，注意 countService 的类型就是 CountService，也就是说 countService 是 CountService 类的一个实例。</p>\n<p>正如上面代码中的注释所说，countService 对象本身是一个 reactive 对象，所以 vue 模版可以直接渲染 countService.count，当 countService.count 变化时，组件也会自动更新。</p>\n<p>到这里为止，聪明的你一定已经发现了很多问题。</p>\n<ul>\n<li>为什么我们不自己 new CountService()，而要通过 useService 获取实例对象？</li>\n<li>useService(CountService) 这里并没有传递 LoggerService，那么这里是如何初始化 LoggerService 的？</li>\n<li>在不同的组件中调用 useService(CountService)，获取到的实例是不是同一个对象？</li>\n</ul>\n<p>这些问题的解答可以<a href=\"./advance.html\">参考这里</a></p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "如何使用类组件",
      "url": "https://www.kaokei.com/project/use-vue-service/guide/component/",
      "id": "https://www.kaokei.com/project/use-vue-service/guide/component/",
      "content_html": "<h2 id=\"简介\"> 简介</h2>\n<p>本教程继续介绍下面这个 api，进而掌握如何使用类组件，以及在类组件中使用依赖注入能力。</p>\n<ul>\n<li>Component</li>\n</ul>\n<p>整体上来说不太推荐使用类组件，但是有些人比较偏爱类组件，所以本库也支持类组件的依赖注入。</p>\n<p>不推荐的原因主要是因为 vue 并不是本身就支持类组件，而是需要借助<code>vue-class-component</code>这个库才能实现支持类组件。虽然这个库也是官方维护的。但毕竟不是原生支持的。</p>\n<p>其实我本身还是比较喜欢类组件的，因为如果整个项目包括服务和组件都是类，整体是比较一致的。只是类组件毕竟不是原生支持的，感觉还是不够顺手。</p>\n<p>不管怎么说，整个项目要不全都用类组件，要不全都用 Option 组件，不要部分组件用类，另一部分组件又用 Option。至少要保持风格统一。</p>\n<h2 id=\"类组件与-option-组件的区别\"> 类组件与 Option 组件的区别</h2>\n<h3 id=\"setup-的不同\"> setup 的不同</h3>\n<p>在 Option 组件中，只有一个 setup 函数，意味着只有一个闭包，我可以在这个闭包内基于已有的数据派生出其他数据。</p>\n<p>但是在类组件中，虽然也可以使用 setup 函数，但是含义已经不一样了，它是对实例属性的延迟初始化的一种方式。</p>\n<p>而且本质也不一样，类组件需要借助<code>vue-class-component</code>库才能使用。而且这里的 setup 也是从 vue-class-component 导入的函数。但是在 Option 组件中，setup 只是组件的一个预定义属性而已。</p>\n<h3 id=\"computed-的不同\"> computed 的不同</h3>\n<p>在 Option 组件中，我们可以在 setup 闭包中使用<code>const computedValue = computed(() =&gt; {})</code>，然后导出这个 computedValue 即可。</p>\n<p>但是在类组件中，我们则是通过定义 getter 函数来实现 computed 属性的功能。</p>\n<h3 id=\"watch-的不同\"> watch 的不同</h3>\n<p>在 Option 组件中，我们可以在 setup 闭包中使用<code>watchEffect()</code>来定义 watch 功能。</p>\n<p>但是在类组件中，这个已经不在类中定义了，只能在装饰器中定义 watch 属性。</p>\n<h3 id=\"类组件转化为-option-组件\"> 类组件转化为 Option 组件</h3>\n<p>通过观察 vue-class-component 的源码，我们可以发现类组件虽然看上去像是一个类，但是最终还是被转换为 Option 组件了。</p>\n<p>而且为了获取类的的实例属性，必须得实例化一次。这意味着类组件的构造函数会被执行两次。所以在 vue 的类组件的构造函数中不能定义有副作用的逻辑，实际上是不建议定义类组件的构造函数的。</p>\n<h2 id=\"使用类组件\"> 使用类组件</h2>\n<p>如何在 vue 中使用类组件的具体官方文档可以<a href=\"https://class-component.vuejs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">参考这里</a>，当然目前这个文档是 vue2.x 的，vue3.x 的文档还没有出来，可以<a href=\"https://github.com/vuejs/vue-class-component/issues\" target=\"_blank\" rel=\"noopener noreferrer\">参考这里</a>。</p>\n<p>本库在<code>vue-class-component@next</code>的基础上新增了一个 api，从而可以实现依赖注入的能力。</p>\n<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>\"</span>container<span>\"</span></span> <span>:style</span><span><span>=</span><span>\"</span>{ background: bgTheme }<span>\"</span></span><span>></span></span>\n    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>\"</span>title<span>\"</span></span><span>></span></span>{{ name || \"defaultName\" }}:<span><span><span>&lt;/</span>span</span><span>></span></span>\n    <span><span><span>&lt;</span>button</span> <span>class</span><span><span>=</span><span>\"</span>decrementBtn<span>\"</span></span> <span>type</span><span><span>=</span><span>\"</span>button<span>\"</span></span> <span>@click</span><span><span>=</span><span>\"</span>counter.decrement<span>\"</span></span><span>></span></span>\n      -\n    <span><span><span>&lt;/</span>button</span><span>></span></span>\n    <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>\"</span>countNum<span>\"</span></span><span>></span></span>{{ counter?.count }}<span><span><span>&lt;/</span>span</span><span>></span></span>\n    <span><span><span>&lt;</span>button</span> <span>class</span><span><span>=</span><span>\"</span>incrementBtn<span>\"</span></span> <span>type</span><span><span>=</span><span>\"</span>button<span>\"</span></span> <span>@click</span><span><span>=</span><span>\"</span>counter.increment<span>\"</span></span><span>></span></span>\n      +\n    <span><span><span>&lt;/</span>button</span><span>></span></span>\n  <span><span><span>&lt;/</span>div</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n\n<span><span><span>&lt;</span>script</span> <span>lang</span><span><span>=</span><span>\"</span>ts<span>\"</span></span><span>></span></span><span><span>\n<span>import</span> <span>{</span> Vue <span>}</span> <span>from</span> <span>\"vue-class-component\"</span><span>;</span>\n\n<span>import</span> <span>{</span> Component<span>,</span> Inject <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n\n<span>import</span> <span>{</span> <span>COUNTER_THEME</span> <span>}</span> <span>from</span> <span>\"@services/service.context.ts\"</span><span>;</span>\n<span>import</span> <span>{</span> SwitchService <span>}</span> <span>from</span> <span>\"@services/switch.service.ts\"</span><span>;</span>\n<span>import</span> <span>{</span> CounterService <span>}</span> <span>from</span> <span>\"@services/counter.service.ts\"</span><span>;</span>\n\n<span>class</span> <span>Props</span> <span>{</span>\n  name<span>?</span><span>:</span> string<span>;</span>\n  bgColor<span>?</span><span>:</span> string<span>;</span>\n<span>}</span>\n\n@<span>Component</span><span>(</span><span>{</span>\n  providers<span>:</span> <span>[</span>\n    <span>{</span>\n      provide<span>:</span> <span>COUNTER_THEME</span><span>,</span>\n      useValue<span>:</span> <span>\"red\"</span>\n    <span>}</span><span>,</span>\n    CounterService\n  <span>]</span>\n<span>}</span><span>)</span>\n<span>export</span> <span>default</span> <span>class</span> <span>Person</span> <span>extends</span> <span>Vue<span>.</span>with</span><span>(</span>Props<span>)</span> <span>{</span>\n  @<span>Inject</span><span>(</span><span>COUNTER_THEME</span><span>)</span>\n  <span>public</span> theme<span>!</span><span>:</span> string<span>;</span>\n\n  @<span>Inject</span><span>(</span>CounterService<span>)</span>\n  <span>public</span> counter<span>!</span><span>:</span> CounterService<span>;</span>\n\n  @<span>Inject</span><span>(</span>SwitchService<span>)</span>\n  <span>public</span> switchService<span>!</span><span>:</span> SwitchService<span>;</span>\n\n  <span>public</span> <span>get</span> <span>bgTheme</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>this</span><span>.</span>switchService<span>.</span>counterStatus <span>===</span> <span>1</span><span>)</span> <span>{</span>\n      <span>return</span> <span>this</span><span>.</span>bgColor <span>||</span> <span>this</span><span>.</span>theme<span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>return</span> <span>\"transparent\"</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n<span>}</span>\n</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><p>这份示例代码中有很多可以说一说的地方。</p>\n<p>第一点：<code>export default class Person extends Vue.with(Props)</code>这行代码是<code>vue-class-component</code>规定的模板代码，并不是本库的要求。</p>\n<p>第二点：虽然 Person 是一个组件，但是整体上来看也可以理解为一个服务，可以利用<code>@Inject</code>注入其他的服务。需要特别注意的地方时，在普通服务中，我们可以在类的构造函数中声明依赖，但是在类组件中则不能通过构造函数声明依赖。只能通过实例属性来声明依赖。这是因为 vue 类组件的构造函数已经定义好了参数<code>constructor(props: Record&lt;string, any&gt;, ctx: SetupContext)</code>。而且由于类组件在转化为 Option 组件的时候，实际上会调用两次构造函数，所以是不建议在类组件的构造函数中增加其他逻辑的。</p>\n<p>第三点：定义了 bgTheme 这个 getter 函数，其功能相当于 vue 中的 computed 属性。</p>\n<p>第四点：也是最重要的一点，使用<code>@Component()</code>这个装饰器来定义类组件。这里有一个取巧的地方，就是在 vue-class-component@7.x 及之前的版本中，都是采用的<code>@Component()</code>这个装饰器定义类组件的，但是在 vue-class-component@8.x 中，已经改为<code>@Options()</code>来定义类组件了。所以本库正好可以占用<code>@Component</code>这个 API。本库提供的<code>@Component</code>与 vue-class-component@8.x 提供的<code>@Options</code>的区别主要有两点：</p>\n<ul>\n<li>\n<p>@Options 支持的参数，@Component 都是支持的。而且额外支持了 providers 这个参数，这个参数可以代替 declareProviders 函数。</p>\n</li>\n<li>\n<p>@Component 是对@Options 的封装，同时支持了依赖注入的能力。</p>\n</li>\n</ul>\n<h2 id=\"参考文章\"> 参考文章</h2>\n<ul>\n<li><a href=\"https://class-component.vuejs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Vue Class Component 官网</a></li>\n</ul>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "使用指南",
      "url": "https://www.kaokei.com/project/use-vue-service/guide/",
      "id": "https://www.kaokei.com/project/use-vue-service/guide/",
      "content_html": "<h2 id=\"简介\"> 简介</h2>\n<p>本库基于 vue3.x 的 reactive 特性，借鉴了 angular 的 service 的实现机制，在 vue 环境中实现了基于服务的依赖注入，可以替代 vuex 更加方便的管理数据。</p>\n<h2 id=\"快速搭建项目\"> 快速搭建项目</h2>\n<ol>\n<li>建议使用<code>@vue/cli</code>来初始化项目。</li>\n</ol>\n<div><pre><code><span>npm</span> <span>install</span> -g @vue/cli\nvue create projectName\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><strong>注意</strong>：手动选择 vue 版本 vue3 以及 typescript 选项，取消 vuex 选项，我们不再需要 vuex。</p>\n<ol start=\"2\">\n<li>在 tsconfig.json 文件中新增以下两行</li>\n</ol>\n<div><pre><code><span>\"experimentalDecorators\"</span><span>:</span> <span>true</span><span>,</span>\n<span>\"emitDecoratorMetadata\"</span><span>:</span> <span>true</span><span>,</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><ol start=\"3\">\n<li>安装 npm 包</li>\n</ol>\n<div><pre><code><span>npm</span> <span>install</span> -S reflect-metadata @kaokei/use-vue-service\n</code></pre>\n<div><span>1</span><br></div></div><p>如果还没有安装 vue-class-component</p>\n<div><pre><code><span>npm</span> <span>install</span> -S vue-class-component@next\n</code></pre>\n<div><span>1</span><br></div></div><p>本库的定位是一个轻量级的依赖注入实现，它并不是一个框架。而且对项目的侵入性比较小。本库所有的依赖包括：</p>\n<ul>\n<li>typescript：依赖装饰器特性\n<ul>\n<li>需要 tsc 编译器，而不能是 esbuild 编译器</li>\n<li>需要开启实验特性</li>\n</ul>\n</li>\n<li>vue3.x：依赖 provide/inject/reactive 等特性</li>\n<li>reflect-metadata：获取类型信息</li>\n<li>vue-class-component：支持类组件</li>\n</ul>\n<ol start=\"4\">\n<li>定义服务</li>\n</ol>\n<p>接下来就是开始写代码了，第一步就是定义服务，我们采用类来定义服务，并使用<code>@Injectable()</code>来表明服务可注入。</p>\n<p><strong>注意</strong>：后续文章有介绍如何定义服务</p>\n<ol start=\"5\">\n<li>组织服务</li>\n</ol>\n<p>第二步是组织这些定义好的服务，所谓组织服务其实就是定义这些服务的作用域。组织方式参考了 angular 的实现方式。</p>\n<p><strong>注意</strong>：后续文章有介绍如何组织服务</p>\n<ol start=\"6\">\n<li>使用服务</li>\n</ol>\n<p>第三步就是通过 api 获取服务实例，拿到服务实例后，就能读取服务的状态以及调用服务的方法更新服务的状态。</p>\n<p>这里再回顾一下我们定义服务的时候采用的是类的形式。服务的实例就是类的实例。所以服务的状态就是类的实例的属性，所以可以调用类的实例的方法更新属性。\n同时服务已经被<code>reactive</code>处理过，vue 模版可以直接渲染服务的状态。当服务的状态变化时，vue 模版也会自动更新。</p>\n<div><pre><code><span>import</span> <span>{</span> useService <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n<span>import</span> <span>{</span> SomeService <span>}</span> <span>from</span> <span>\"./some.service.ts\"</span><span>;</span>\n\n<span>const</span> someService <span>=</span> <span>useService</span><span>(</span>SomeService<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>\n  <span><span><span>&lt;</span>div</span><span>></span></span>{{ someService.name }}: {{ someService.age }}<span><span><span>&lt;/</span>div</span><span>></span></span>\n  <span><span><span>&lt;</span>button</span> <span>type</span><span><span>=</span><span>\"</span>button<span>\"</span></span> <span>@click</span><span><span>=</span><span>\"</span>someService.agePlusOne<span>\"</span></span><span>></span></span>年龄+1<span><span><span>&lt;/</span>button</span><span>></span></span>\n<span><span><span>&lt;/</span>template</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"注意\"> 注意</h2>\n<p>虽然 vue 官网比较推荐使用 vite 搭建项目，但是这里暂时还不能使用 vite 搭建项目。</p>\n<p>因为 vite 使用的是 esbuild 而不是 tsc 编译 ts 代码。而 esbuild 暂时还不支持装饰器特性，本库最大的特点就是依赖注入，它是通过装饰器来实现的。</p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "@kaokei/use-vue-service",
      "url": "https://www.kaokei.com/project/use-vue-service/",
      "id": "https://www.kaokei.com/project/use-vue-service/",
      "content_html": "<h2 id=\"安装\"> 安装</h2>\n<div><pre><code><span>npm</span> <span>install</span> -S reflect-metadata @kaokei/use-vue-service\n</code></pre>\n<div><span>1</span><br></div></div><h2 id=\"示例代码\"> 示例代码</h2>\n<div><pre><code><span>import</span> <span>{</span> useService <span>}</span> <span>from</span> <span>\"@kaokei/use-vue-service\"</span><span>;</span>\n<span>import</span> <span>{</span> SomeService <span>}</span> <span>from</span> <span>\"./some.service.ts\"</span><span>;</span>\n\n<span>const</span> someService <span>=</span> <span>useService</span><span>(</span>SomeService<span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "博客主页",
      "url": "https://www.kaokei.com/",
      "id": "https://www.kaokei.com/",
      "content_html": "<p>这是一个博客主页。</p>\n<p>要使用此布局，您应该在页面前端设置 <code>blog: true</code> 和 <code>home: true</code>。</p>\n<p>相关配置文档请见 <a href=\"https://vuepress-theme-hope.github.io/zh/guide/blog/home/\" target=\"_blank\" rel=\"noopener noreferrer\">博客主页</a></p>\n<p>ICP 证：<a href=\"https://beian.miit.gov.cn/\" target=\"_blank\">京 ICP 备 16051049 号-2</a></p>\n",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    },
    {
      "title": "幻灯片页",
      "url": "https://www.kaokei.com/slides/",
      "id": "https://www.kaokei.com/slides/",
      "content_html": "\n<i>Not supported content</i>",
      "image": "https://www.kaokei.com/logo.svg",
      "date_published": "2021-12-05T12:49:29.000Z",
      "date_modified": "2021-12-05T12:49:29.000Z",
      "authors": [
        {
          "name": "kaokei"
        }
      ],
      "tags": []
    }
  ]
}