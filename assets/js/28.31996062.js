(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{495:function(t,e,v){"use strict";v.r(e);var a=v(20),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"组件间通信方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组件间通信方式"}},[t._v("#")]),t._v(" 组件间通信方式")]),t._v(" "),v("h2",{attrs:{id:"父子组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#父子组件"}},[t._v("#")]),t._v(" 父子组件")]),t._v(" "),v("p",[t._v("父组件通过 props 传递数据给子组件\n父组件监听子组件 emit 出来的事件，接受子组件的数据")]),t._v(" "),v("p",[v("strong",[t._v("注意点一")]),t._v("\n父组件不仅仅可以传递数据给子组件，也可以传递函数给子组件，然后在子组件中调用该函数，从而修改父组件中的数据。这种方式也是可以的，而且这也是 react 中的常规操作。")]),t._v(" "),v("p",[v("strong",[t._v("注意点二")]),t._v("\n子组件 emit 事件，如果是自定义事件，那么只会传递给父组件。父组件的父组件是接受不到该事件的。但是如果是原生事件，那么就能接收到。")]),t._v(" "),v("h2",{attrs:{id:"爷孙组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#爷孙组件"}},[t._v("#")]),t._v(" 爷孙组件")]),t._v(" "),v("p",[t._v("注意这里的爷孙并不是特指爷爷和孙子，而是指那些组件层级大于等于 2 层的组件。")]),t._v(" "),v("p",[t._v("对于这种组件关系，我们仍然可以通过 props 一层层地去传递数据到最底层组件，也可以通过一层层的 emit 事件传递到最顶层组件。")]),t._v(" "),v("p",[t._v("但是这显然加大了工作量，而且不利于代码维护。")]),t._v(" "),v("h2",{attrs:{id:"兄弟组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#兄弟组件"}},[t._v("#")]),t._v(" 兄弟组件")]),t._v(" "),v("p",[t._v("通常需要考虑把兄弟组件都需要的数据提升到最近的公共父组件中，这样每个兄弟组件都只需要和父组件进行沟通即可，即通过 props 和 emit 来转化为爷孙组件/父子组件的通信方式。这样只要父组件中的数据变化了，那么两个兄弟组件都会得到更新。")]),t._v(" "),v("p",[t._v("还有一种场景，就是 A 组件 emit 事件到父组件中，父组件监听该事件，然后通过 ref 直接调用 B 组件中的方法。反过来也可以实现 B 组件触发 A 组件中的方法。")]),t._v(" "),v("h2",{attrs:{id:"事件总线"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件总线"}},[t._v("#")]),t._v(" 事件总线")]),t._v(" "),v("p",[t._v("还有一种方式则是通过公共事件总线来传递消息。"),v("code",[t._v("const bus = new Vue();")]),t._v("\n在任意组件中可以")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("bus.$on('eventName', eventHandler);\nbus.$emit('eventName');\n")])])]),v("p",[t._v("这是一种功能非常强大的手段，可以做到整个页面中任意组件之间的通信，但是同时也是非常糟糕的一种设计。因为我们只能通过全局搜索才能找到哪些组件会触发事件，哪些组件会接受事件。")]),t._v(" "),v("h2",{attrs:{id:"redux-or-vuex"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redux-or-vuex"}},[t._v("#")]),t._v(" redux or vuex")]),t._v(" "),v("p",[t._v("redux 和 vuex 都是全局唯一数据源。然后通过 dispatch 一个字符串来更新数据。")]),t._v(" "),v("p",[t._v("和事件总线一样，通过字符串来触发更新逻辑对于开发来说是非常效率低下的。")]),t._v(" "),v("p",[t._v("但是相对于事件总线来说要友好一些，主要是因为 dispatch 之后的逻辑非常明确，就是修改 store 中的数据。至于有哪些组件依赖了 store 中的数据则不是我们需要关心的。但是事件总线方案中，我们是需要时刻关心有哪些组件中订阅了某个事件的，至少需要保证事件不重名，否则就乱套了。")]),t._v(" "),v("h2",{attrs:{id:"本库的实现方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#本库的实现方式"}},[t._v("#")]),t._v(" 本库的实现方式")]),t._v(" "),v("p",[t._v("考虑 props 和 emit 的本质其实是把数据和方法分割开了。那么本库的实现方式正好与此相反。")]),t._v(" "),v("p",[t._v("我们把数据和方法集合到一起变成一个对象，我们称之为服务。然后通过 provide/inject 的技术，可以方便的在任意组件中获取这个服务。只要我们获取到这个对象，我们可以在模版中渲染这个对象的数据，我们可以直接调用这个对象的方法。")]),t._v(" "),v("p",[t._v("因为这个对象本身就是 reactive 的，所以只要数据变化了，所有依赖这个服务的组件都会自动更新。")]),t._v(" "),v("p",[t._v("由于是通过 provide/inject 来获取的服务，所以是可以跨越多个组件层级直接获取服务对象的。")]),t._v(" "),v("p",[t._v("因为服务对象是一个类的实例，所以数据类型是非常明确的，避免了上述"),v("code",[t._v("字符串")]),t._v("丢失类型的问题。")]),t._v(" "),v("p",[t._v("我们还可以控制 provide 的位置，去控制服务对象的范围。因为服务是和组件关联的，当组件销毁的时候，服务也会跟着销毁，间接控制了服务的生命周期。")]),t._v(" "),v("p",[t._v("虽然本库功能很强大，但是不意味着在整个项目中全部使用它，实际上本库还是比较适合那些容器组件。而对于那些受控组件则还是建议使用 props/emit 技术。")])])}),[],!1,null,null,null);e.default=r.exports}}]);