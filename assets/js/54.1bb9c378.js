(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{531:function(e,t,v){"use strict";v.r(t);var a=v(20),_=Object(a.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[e._v("如果是官方的 npm 仓库，可以直接使用 npm.io 提供的 api。")]),e._v(" "),v("p",[e._v("这里研究的是私有仓库，是通过 Verdaccio 搭建的。")]),e._v(" "),v("p",[e._v("首先能想到的是通过命令行来获取相关数据。")]),e._v(" "),v("div",{staticClass:"language-bash extra-class"},[v("pre",{pre:!0,attrs:{class:"language-bash"}},[v("code",[v("span",{pre:!0,attrs:{class:"token function"}},[e._v("npm")]),e._v(" view @someScope/packageName versions --json\n")])])]),v("p",[e._v("但是不太喜欢命令行这种方式，猜测应该是存在相应的 rest api。最终发现是这个 API。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("https://private.registry.com/@someScope/packageName\n")])])]),v("p",[e._v("当然对于私有包，需要设置 token 来获取数据，注意这里的 token 并不是我们在仓库的官方网站登录后产生的 token。而是在命令行中"),v("code",[e._v("npm login")]),e._v("之后产生的 token，会存储在~/.npmrc 文件中。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("需要设置https header\nauthorization: 'Bearer abcdefg123123123123123123123123123'\n")])])]),v("p",[e._v("以上拿就是最终的结论，下面再记录一下调查过程。")]),e._v(" "),v("p",[e._v("首先我想到的是抓包来看看当我执行 npm view 命令时，到底发送了什么 api 请求，这样不就立即搞定了吗？")]),e._v(" "),v("p",[e._v("以前了解到的抓包都是代理抓包，但是我不知道怎么设置终端的代理。")]),e._v(" "),v("p",[e._v("后来调研到可以使用 httpry，ngrep，wireshark。但是都有一个问题就是不能分析 https 的包，就连请求的 URL 都看不见。本来以为不看数据体也行，至少要能看看请求头。最终抓包这个方案行不通。")]),e._v(" "),v("p",[e._v("没有办法，只能去看 npm view 的源代码。分析如下：")]),e._v(" "),v("p",[e._v("npm 源代码仓库是"),v("a",{attrs:{href:"https://github.com/npm/cli",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),v("OutboundLink")],1),e._v("。")]),e._v(" "),v("p",[v("code",[e._v("npm view")]),e._v("文件再"),v("code",[e._v("lib/commands/view.js")]),e._v("，猜测应该是执行的"),v("code",[e._v("exec")]),e._v("方法，然后调用的是"),v("code",[e._v("getData")]),e._v("方法，然后关键的是"),v("code",[e._v("packument")]),e._v("方法。")]),e._v(" "),v("p",[e._v("注意到 packument 来源于"),v("code",[e._v("pacote")]),e._v("这个 npm 包，所以下载它的"),v("a",{attrs:{href:"https://github.com/npm/pacote",target:"_blank",rel:"noopener noreferrer"}},[e._v("源代码"),v("OutboundLink")],1),e._v("。")]),e._v(" "),v("p",[e._v("查看 pacote 的入口文件 index.js，其中 packument 方法依赖 get 方法，get 方法来源"),v("code",[e._v("fetcher.js")]),e._v("文件。")]),e._v(" "),v("p",[e._v("fetcher.js 文件中猜测应该走的是"),v("code",[e._v("RegistryFetcher")]),e._v("这个分支。然后看"),v("code",[e._v("registry.js")]),e._v("这个文件。终于找到了我们需要的"),v("code",[e._v("packument")]),e._v("方法，我们可以在这里打印"),v("code",[e._v("this.packumentUrl")]),e._v("，就能知道实际访问的 api 接口了。")]),e._v(" "),v("p",[e._v("继续观察到其中"),v("code",[e._v("packument")]),e._v("方法依赖"),v("code",[e._v("fetch")]),e._v("方法，本以为这个 fetch 方法就是常用的 fetch 方法，后来发现居然是专用的一个 npm 包"),v("code",[e._v("npm-registry-fetch")]),e._v("。")]),e._v(" "),v("p",[e._v("同样的下载"),v("a",{attrs:{href:"https://github.com/npm/npm-registry-fetch",target:"_blank",rel:"noopener noreferrer"}},[e._v("npm-registry-fetch"),v("OutboundLink")],1),e._v("，这里就是一个默认导出，主要是注意到其中的"),v("code",[e._v("pickRegistry")]),e._v("和"),v("code",[e._v("getHeaders")]),e._v("。")]),e._v(" "),v("p",[e._v("分析这两个方法并打印日志，就可以观察到实际使用的是"),v("code",[e._v("~/.npmrc")]),e._v("文件中的 token 作为授权 token，需要注意增加"),v("code",[e._v("Bearer\b")]),e._v("前缀。")])])}),[],!1,null,null,null);t.default=_.exports}}]);