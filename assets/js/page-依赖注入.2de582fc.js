(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{574:function(t,s,a){"use strict";a.r(s);var n=a(1),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"什么是依赖注入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是依赖注入"}},[t._v("#")]),t._v(" 什么是依赖注入")]),t._v(" "),a("p",[t._v("关于依赖注入的概念可以参考 Angular 的文档，"),a("a",{attrs:{href:"https://angular.cn/guide/dependency-injection",target:"_blank",rel:"noopener noreferrer"}},[t._v("Angular 中的依赖注入"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("p",[t._v("首先不得不提到的一点是什么是依赖注入，我在网上搜索了很多文章，专业术语也有很多，看的我迷迷糊糊的。我尝试记录一下我自己的理解。")]),t._v(" "),a("p",[t._v("首先从名字入手，依赖注入可以分成依赖和注入。")]),t._v(" "),a("h4",{attrs:{id:"什么是依赖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是依赖"}},[t._v("#")]),t._v(" 什么是依赖？")]),t._v(" "),a("p",[t._v("在讨论依赖之前，必须先了解什么是服务，不考虑边界情况下，可以把服务理解为数据和方法的集合，即一个对象既包含数据又包含方法就可以称为为服务。")]),t._v(" "),a("p",[t._v("一般我们会通过实例化一个类来得到这个对象。我们可以想象的到这个类的某个实例属性有可能又是另一个类的实例对象。这个过程可以一直进行下去。比如这样的依赖关系图：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("A --\x3e B、C、D\nB --\x3e C、D\nC --\x3e D、E\nD --\x3e E、F\nE --\x3e F\nF 没有依赖\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("上面的依赖图代表 A 这个类有三个实例属性"),a("code",[t._v("b、c、d")]),t._v("分别是"),a("code",[t._v("B、C、D")]),t._v("这三个类的实例对象。意味着"),a("code",[t._v("A")]),t._v("类是依赖"),a("code",[t._v("B、C、D")]),t._v("这 3 个类的。\n而"),a("code",[t._v("B")]),t._v("类又是依赖"),a("code",[t._v("C、D")]),t._v("这两个类的。依次类推我们可以知道"),a("code",[t._v("C、D、E")]),t._v("这三个类的依赖，注意到"),a("code",[t._v("F")]),t._v("类是没有依赖的。")]),t._v(" "),a("p",[t._v("具体从类的角度来讲，可以在 2 个地方来描述这种依赖关系。\n第 1 个地方是在实例属性上声明该属性是另一个类的实例。\n第 2 个地方就是在类的构造函数中声明参数是某个类的实例属性。\n示例代码如下：")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" Injectable "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"@kaokei/use-vue-service"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token decorator"}},[a("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Injectable")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("LoggerService")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("msg"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"from logger service ==>"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("msg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token decorator"}},[a("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Injectable")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CountService")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" count "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 该属性是普通属性，不是依赖")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token decorator"}},[a("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Inject")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("LoggerService"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" logger"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" LoggerService"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 该属性是依赖")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" logger2"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" LoggerService "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 该参数是依赖")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addOne")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("logger"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"from logger addOne ==> "')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("logger2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"from logger2 addOne ==> "')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br"),a("span",{staticClass:"line-number"},[t._v("17")]),a("br"),a("span",{staticClass:"line-number"},[t._v("18")]),a("br"),a("span",{staticClass:"line-number"},[t._v("19")]),a("br"),a("span",{staticClass:"line-number"},[t._v("20")]),a("br"),a("span",{staticClass:"line-number"},[t._v("21")]),a("br"),a("span",{staticClass:"line-number"},[t._v("22")]),a("br"),a("span",{staticClass:"line-number"},[t._v("23")]),a("br"),a("span",{staticClass:"line-number"},[t._v("24")]),a("br"),a("span",{staticClass:"line-number"},[t._v("25")]),a("br"),a("span",{staticClass:"line-number"},[t._v("26")]),a("br")])]),a("h4",{attrs:{id:"什么是注入呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是注入呢"}},[t._v("#")]),t._v(" 什么是注入呢？")]),t._v(" "),a("p",[t._v("在谈论注入之前，我们先来看看，如果没有依赖注入框架，我们怎么实例化 CountService 呢？")]),t._v(" "),a("p",[t._v("显然在我们调用构造函数之前，我们需要提前准备好参数。即"),a("code",[t._v("const logger = new LoggerService();")]),t._v("。")]),t._v(" "),a("p",[t._v("然后就可以调用构造函数了，"),a("code",[t._v("const countService = new CountService(logger);")]),t._v("。此时我们就完成了 CountService 的实例化。")]),t._v(" "),a("p",[t._v("但是似乎还有一个缺陷，就是现在这个实例仍然缺少一个实例属性"),a("code",[t._v("logger")]),t._v("。最简单的解决办法就是"),a("code",[t._v("countService.logger = logger;")]),t._v("。")]),t._v(" "),a("p",[t._v("这样我们终于完成了全部的实例化过程。注意到这里我们复用了"),a("code",[t._v("logger")]),t._v("对象。即 logger 属性和 logger2 属性指向了同一个对象。")]),t._v(" "),a("p",[t._v("这个例子只是演示实例化过程。实际业务中应该很少会有两个属性指向同一个对象。")]),t._v(" "),a("p",[t._v("其实无意中我们已经介绍了两种注入服务的方式的手动实现版本，即"),a("code",[t._v("构造函数参数注入")]),t._v("和"),a("code",[t._v("属性注入")]),t._v("。")]),t._v(" "),a("p",[t._v("这里再顺嘴提一句还存在另一种注入方式，就是"),a("code",[t._v("setter注入")]),t._v("，简单介绍就是在类中定义一个方法，在方法内设置属性值。然后再调用该方法。类似这样："),a("code",[t._v("countService.setLogger(logger);")]),t._v("。在有些依赖注入框架中优先建议使用"),a("code",[t._v("setter注入")]),t._v("，而不建议使用"),a("code",[t._v("属性注入")]),t._v("。不过本库只是实现了"),a("code",[t._v("属性注入")]),t._v("，而不支持"),a("code",[t._v("setter注入")]),t._v("。")]),t._v(" "),a("p",[t._v("书归正传，上面详细介绍了"),a("code",[t._v("依赖注入")]),t._v("的手动实现过程。那么依赖注入框架的作用就是把上面的过程自动化。")]),t._v(" "),a("p",[t._v("通过依赖注入框架，我们可以这样来获取 countService 实例对象。")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" countService "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("useService")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("CountService"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("和上面的手动的实例化过程对比，是不是发现这样写的代码就简单多了，这就是依赖注入框架的魅力，实际上依赖关系越复杂，依赖注入框架的优势就越明显。")]),t._v(" "),a("p",[t._v("这里再多嘴说一句，从上面的分析来看，useService 这个函数是用来获取实例的，但却不一定是必须的。")]),t._v(" "),a("p",[t._v("比如在 angular 中，就不需要这样一个函数来获取实例。因为 angular 应用中组件的形式只能是类，在这个组件类中就可以直接使用@Inject 来注入服务了。")]),t._v(" "),a("p",[t._v("但是在 Vue 中，Vue 组件的形式有两种，一种是类组件，这种情况我们也可以不使用 useService，可以直接使用@Inject 来注入服务；另一种情况则是 Option 组件，因为 Option 组件不是类，所以不能使用装饰器。只能使用 useService 这种类似 hooks 的方法类获取实例对象。")]),t._v(" "),a("p",[t._v("我的总结是依赖注入实在没有什么技术含量，也没有什么高大上的地方。不要被陌生的技术名词给吓到了。\n本质上就是 Key-Value 的魔法。比如：")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("defineKeyValue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"tokenA"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"valueA"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 内部使用map来记录对应关系")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getValueByKey")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"tokenA"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 再通过map.get(key)获取数据即可")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("可以说这就是最简单的依赖注入的简单实现。但是它实在是太简单了，处理的场景有限，所以价值不大。至少要再加上类的实例化能力。")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("defineKeyValue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"tokenA"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ClassA"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 内部使用map来记录对应关系")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getValueByKey")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"tokenA"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 再通过map.get(key)获取到ClassA，然后实例化一个实例返回")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("当然如果要处理 ClassA 依赖 ClassB 这种场景，就需要其他方面的支持。比如 typescript 以及 decorator。因为这属于技术问题，不属于概念问题，这里不再细述。")]),t._v(" "),a("p",[t._v("现在我们这个简易的依赖注入库实现了两种能力，如果判断是类，则去实例化；否值直接返回。我们可以沿着这个思路继续添加新能力。比如如果是普通函数，那么就当作普通函数来执行，然后把这个函数的返回值当作服务返回，这样我们就有三种能力了。")]),t._v(" "),a("p",[t._v("主要是介绍这种扩展的思路，只要有这种扩展的思路，我们就可以继续扩展更多的能力，无非就是添加一个"),a("code",[t._v("if-else")]),t._v("分支的事情。")]),t._v(" "),a("p",[t._v("排除掉这种扩展思路本身，我们的依赖注入框架还有什么局限性吗？")]),t._v(" "),a("p",[t._v("其实还有命名空间单一的问题。显然上面所有的数据都处于同一个全局命名空间下。因为"),a("code",[t._v("defineKeyValue")]),t._v("和"),a("code",[t._v("getValueByKey")]),t._v("是一个全局函数。那么所有的配置信息就只有一份。这种状况在大多数场景应该也没有什么问题。但是确实还可以继续提升一下。")]),t._v(" "),a("p",[t._v("我们需要继续引入一个新的概念，就是"),a("code",[t._v("Injector")]),t._v("。通过下面的伪代码我们可以快速了解什么是 Injector。")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" parentInjector "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Injector")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" childInjector "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Injector")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nchildInjector"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("parent "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" parentInjector"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nparentInjector"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("defineKeyValue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"tokenA"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ClassA"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nchildInjector"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("defineKeyValue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"tokenB"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ClassB"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 注意到childInjector中并没有定义tokenA，但是仍然可以获取到服务实例")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" serviceA "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" childInjector"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getValueByKey")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"tokenA"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" serviceB "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" childInjector"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getValueByKey")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"tokenB"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br")])]),a("p",[t._v("从以上伪代码中可以看出，之所以引入 Injector 这个概念主要是为了避免只有全局一份配置信息。我们可以做到每次实例化一个 Injector 对象，这个 Injector 对象就具有依赖注入的能力；除此之外我们还可以给 Injector 对象增加一个 parent 属性，从而可以把 Injector 对象关联起来，如果当前 Injector 对象中找不到某个服务，就会从其 parent Injector 对象中寻找服务，直到根 Injector 为空。")]),t._v(" "),a("p",[t._v("以上是从依赖注入框架的角度来思考的，和具体业务是无关的。考虑到在前端的场景下，应该怎样去结合呢？")]),t._v(" "),a("p",[t._v("本库参考 angular 把 Injector 绑定在组件上，默认根 Injector 是绑定在根组件上，可以理解为公共的全局的命名空间。")]),t._v(" "),a("p",[t._v("如果在业务上认为某个数据和某个组件是绑定的，就需要用到 "),a("code",[t._v("declareProviders([CountService])")]),t._v("。这行代码意味着当前组件会关联一个 Injector，并且配置了一个 CountService 服务。同时也意味着，在当前组件及其子孙组件中调用 useService 时，一定会从这个 Injector 中获取到 CountService 服务实例（前提是子孙组件不再定义同样的服务"),a("code",[t._v("declareProviders([CountService])")]),t._v("）。")]),t._v(" "),a("p",[t._v("这种寻找机制和原型链寻找属性的机制非常相似，也就是底层的命名空间中的同名属性会覆盖上层命名空间的同名属性。")]),t._v(" "),a("h2",{attrs:{id:"依赖注入-vs-import-export"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖注入-vs-import-export"}},[t._v("#")]),t._v(" 依赖注入 vs import/export")]),t._v(" "),a("ol",[a("li",[t._v("import/export 适合单例")]),t._v(" "),a("li",[t._v("import/export 强制依赖某个实例/具体的数据，不存在干预服务创建过程的可能性。")]),t._v(" "),a("li",[t._v("依赖注入解藕了依赖声明和依赖的实例化。比如声明依赖 LoggerService，但是可以通过配置修改为 OtherLoggerService 的实例")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.zhihu.com/question/391394082/answer/1188254737",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue3 跨组件共享数据，为何要用 provide/inject？直接 export/import 数据行吗？"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.zhihu.com/question/374161373/answer/1034772082",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端什么时候用 import 什么时候用依赖注入?"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"图解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图解"}},[t._v("#")]),t._v(" 图解")]),t._v(" "),a("p",[t._v("通过图片中不同的颜色可以区分出 declareProviders 划分出来不同的命名空间，这也是本库的 logo 的来源。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/assets/image/project/demo.png",alt:"hello logo"}})]),t._v(" "),a("h2",{attrs:{id:"什么是-provider"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-provider"}},[t._v("#")]),t._v(" 什么是 provider")]),t._v(" "),a("p",[t._v("因为本库的依赖注入的思想是来自于 angular，所以大家可以直接查看"),a("a",{attrs:{href:"https://angular.cn/guide/dependency-injection-providers#using-an-injectiontoken-object",target:"_blank",rel:"noopener noreferrer"}},[t._v("angular 的官方文档"),a("OutboundLink")],1),t._v("。这里我再说说我的理解。")]),t._v(" "),a("p",[t._v("provider 字面意思就是提供者，这里具体一点就是服务的提供者。提到服务，我们必须了解两个概念：服务名字和服务来源。最常见的 provider 如下：")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  provide"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" AppleService"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这是服务名字")]),t._v("\n  useClass"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" AppleService"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这是服务来源")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("服务提供者是用来解决一个问题：服务是怎么来的？")]),t._v(" "),a("p",[t._v("最简单的场景就是配置的是什么，就把这个当作服务。还可以实例化一个类来当作服务，还可以执行某个函数，把返回值当作服务。这些在上面已经介绍过了。")]),t._v(" "),a("p",[t._v("总结起来就是 provider 是一种规范，从 provider 中我们可以获取服务标识符、服务创建机制、创建服务所需要的东西。")]),t._v(" "),a("p",[t._v("服务标识符意味着当我们获取服务时需要提供的标识符。")]),t._v(" "),a("p",[t._v("服务创建机制也是必须的，因为我们可能是没有办法只从服务标识符中推导出如何创建一个服务的，比如我们没有办法准确区分一个类和一个普通函数，也就没有办法知道怎么去创建这个服务，是应该 new 这个函数，还是直接调用这个函数。")]),t._v(" "),a("p",[t._v("当我们指定"),a("code",[t._v("useClass")]),t._v("时，显然是想要通过类的实例化来创建一个服务，虽然我们可以直接把服务标识符来当作类来使用，但是我们仍然支持"),a("code",[t._v("useClass:AnotherService")]),t._v("，从而达到实际提供服务的类和服务标识符的类的解耦。")])])}),[],!1,null,null,null);s.default=e.exports},578:function(t,s,a){"use strict";a.r(s);var n=a(1),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"doux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#doux"}},[t._v("#")]),t._v(" doux")]),t._v(" "),a("p",[t._v("该库似乎已经被删除了，但是历史代码还存在，代码实现比较简单，非常方便入门分析。")]),t._v(" "),a("p",[t._v("observable 相当于 reactive\nobserve 相当于 watch\nobserver 相当于 watchEffect")]),t._v(" "),a("p",[t._v("其实 observable 和另外两个是比较独立的，可以独立分析。")]),t._v(" "),a("p",[t._v("observable 在 get/ownKeys/has 三个方法中会调用 track 方法来收集依赖。在 set/deleteProperty 这个两个方法中会调用 trigger 方法来触发副作用。")]),t._v(" "),a("p",[t._v("对比 track 和 trigger 的参数部分，主要是通过 target+key 这两个参数作为链接的桥梁。简单的理解为在 track 时，把 activeEffect 存储到 target+key 对应的 map 中，当 trigger 发生时就可以通过 target+key 来获取曾经保存的 activeEffect，然后执行它。关键点在于 activeEffect 是一个运行时产生的，observable 本身是不依赖它的。")]),t._v(" "),a("p",[t._v("提到 activeEffect，它是怎么产生的呢？其实就是由 observe 产生的。observe 的返回值就是 effect。\n其中这段代码说明了 activeEffect 是怎么产生的：")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[t._v("effectStack"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("effect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nactiveEffect "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" effect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Reflect")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("apply")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ctx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" args"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("其中"),a("code",[t._v("fn")]),t._v("就是我们想要观察的代码，想要收集依赖的代码。所以在执行该代码之前，我们提前准备好 activeEffect。")]),t._v(" "),a("p",[t._v("observer 主要是实现了对组件的观察，主要是判断 effect 是否有 cb 属性。")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[t._v("effects"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("forEach")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Effect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isFn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("cb"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("cb")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("e")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("h2",{attrs:{id:"dob"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dob"}},[t._v("#")]),t._v(" dob")]),t._v(" "),a("p",[t._v("首先查看最简单的例子。")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" observable"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" observe "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"dob"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" obj "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("observable")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("observe")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("debugger")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"obj.a has changed to"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <· obj.a has changed to 1")]),t._v("\n\nobj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <· obj.a has changed to 2")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br")])]),a("p",[t._v("首先 observable 会把一个普通对象转变为 Proxy 对象。主要是 get/set/deleteProperty 这三个属性。这种转变只是为了后续作服务的。")]),t._v(" "),a("p",[t._v("当执行 observe 函数时，类似于 vue-next 中的 watchEffect，它是立即执行的。关键在于 Reaction 中有一段代码是这样的。")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[t._v("global_state_1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("globalState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("currentReaction "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Clear bindings first.")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("clearBinding")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("callback")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    debugId"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" global_state_1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("globalState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("currentDebugId\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("finally")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  global_state_1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("globalState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("currentReaction "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br")])]),a("p",[t._v("这段代码是非常经典的，首先设置当前的依赖项 currentReaction，然后执行 callback，再清除 currentReaction。这样在执行 callback 的过程中，会触发 observable 中设置的 getter 函数。会把 currentReaction 当作所有数据的依赖。关键代码在"),a("code",[t._v("bindCurrentReaction")]),t._v("中实现。")]),t._v(" "),a("p",[t._v("相应的当我们执行"),a("code",[t._v("obj.a = 2")]),t._v("时，会触发 Proxy 的 setter 函数，会调用 queueRunReactions 从而找到刚才保存下来的 currentReaction，然后就可以"),a("code",[t._v("runReaction(currentReaction)")]),t._v("。")]),t._v(" "),a("p",[t._v("重点需要关注"),a("code",[t._v("Reaction")]),t._v("的实现，类似于 vue-next 中的"),a("code",[t._v("effect")]),t._v("的实现。")]),t._v(" "),a("p",[t._v("另一个比较重要的点是这个库非常依赖全局状态管理，主要集中在 global-state.ts 文件中，尤其是其中的 objectReactionBindings 这个对象。它全局保存了数据和 Reaction 的依赖关系。")]),t._v(" "),a("p",[t._v("依赖"),a("code",[t._v("dependency-inject")]),t._v("实现依赖注入的功能。")]),t._v(" "),a("h2",{attrs:{id:"dob-react"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dob-react"}},[t._v("#")]),t._v(" dob-react")]),t._v(" "),a("p",[t._v("主要是提供了 Provider 和 Connect 这两个方法。可以在 Provider 这个组件上声明任意多个 props，这些 props 数据都会被注入到"),a("code",[t._v("@Connect")]),t._v("装饰的组件中。")]),t._v(" "),a("p",[t._v("也就是说我们自己写的组件如果使用了"),a("code",[t._v("@Connect")]),t._v("装饰器，那么组件内"),a("code",[t._v("this.props")]),t._v("就会自动被注入一些属性，这些属性就是 Provider 上声明的属性。")]),t._v(" "),a("p",[t._v("目前发现的唯一路径是这样的。"),a("code",[t._v("observe")]),t._v("调用"),a("code",[t._v("new Reaction")]),t._v("调用"),a("code",[t._v("设置currentReaction")]),t._v("，然后在访问 getter 时，就会把数据和 currentReaction 绑定起来，也就是"),a("code",[t._v("bindCurrentReaction")]),t._v("。")]),t._v(" "),a("p",[t._v("在 dob 中只能通过"),a("code",[t._v("observe")]),t._v("才能实现依赖收集。在"),a("code",[t._v("dob-react")]),t._v("中，有以下流程：\n"),a("code",[t._v("@connect")]),t._v("调用"),a("code",[t._v("mixinAndInject")]),t._v("调用"),a("code",[t._v("mixinLifecycleEvents")]),t._v("调用"),a("code",[t._v("patch")]),t._v("调用"),a("code",[t._v("reactiveMixin")]),t._v("调用"),a("code",[t._v("initialRender")]),t._v("调用"),a("code",[t._v("new Reaction")]),t._v("，从而把组件的 render 函数和数据绑定起来。")]),t._v(" "),a("p",[t._v("当然最终的实现部分还是需要注意"),a("code",[t._v("baseRender")]),t._v("和"),a("code",[t._v("initialRender")]),t._v("和"),a("code",[t._v("reactiveRender")]),t._v("之间的关系。")]),t._v(" "),a("h2",{attrs:{id:"concent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#concent"}},[t._v("#")]),t._v(" concent")]),t._v(" "),a("p",[t._v("这是一个框架，而且功能非常强大，并且更新非常活跃。同时支持类组件和函数组件。唯一我不太喜欢的地方可能就是过于复杂了，上手成本有点高，再加上使用字符串来区分模块也是一个原罪。不过它仍然是一个非常优秀的框架。")]),t._v(" "),a("p",[t._v("我这里重点关注一下 register 和 useConcent 是如何实现组件的响应式更新的。")]),t._v(" "),a("p",[t._v("参考官方文档中"),a("a",{attrs:{href:"https://concentjs.github.io/concent-doc/api-much-used/useConcent",target:"_blank",rel:"noopener noreferrer"}},[t._v("最简单的例子"),a("OutboundLink")],1)]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Demo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" setState "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("useConcent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" module"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"foo"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("changeName")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" e "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("target"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("可以猜测到 useConcent 本身是不需要做依赖收集的。因为我们还是需要手动调用"),a("code",[t._v("setState")]),t._v("方法去更新数据，这时可以强制调用"),a("code",[t._v("forseUpdate")]),t._v("方法去更新组件。")]),t._v(" "),a("p",[t._v("分析源码可知，useConcent 返回值是一个"),a("code",[t._v("CcHook")]),t._v("的实例对象。这个实例对象的 state 和 setState\b 就是"),a("code",[t._v("React.useState")]),t._v("的返回值。综上 useConcent 就是对"),a("code",[t._v("React.useState")]),t._v("的封装，说明我猜测的没有错。")]),t._v(" "),a("p",[t._v("我还发现 useConcent 是不支持直接 mutable 修改 state 数据的，只能通过 setState 来修改数据。make-ob-state.js 中的 setter 中是没有 trigger 方法的，说明确实没有实现 mutable 响应式。")]),t._v(" "),a("p",[t._v("当然 useConcent 是需要做到多个组件共享数据的，也就是一个组件修改了数据，可能会影响到别的组件。")]),t._v(" "),a("p",[t._v("useConcent 调用 buildRef 调用 buildRefCtx，其中 buildRefCtx 会修改 ref.state 属性，该属性会合并当前组件的 state 和 moduleState。这就是 useConcent 从全局获取 moduleState 的过程。")]),t._v(" "),a("p",[t._v("至于 moduleState 状态的改变，是如何改变所有依赖这个 moduleState 所有组件的稍微复杂一些。")]),t._v(" "),a("p",[t._v("build-ref-ctx.js 中使用了 makeObState 处理了 state\b 数据，\b 从而利用 Proxy 的 getter 收集依赖。收集依赖的逻辑在 updateDep 函数中。主要是以下代码。")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这个key代表着refCtx，从而可以利用这个refCtx来更新组件")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" ccUniqueKey "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" refCtx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ccUniqueKey"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这个key代表着数据foo/count")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" waKey "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("makeWaKey")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("module"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 最终在wakey-ukey-map.js文件中把这两个key通过waKey2uKeyMap关联起来。")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[t._v("当用户点击某个按钮，触发点击事件，然后调用 setState 去修改数据时，这个 setState 其实是在 build-ref-ctx.js 文件中定义的，最终会调用 changeState 调用 changeRefState。\nchangeRefState 会调用 triggerBroadcastState 会调用 broadcastState，其中有个重要的函数是 findUpdateRefs，这个函数会返回所有依赖了变更数据的 ref 的 key。有了这个 key，再加上我们还有全局的 ref 对象池。")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取全局ref对象池，是一个Record<string, Ref>的对象")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" ccUKey2ref "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ccContext"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ccUKey2ref"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 通过key和全局ref对象池，就能获取到ref对象")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" ref "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ccUKey2ref"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("refKey"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 有了ref对象，就能触发这个ref上的setState方法，从而\b更新组件")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("triggerReactSetState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ref"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("以上分析我是通过 debug 代码观察到 \b 的整个过程。当然我只是观察了最简单的两个组件依赖同一个 module 的过程。")]),t._v(" "),a("p",[t._v("我观察到的最大的结论是 useConcent\b 没有实现 Proxy 中的 setter 的响应式触发，也就是不支持 mutable 更新数据。第二点就是 concent 在保存数据和视图的依赖关系时，是通过保存 key 与 key 之间的依赖关系，而且还保存了全局的 ref 对象池。从而实现当某个数据变化时，多个依赖该数据的视图都能得到更新。相对应的在很多别的 \b 库中，都是直接通过 map 来保存数据和 Dep 之间的依赖关系。")]),t._v(" "),a("p",[t._v("register 作为一个装饰器，会包装一个类组件，然后返回一个新的类组件。只需要知道这一行代码即可。")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("buildRefCtx")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" params"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" lite"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("上面有提到的 useConcent 的核心代码就是"),a("code",[t._v("buildRefCtx(hookRef, params, lite);")]),t._v("，这行代码内部会重新包装 state 和 setState，从而可以支持 module 等特性。")]),t._v(" "),a("h2",{attrs:{id:"nx-js-observer-util"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nx-js-observer-util"}},[t._v("#")]),t._v(" @nx-js/observer-util")]),t._v(" "),a("p",[t._v("observable 方法对应的是 reactive 方法，实现原理和 doux 比较一致，只是封装的更好一些。也是在不同的 handler 中处理 track 和 trigger。当然 track 和 trigger 需要处理的是 reaction，相当于 doux 中的 effect。")]),t._v(" "),a("p",[t._v("observe 和 unobserve 则分别对应的是 watch 和 stopWatch 方法。注意这里使用"),a("code",[t._v("reaction.scheduler")]),t._v("代替了"),a("code",[t._v("reaction")]),t._v("。从而实现了从组件收集依赖和更新组件的分离。这一点和 doux 的"),a("code",[t._v("cb")]),t._v("属性是比较相似的。")]),t._v(" "),a("h2",{attrs:{id:"preact-nx-observer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#preact-nx-observer"}},[t._v("#")]),t._v(" preact-nx-observer")]),t._v(" "),a("p",[t._v("observer 方法支持类组件，这里比较取巧的地方就是在 componentDidMount 中替换了 render 方法。")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("render "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("observe")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("render"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("scheduler")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  lazy"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("这一段代码还是比较巧妙的，但就是不知道兼容性如何。而且也没有支持函数组件。")]),t._v(" "),a("h2",{attrs:{id:"react-easy-state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-easy-state"}},[t._v("#")]),t._v(" react-easy-state")]),t._v(" "),a("p",[t._v("store，以及 createStore 都是对 observable 的封装。只是增加了对"),a("code",[t._v("unstable_batchedUpdates")]),t._v("的支持。"),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/78516581",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考这片文章"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("view 则是对组件的封装。支持函数组件和类组件。")]),t._v(" "),a("p",[t._v("注意类组件中是在构造函数中替换掉的 render 方法，对比"),a("code",[t._v("preact-nx-observer")]),t._v("是在 componentDidMount 中替换的。我认为在构造函数中替换更符合直觉。")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 针对函数组件的封装")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" render "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("useMemo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("observe")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Comp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("scheduler")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      lazy"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Adding the original Comp here is necessary to make React Hot Reload work")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// it does not affect behavior otherwise")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Comp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br")])]),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 针对类组件的封装")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("render "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("observe")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("render"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("scheduler")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  lazy"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("h2",{attrs:{id:"mobx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mobx"}},[t._v("#")]),t._v(" mobx")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 相当于vue-next中的reactive")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("makeObservable")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("target"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" annotations"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" options"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("makeAutoObservable")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("target"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" overrides"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" options"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("observable")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("source"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" overrides"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" options"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("需要指定"),a("code",[t._v("@observable")]),t._v(","),a("code",[t._v("@action")]),t._v(","),a("code",[t._v("@computed")]),t._v("等来指定各个属性的性质。")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 相当于vue-next中的watch")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("reaction")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" previousValue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" reaction"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" sideEffect "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" options"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 相当于vue-next中的watchEffect")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("autorun")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("effect")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("reaction"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对组件的封装")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" observer "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"mobx-react-lite"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// Or "mobx-react".')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" MyComponent "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("observer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("props "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" ReactElement"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("这里的 observer 功能非常强大，只要组件依赖了 observable 数据，不管这个"),a("a",{attrs:{href:"https://mobx.js.org/react-integration.html#local-and-external-state",target:"_blank",rel:"noopener noreferrer"}},[t._v("数据的来源"),a("OutboundLink")],1),t._v("是什么，都能触发组件重新渲染。")]),t._v(" "),a("p",[t._v("尤其是对各种情况都考虑的非常周全，值得学习。")]),t._v(" "),a("h2",{attrs:{id:"vue-next"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-next"}},[t._v("#")]),t._v(" vue-next")]),t._v(" "),a("p",[t._v("整个流程比较像"),a("code",[t._v("@nx-js/observer-util")]),t._v("，reactive 也是借助的 Proxy 来实现的，关键是 baseHandler 的实现。然后利用 track 来收集依赖。依赖被转为 effect，又有 activeEffect 和 effectStack 这些概念。")]),t._v(" "),a("p",[t._v("可惜我只想依赖其中的@vue/reactivity 这个库。但是 watch/watchEffect 这两个方法都不包含在内，因为 watch 和 watchEffect 都是和 vue 深度绑定的。")]),t._v(" "),a("p",[t._v("所以如果想要在 react 中使用，则必须实现自己的 watch/watchEffect 方法。")]),t._v(" "),a("p",[t._v("我理解广义 watch 的 api 形式有这 3 种场景：")]),t._v(" "),a("ol",[a("li",[t._v("指定需要 watch 的数据，可以是对象、数组、函数形式指定依赖数据，当数据有变化时，执行 callback")]),t._v(" "),a("li",[t._v("指定一个 effect，第一次立即执行时会收集依赖，后续当这些依赖数据有变化的时候，会再次执行这个 effect")]),t._v(" "),a("li",[t._v("指定 effect 和 callback，当 effect 对应的依赖有变化的时候，会执行 callback")])]),t._v(" "),a("p",[t._v("很容易发现在 vue-next 中已经实现了"),a("code",[t._v("watch")]),t._v("和"),a("code",[t._v("watchEffect")]),t._v("方法，但是实际上在 dowatch 中，又一个细节实现：")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" runner "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("effect")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("getter"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  lazy"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  onTrack"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  onTrigger"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  scheduler\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("这段代码可以理解为观察 getter 返回的数据是否有变化，如果有变化就执行 scheduler。这就是上面提到的第 3 中 api。而且 1 和 2 就是依赖 3 来实现的。\n当 watch 的数据本身看作是一个 getter 时，1 就变成 3 了。\n当 effect 等于 callback 时，2 就是 3 的一种特殊形式。\n需要注意这里的 3 中的 effect 和 callback 不是完全独立的。如果是完全独立的，应该采用 1 这种形式以 getter 的形式提供观察的数据，而不是以 effect 的形式提供依赖数据。观察如下代码：")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这里的本意是当state.count变化时，输出state.name")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 但是这里不应该这么写")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("watch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这里明确以getter的形式提供依赖数据")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("watch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br")])]),a("p",[t._v("3 的场景可能是这样的。")]),t._v(" "),a("div",{staticClass:"language-ts line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// renderView是渲染试图的函数，也是我们观察的effect，当其依赖的数据有变化时，我们可能没有办法直接调用renderView这个函数")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 我们只能通过另一个函数forceUpdate来触发视图更新")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("watch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("renderView")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("someView"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("forceUpdate")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("someView"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("h2",{attrs:{id:"constate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#constate"}},[t._v("#")]),t._v(" constate")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/diegohaz/constate",target:"_blank",rel:"noopener noreferrer"}},[t._v("github 网址"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("我想实现的库可以看作是 constate 的升级版。现在 constate 只是把 hooks 都放到一个全局的空间中。然后达到所有组件可以共享这个 hooks 的状态。")]),t._v(" "),a("p",[t._v("缺点是只有一个全局命名空间。而且服务的形式只能是 hooks，没有依赖注入，没有 mutable 响应式。")]),t._v(" "),a("p",[t._v("优点是简单，而且只依赖 hooks 和 context，应该是兼容并发模式的。")]),t._v(" "),a("h2",{attrs:{id:"react-类组件-vs-vue-类组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-类组件-vs-vue-类组件"}},[t._v("#")]),t._v(" react 类组件 vs vue 类组件")]),t._v(" "),a("p",[t._v("react 类组件是官方原生支持的，实例属性不是 reactive 的，只有通过 this.setState 修改 this.state 才会 re-render。")]),t._v(" "),a("p",[t._v("vue 类组件必须借助 vue-class-component 才能工作，其原理也是转化为 Option 组件。其中所有实例属性都是 reactive 的。")]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("doux 使用函数组件包裹业务组件，也可以看作是"),a("code",[t._v("observe")]),t._v("函数的返回值作为 this.render\npreact-nx-observer 是"),a("code",[t._v("observe")]),t._v("直接返回新的 render 函数替换 this.render\nreact-easy-state 也是直接替换的 this.render\ndob-react 是需要自己构建新的 render 函数去替换 this.render\nconcent 主要是对"),a("code",[t._v("setState")]),t._v("的封装，而且不支持 mutable 响应式\nmobx 再看看\nvue-next 中的 render 函数默认就会收集依赖的，而且会把 render 函数当作一个 watchEffect 来对待")])])}),[],!1,null,null,null);s.default=e.exports}}]);