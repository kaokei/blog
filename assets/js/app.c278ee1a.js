(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,i,s=e[0],c=e[1],l=e[2],p=0,d=[];p<s.length;p++)i=s[p],Object.prototype.hasOwnProperty.call(o,i)&&o[i]&&d.push(o[i][0]),o[i]=0;for(r in c)Object.prototype.hasOwnProperty.call(c,r)&&(n[r]=c[r]);for(u&&u(e);d.length;)d.shift()();return a.push.apply(a,l||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,s=1;s<t.length;s++){var c=t[s];0!==o[c]&&(r=!1)}r&&(a.splice(e--,1),n=i(i.s=t[0]))}return n}var r={},o={1:0},a=[];function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=o[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=o[n]=[e,r]}));e.push(t[2]=r);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"7c544ba5",3:"35201f32",4:"d73334a3",5:"1def405a",6:"d9038534",7:"1726cd54",8:"7f7fece9",9:"9c8c35c6",10:"79f1acf3",11:"e02b63d8",12:"79bc61e4",13:"93cdfcb4",14:"5b395604",15:"a7821766",16:"b8590dff",17:"ab576823",18:"253ac86e",19:"885bb45c",20:"fe55e5ba",21:"95118097",22:"f80a29ba",23:"5f3a55bd",24:"c6ecf195",25:"9939ce0c",26:"8b28dcdf",27:"acfba05e",28:"5d27ed25",29:"4bd0be68",30:"543e5841",31:"d3c2bab3",32:"806646a7",33:"25534b16",34:"9e309fd2",35:"2dc724ca",36:"805a8013",37:"53a94579",38:"6c7c77ff",39:"ccd38598",40:"61d57688",41:"70cc27aa",42:"728409cd",43:"c3b6005c",44:"35fc22cd",45:"542d7798",46:"421aa95b",47:"5c0dbc06",48:"02a0f636",49:"87afac87",50:"1e295eb9",51:"04a080e5",52:"0bd0d6b8",53:"5316ce9d",54:"4464b4a6",55:"6f6a863a",56:"fd4f7765",57:"82eef0c1",58:"8a74a1ef",59:"60a71176",60:"332c9fc4",61:"056822ec",62:"4b0049a0",63:"c8034519",64:"d85ee7fe",65:"f8165280",66:"78f76214",67:"61515031",68:"7fb38902",69:"98e4e3ae",70:"a8b1b80f",71:"c2d79a03",72:"ef591f37",73:"593a99af",74:"3a9118e6",75:"53c732f4",76:"8aa53a7b",77:"d4db3187",78:"dba2527d",79:"47cd3820",80:"54d4a821",81:"3bad61c5",82:"963fa092"}[n]+".js"}(n);var c=new Error;a=function(e){s.onerror=s.onload=null,clearTimeout(l);var t=o[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;c.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",c.name="ChunkLoadError",c.type=r,c.request=a,t[1](c)}o[n]=void 0}};var l=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=r,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)i.d(t,r,function(e){return n[e]}.bind(null,r));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],c=s.push.bind(s);s.push=e,s=s.slice();for(var l=0;l<s.length;l++)e(s[l]);var u=c;a.push([102,0]),t()}([function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){"use strict";function r(n,e,t,r,o,a,i,s){var c,l="function"==typeof n?n.options:n;if(e&&(l.render=e,l.staticRenderFns=t,l._compiled=!0),r&&(l.functional=!0),a&&(l._scopeId="data-v-"+a),i?(c=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),o&&o.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},l._ssrRegister=c):o&&(c=s?function(){o.call(this,(l.functional?this.parent:this).$root.$options.shadowRoot)}:o),c)if(l.functional){l._injectStyles=c;var u=l.render;l.render=function(n,e){return c.call(e),u(n,e)}}else{var p=l.beforeCreate;l.beforeCreate=p?[].concat(p,c):[c]}return{exports:n,options:l}}t.d(e,"a",(function(){return r}))},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var r=t(28),o=Function.prototype,a=o.bind,i=o.call,s=r&&a.bind(i,i);n.exports=r?function(n){return n&&s(n)}:function(n){return n&&function(){return i.apply(n,arguments)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(3),o=t(46),a=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(o(n),e)}},function(n,e,t){var r=t(68),o="object"==typeof self&&self&&self.Object===Object&&self,a=r||o||Function("return this")();n.exports=a},function(n,e,t){var r=t(4);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(0);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(157),o=t(160);n.exports=function(n,e){var t=o(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return i})),t.d(e,"g",(function(){return c})),t.d(e,"h",(function(){return l})),t.d(e,"i",(function(){return u})),t.d(e,"c",(function(){return p})),t.d(e,"f",(function(){return d})),t.d(e,"l",(function(){return v})),t.d(e,"m",(function(){return m})),t.d(e,"d",(function(){return f})),t.d(e,"k",(function(){return g})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return x}));const r=/#.*$/,o=/\.(md|html)$/,a=/\/$/,i=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(o,"")}function c(n){return i.test(n)}function l(n){return/^mailto:/.test(n)}function u(n){return/^tel:/.test(n)}function p(n){if(c(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",o=s(n);return a.test(o)?n:o+".html"+t}function d(n,e){const t=n.hash,o=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(o&&t!==o)return!1;return s(n.path)===s(e)}function v(n,e,t){if(c(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const o=e.split("/");t&&o[o.length-1]||o.pop();const a=n.replace(/^\//,"").split("/");for(let n=0;n<a.length;n++){const e=a[n];".."===e?o.pop():"."!==e&&o.push(e)}""!==o[0]&&o.unshift("");return o.join("/")}(e,t));const r=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:p(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function m(n,e,t,r){const{pages:o,themeConfig:a}=t,i=r&&a.locales&&a.locales[r]||a;if("auto"===(n.frontmatter.sidebar||i.sidebar||a.sidebar))return h(n);const s=i.sidebar||a.sidebar;if(s){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,s);return"auto"===r?h(n):r?r.map(n=>function n(e,t,r,o=1){if("string"==typeof e)return v(t,e,r);if(Array.isArray(e))return Object.assign(v(t,e[0],r),{title:e[1]});{o>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const a=e.children||[];return 0===a.length&&e.path?Object.assign(v(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map(e=>n(e,t,r,o+1)),collapsable:!1!==e.collapsable}}}(n,o,t)):[]}return[]}function h(n){const e=f(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function f(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function g(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(8),o=t(62),a=t(98),i=t(26),s=t(53),c=TypeError,l=Object.defineProperty,u=Object.getOwnPropertyDescriptor;e.f=r?a?function(n,e,t){if(i(n),e=s(e),i(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=u(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return l(n,e,t)}:l:function(n,e,t){if(i(n),e=s(e),i(t),o)try{return l(n,e,t)}catch(n){}if("get"in t||"set"in t)throw c("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(15),o=t(142),a=t(143),i=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?o(n):a(n)}},function(n,e,t){var r=t(7).Symbol;n.exports=r},function(n,e,t){var r=t(2),o=t(0),a=function(n){return o(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(r[n]):r[n]&&r[n][e]}},function(n,e,t){var r=t(2),o=t(59),a=t(6),i=t(61),s=t(57),c=t(56),l=o("wks"),u=r.Symbol,p=u&&u.for,d=c?u:u&&u.withoutSetter||i;n.exports=function(n){if(!a(l,n)||!s&&"string"!=typeof l[n]){var e="Symbol."+n;s&&a(u,n)?l[n]=u[n]:l[n]=c&&p?p(e):d(e)}return l[n]}},function(n,e,t){var r=t(8),o=t(13),a=t(31);n.exports=r?function(n,e,t){return o.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(147),o=t(148),a=t(149),i=t(150),s=t(151);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=o,c.prototype.get=a,c.prototype.has=i,c.prototype.set=s,n.exports=c},function(n,e,t){var r=t(70);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(10)(Object,"create");n.exports=r},function(n,e,t){var r=t(169);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(42);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,o;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(o="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function o(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=o(n,r.minimum,1),t.status=1===n?null:n;var c=t.render(!e),l=c.querySelector(r.barSelector),u=r.speed,p=r.easing;return c.offsetWidth,i((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(l,function(n,e,t){var o;return(o="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,o}(n,u,p)),1===n?(s(c,{transition:"none",opacity:1}),c.offsetWidth,setTimeout((function(){s(c,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*o(Math.random()*e,.1,.95)),e=o(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");l(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var o,i=e.querySelector(r.barSelector),c=n?"-100":a(t.status||0),u=document.querySelector(r.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+c+"%,0,0)"}),r.showSpinner||(o=e.querySelector(r.spinnerSelector))&&d(o),u!=document.body&&l(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&d(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,o=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);o--;)if((r=n[o]+a)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,o,a=arguments;if(2==a.length)for(t in e)void 0!==(o=e[t])&&e.hasOwnProperty(t)&&r(n,t,o);else r(n,a[1],a[2])}}();function c(n,e){return("string"==typeof n?n:p(n)).indexOf(" "+e+" ")>=0}function l(n,e){var t=p(n),r=t+e;c(t,e)||(n.className=r.substring(1))}function u(n,e){var t,r=p(n);c(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function p(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function d(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=o)},function(n){n.exports=JSON.parse('{"name":"vuepress-plugin-comment","version":"0.7.3","description":"Comment plugin in vuepress, such as Gitalk, Valine...","main":"index.js","scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"author":"dongyuanxin","license":"MIT","bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"}}')},function(n,e,t){var r=t(9),o=String,a=TypeError;n.exports=function(n){if(r(n))return n;throw a(o(n)+" is not an object")}},function(n,e,t){var r=t(2),o=t(51).f,a=t(18),i=t(110),s=t(34),c=t(64),l=t(122);n.exports=function(n,e){var t,u,p,d,v,m=n.target,h=n.global,f=n.stat;if(t=h?r:f?r[m]||s(m,{}):(r[m]||{}).prototype)for(u in e){if(d=e[u],p=n.dontCallGetSet?(v=o(t,u))&&v.value:t[u],!l(h?u:m+(f?".":"#")+u,n.forced)&&void 0!==p){if(typeof d==typeof p)continue;c(d,p)}(n.sham||p&&p.sham)&&a(d,"sham",!0),i(t,u,d,n)}}},function(n,e,t){var r=t(4);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(44),o=t(52);n.exports=function(n){return r(o(n))}},function(n,e,t){var r=t(28),o=Function.prototype.call;n.exports=r?o.bind(o):function(){return o.apply(o,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(3),o=r({}.toString),a=r("".slice);n.exports=function(n){return a(o(n),8,-1)}},function(n,e,t){var r=t(2),o=t(34),a=r["__core-js_shared__"]||o("__core-js_shared__",{});n.exports=a},function(n,e,t){var r=t(2),o=Object.defineProperty;n.exports=function(n,e){try{o(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(141),o=t(12),a=Object.prototype,i=a.hasOwnProperty,s=a.propertyIsEnumerable,c=r(function(){return arguments}())?r:function(n){return o(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=c},function(n,e,t){var r=t(10)(t(7),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(161),o=t(168),a=t(170),i=t(171),s=t(172);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=o,c.prototype.get=a,c.prototype.has=i,c.prototype.set=s,n.exports=c},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(5),o=t(42),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!o(n))||(i.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(14),o=t(12);n.exports=function(n){return"symbol"==typeof n||o(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var r=t(3),o=t(4),a=t(32),i=Object,s=r("".split);n.exports=o((function(){return!i("z").propertyIsEnumerable(0)}))?function(n){return"String"==a(n)?s(n,""):i(n)}:i},function(n,e,t){var r=t(0),o=t(108),a=TypeError;n.exports=function(n){if(r(n))return n;throw a(o(n)+" is not a function")}},function(n,e,t){var r=t(52),o=Object;n.exports=function(n){return o(r(n))}},function(n,e){n.exports={}},function(n,e,t){var r=t(120);n.exports=function(n){return r(n.length)}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,o=/^0b[01]+$/i,a=/^0o[0-7]+$/i,i=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,c="object"==typeof self&&self&&self.Object===Object&&self,l=s||c||Function("return this")(),u=Object.prototype.toString,p=Math.max,d=Math.min,v=function(){return l.Date.now()};function m(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function h(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(m(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=m(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=o.test(n);return s||a.test(n)?i(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,o,a,i,s,c,l=0,u=!1,f=!1,g=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,a=o;return r=o=void 0,l=e,i=n.apply(a,t)}function y(n){return l=n,s=setTimeout(j,e),u?b(n):i}function x(n){var t=n-c;return void 0===c||t>=e||t<0||f&&n-l>=a}function j(){var n=v();if(x(n))return k(n);s=setTimeout(j,function(n){var t=e-(n-c);return f?d(t,a-(n-l)):t}(n))}function k(n){return s=void 0,g&&r?b(n):(r=o=void 0,i)}function w(){var n=v(),t=x(n);if(r=arguments,o=this,c=n,t){if(void 0===s)return y(c);if(f)return s=setTimeout(j,e),b(c)}return void 0===s&&(s=setTimeout(j,e)),i}return e=h(e)||0,m(t)&&(u=!!t.leading,a=(f="maxWait"in t)?p(h(t.maxWait)||0,e):a,g="trailing"in t?!!t.trailing:g),w.cancel=function(){void 0!==s&&clearTimeout(s),l=0,r=c=o=s=void 0},w.flush=function(){return void 0===s?i:k(v())},w}},function(n,e,t){var r=t(8),o=t(30),a=t(104),i=t(31),s=t(29),c=t(53),l=t(6),u=t(62),p=Object.getOwnPropertyDescriptor;e.f=r?p:function(n,e){if(n=s(n),e=c(e),u)try{return p(n,e)}catch(n){}if(l(n,e))return i(!o(a.f,n,e),n[e])}},function(n,e){var t=TypeError;n.exports=function(n){if(null==n)throw t("Can't call method on "+n);return n}},function(n,e,t){var r=t(105),o=t(54);n.exports=function(n){var e=r(n,"string");return o(e)?e:e+""}},function(n,e,t){var r=t(16),o=t(0),a=t(55),i=t(56),s=Object;n.exports=i?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return o(e)&&a(e.prototype,s(n))}},function(n,e,t){var r=t(3);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(57);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(58),o=t(4);n.exports=!!Object.getOwnPropertySymbols&&!o((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,o,a=t(2),i=t(106),s=a.process,c=a.Deno,l=s&&s.versions||c&&c.version,u=l&&l.v8;u&&(o=(r=u.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!o&&i&&(!(r=i.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=i.match(/Chrome\/(\d+)/))&&(o=+r[1]),n.exports=o},function(n,e,t){var r=t(60),o=t(33);(n.exports=function(n,e){return o[n]||(o[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.23.5",mode:r?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.23.5/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var r=t(3),o=0,a=Math.random(),i=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+i(++o+a,36)}},function(n,e,t){var r=t(8),o=t(4),a=t(97);n.exports=!r&&!o((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(3),o=t(0),a=t(33),i=r(Function.toString);o(a.inspectSource)||(a.inspectSource=function(n){return i(n)}),n.exports=a.inspectSource},function(n,e,t){var r=t(6),o=t(115),a=t(51),i=t(13);n.exports=function(n,e,t){for(var s=o(e),c=i.f,l=a.f,u=0;u<s.length;u++){var p=s[u];r(n,p)||t&&r(t,p)||c(n,p,l(e,p))}}},function(n,e,t){var r=t(119);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){var r=t(3),o=t(26),a=t(129);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return o(t),a(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,o=n.length;++t<r;)n[o+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(19),o=t(152),a=t(153),i=t(154),s=t(155),c=t(156);function l(n){var e=this.__data__=new r(n);this.size=e.size}l.prototype.clear=o,l.prototype.delete=a,l.prototype.get=i,l.prototype.has=s,l.prototype.set=c,n.exports=l},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(14),o=t(37);n.exports=function(n){if(!o(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(173),o=t(12);n.exports=function n(e,t,a,i,s){return e===t||(null==e||null==t||!o(e)&&!o(t)?e!=e&&t!=t:r(e,t,a,i,n,s))}},function(n,e,t){var r=t(75),o=t(176),a=t(76);n.exports=function(n,e,t,i,s,c){var l=1&t,u=n.length,p=e.length;if(u!=p&&!(l&&p>u))return!1;var d=c.get(n),v=c.get(e);if(d&&v)return d==e&&v==n;var m=-1,h=!0,f=2&t?new r:void 0;for(c.set(n,e),c.set(e,n);++m<u;){var g=n[m],b=e[m];if(i)var y=l?i(b,g,m,e,n,c):i(g,b,m,n,e,c);if(void 0!==y){if(y)continue;h=!1;break}if(f){if(!o(e,(function(n,e){if(!a(f,e)&&(g===n||s(g,n,t,i,c)))return f.push(e)}))){h=!1;break}}else if(g!==b&&!s(g,b,t,i,c)){h=!1;break}}return c.delete(n),c.delete(e),h}},function(n,e,t){var r=t(38),o=t(174),a=t(175);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=o,i.prototype.has=a,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(186),o=t(192),a=t(81);n.exports=function(n){return a(n)?r(n):o(n)}},function(n,e,t){(function(n){var r=t(7),o=t(188),a=e&&!e.nodeType&&e,i=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===a?r.Buffer:void 0,c=(s?s.isBuffer:void 0)||o;n.exports=c}).call(this,t(49)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(189),o=t(190),a=t(191),i=a&&a.isTypedArray,s=i?o(i):r;n.exports=s},function(n,e,t){var r=t(71),o=t(40);n.exports=function(n){return null!=n&&o(n.length)&&!r(n)}},function(n,e,t){var r=t(10)(t(7),"Set");n.exports=r},function(n,e,t){var r=t(37);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(86),o=t(23);n.exports=function(n,e){for(var t=0,a=(e=r(e,n)).length;null!=n&&t<a;)n=n[o(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var r=t(5),o=t(41),a=t(203),i=t(206);n.exports=function(n,e){return r(n)?n:o(n,e)?[n]:a(i(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(139),o=t(144),a=t(215),i=t(223),s=t(232),c=t(101),l=a((function(n){var e=c(n);return s(e)&&(e=void 0),i(r(n,1,s,!0),o(e,2))}));n.exports=l},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var r=t(242),o=t(243),a=t(244),i=!1,s=t(245).version,c=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],l=c.concat("cache"),u=/^\uFEFF/;function p(n,t){var o,a,i=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)o=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(a=e.resolveInclude(n,t.filename),r.existsSync(a)&&(o=a)),o||Array.isArray(i)&&i.some((function(t){return a=e.resolveInclude(n,t,!0),r.existsSync(a)}))&&(o=a),!o)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return o}function d(n,t){var r,o=n.filename,a=arguments.length>1;if(n.cache){if(!o)throw new Error("cache option requires a filename");if(r=e.cache.get(o))return r;a||(t=m(o).toString().replace(u,""))}else if(!a){if(!o)throw new Error("Internal EJS error: no file name or template provided");t=m(o).toString().replace(u,"")}return r=e.compile(t,n),n.cache&&e.cache.set(o,r),r}function v(n,t,r){var o;if(!r){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,r){try{e(o=d(n)(t))}catch(n){r(n)}}));throw new Error("Please provide a callback function")}try{o=d(n)(t)}catch(n){return r(n)}r(null,o)}function m(n){return e.fileLoader(n)}function h(n,e,t,r,o){var a=e.split("\n"),i=Math.max(r-3,0),s=Math.min(a.length,r+3),c=o(t),l=a.slice(i,s).map((function(n,e){var t=e+i+1;return(t==r?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=c,n.message=(c||"ejs")+":"+r+"\n"+l+"\n\n"+n.message,n}function f(n){return n.replace(/;(\s*$)/,"$1")}function g(n,t){t=t||{};var r={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],r.client=t.client||!1,r.escapeFunction=t.escape||t.escapeFunction||a.escapeXML,r.compileDebug=!1!==t.compileDebug,r.debug=!!t.debug,r.filename=t.filename,r.openDelimiter=t.openDelimiter||e.openDelimiter||"<",r.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",r.delimiter=t.delimiter||e.delimiter||"%",r.strict=t.strict||!1,r.context=t.context,r.cache=t.cache||!1,r.rmWhitespace=t.rmWhitespace,r.root=t.root,r.outputFunctionName=t.outputFunctionName,r.localsName=t.localsName||e.localsName||"locals",r.views=t.views,r.async=t.async,r.destructuredLocals=t.destructuredLocals,r.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,r.strict?r._with=!1:r._with=void 0===t._with||t._with,this.opts=r,this.regex=this.createRegex()}e.cache=a.cache,e.fileLoader=r.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var r=o.dirname,a=o.extname,i=(0,o.resolve)(t?e:r(e),n);return a(n)||(i+=".ejs"),i},e.compile=function(n,e){return e&&e.scope&&(i||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),i=!0),e.context||(e.context=e.scope),delete e.scope),new g(n,e).compile()},e.render=function(n,e,t){var r=e||{},o=t||{};return 2==arguments.length&&a.shallowCopyFromList(o,r,c),d(o,n)(r)},e.renderFile=function(){var n,e,t,r=Array.prototype.slice.call(arguments),o=r.shift(),i={filename:o};return"function"==typeof arguments[arguments.length-1]&&(n=r.pop()),r.length?(e=r.shift(),r.length?a.shallowCopy(i,r.pop()):(e.settings&&(e.settings.views&&(i.views=e.settings.views),e.settings["view cache"]&&(i.cache=!0),(t=e.settings["view options"])&&a.shallowCopy(i,t)),a.shallowCopyFromList(i,e,l)),i.filename=o):e={},v(i,e,n)},e.Template=g,e.clearCache=function(){e.cache.reset()},g.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},g.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=a.escapeRegExpChars(this.opts.delimiter),t=a.escapeRegExpChars(this.opts.openDelimiter),r=a.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,r),new RegExp(n)},compile:function(){var n,e,t,r=this.opts,i="",s="",c=r.escapeFunction;if(!this.source){if(this.generateSource(),i+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',r.outputFunctionName&&(i+="  var "+r.outputFunctionName+" = __append;\n"),r.destructuredLocals&&r.destructuredLocals.length){for(var l="  var __locals = ("+r.localsName+" || {}),\n",u=0;u<r.destructuredLocals.length;u++){var v=r.destructuredLocals[u];u>0&&(l+=",\n  "),l+=v+" = __locals."+v}i+=l+";\n"}!1!==r._with&&(i+="  with ("+r.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=i+this.source+s}n=r.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(r.filename?JSON.stringify(r.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,r.client&&(n="escapeFn = escapeFn || "+c.toString()+";\n"+n,r.compileDebug&&(n="rethrow = rethrow || "+h.toString()+";\n"+n)),r.strict&&(n='"use strict";\n'+n),r.debug&&console.log(n),r.compileDebug&&r.filename&&(n=n+"\n//# sourceURL="+r.filename+"\n");try{if(r.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(r.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(r.filename&&(n.message+=" in "+r.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",r.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var m=r.client?e:function(n){return e.apply(r.context,[n||{},c,function(e,t){var o=a.shallowCopy({},n);return t&&(o=a.shallowCopy(o,t)),function(n,e){var t=a.shallowCopy({},e);return t.filename=p(n,t),d(t)}(e,r)(o)},h])};if(m.dependencies=this.dependencies,r.filename&&"function"==typeof Object.defineProperty){var f=r.filename,g=o.basename(f,o.extname(f));try{Object.defineProperty(m,"name",{value:g,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return m},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,r=this.parseTemplateText(),o=this.opts.delimiter,i=this.opts.openDelimiter,s=this.opts.closeDelimiter;r&&r.length&&r.forEach((function(c,l){var d,v,h,f,b,y;if(0===c.indexOf(i+o)&&0!==c.indexOf(i+o+o)&&(v=r[l+2])!=o+s&&v!="-"+o+s&&v!="_"+o+s)throw new Error('Could not find matching close tag for "'+c+'".');if(n.legacyInclude&&(h=c.match(/^\s*include\s+(\S+)/))&&(d=r[l-1])&&(d==i+o||d==i+o+"-"||d==i+o+"_"))return f=a.shallowCopy({},t.opts),b=function(n,e){var t,r,o=a.shallowCopy({},e);r=m(t=p(n,o)).toString().replace(u,""),o.filename=t;var i=new g(r,o);return i.generateSource(),{source:i.source,filename:t,template:r}}(h[1],f),y=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(b.template)+"\n      , __filename = "+JSON.stringify(b.filename)+";\n      try {\n"+b.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+b.source+"    ; }).call(this)\n",t.source+=y,void t.dependencies.push(e.resolveInclude(h[1],f.filename));t.scanLine(c)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,r=t.exec(e),o=[];r;)0!==(n=r.index)&&(o.push(e.substring(0,n)),e=e.slice(n)),o.push(r[0]),e=e.slice(r[0].length),r=t.exec(e);return e&&o.push(e),o},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,r=this.opts.openDelimiter,o=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case r+t:case r+t+"_":this.mode=g.modes.EVAL;break;case r+t+"=":this.mode=g.modes.ESCAPED;break;case r+t+"-":this.mode=g.modes.RAW;break;case r+t+"#":this.mode=g.modes.COMMENT;break;case r+t+t:this.mode=g.modes.LITERAL,this.source+='    ; __append("'+n.replace(r+t+t,r+t)+'")\n';break;case t+t+o:this.mode=g.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+o,t+o)+'")\n';break;case t+o:case"-"+t+o:case"_"+t+o:this.mode==g.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case g.modes.EVAL:case g.modes.ESCAPED:case g.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case g.modes.EVAL:this.source+="    ; "+n+"\n";break;case g.modes.ESCAPED:this.source+="    ; __append(escapeFn("+f(n)+"))\n";break;case g.modes.RAW:this.source+="    ; __append("+f(n)+")\n";break;case g.modes.COMMENT:break;case g.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=a.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},o=(t(235),t(1)),a=Object(o.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},o=(t(236),t(1)),a=Object(o.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=a.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(2),o=t(9),a=r.document,i=o(a)&&o(a.createElement);n.exports=function(n){return i?a.createElement(n):{}}},function(n,e,t){var r=t(8),o=t(4);n.exports=r&&o((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(59),o=t(61),a=r("keys");n.exports=function(n){return a[n]||(a[n]=o(n))}},function(n,e,t){var r=t(3),o=t(6),a=t(29),i=t(117).indexOf,s=t(47),c=r([].push);n.exports=function(n,e){var t,r=a(n),l=0,u=[];for(t in r)!o(s,t)&&o(r,t)&&c(u,t);for(;e.length>l;)o(r,t=e[l++])&&(~i(u,t)||c(u,t));return u}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(248)},function(n,e,t){"use strict";var r=t(27),o=t(123).left,a=t(124),i=t(58),s=t(125);r({target:"Array",proto:!0,forced:!a("reduce")||!s&&i>79&&i<83},{reduce:function(n){var e=arguments.length;return o(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,o=Object.getOwnPropertyDescriptor,a=o&&!r.call({1:2},1);e.f=a?function(n){var e=o(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(30),o=t(9),a=t(54),i=t(107),s=t(109),c=t(17),l=TypeError,u=c("toPrimitive");n.exports=function(n,e){if(!o(n)||a(n))return n;var t,c=i(n,u);if(c){if(void 0===e&&(e="default"),t=r(c,n,e),!o(t)||a(t))return t;throw l("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){var r=t(16);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(45);n.exports=function(n,e){var t=n[e];return null==t?void 0:r(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var r=t(30),o=t(0),a=t(9),i=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&o(t=n.toString)&&!a(s=r(t,n)))return s;if(o(t=n.valueOf)&&!a(s=r(t,n)))return s;if("string"!==e&&o(t=n.toString)&&!a(s=r(t,n)))return s;throw i("Can't convert object to primitive value")}},function(n,e,t){var r=t(0),o=t(13),a=t(111),i=t(34);n.exports=function(n,e,t,s){s||(s={});var c=s.enumerable,l=void 0!==s.name?s.name:e;if(r(t)&&a(t,l,s),s.global)c?n[e]=t:i(e,t);else{try{s.unsafe?n[e]&&(c=!0):delete n[e]}catch(n){}c?n[e]=t:o.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var r=t(4),o=t(0),a=t(6),i=t(8),s=t(112).CONFIGURABLE,c=t(63),l=t(113),u=l.enforce,p=l.get,d=Object.defineProperty,v=i&&!r((function(){return 8!==d((function(){}),"length",{value:8}).length})),m=String(String).split("String"),h=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!a(n,"name")||s&&n.name!==e)&&(i?d(n,"name",{value:e,configurable:!0}):n.name=e),v&&t&&a(t,"arity")&&n.length!==t.arity&&d(n,"length",{value:t.arity});try{t&&a(t,"constructor")&&t.constructor?i&&d(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=u(n);return a(r,"source")||(r.source=m.join("string"==typeof e?e:"")),n};Function.prototype.toString=h((function(){return o(this)&&p(this).source||c(this)}),"toString")},function(n,e,t){var r=t(8),o=t(6),a=Function.prototype,i=r&&Object.getOwnPropertyDescriptor,s=o(a,"name"),c=s&&"something"===function(){}.name,l=s&&(!r||r&&i(a,"name").configurable);n.exports={EXISTS:s,PROPER:c,CONFIGURABLE:l}},function(n,e,t){var r,o,a,i=t(114),s=t(2),c=t(3),l=t(9),u=t(18),p=t(6),d=t(33),v=t(99),m=t(47),h=s.TypeError,f=s.WeakMap;if(i||d.state){var g=d.state||(d.state=new f),b=c(g.get),y=c(g.has),x=c(g.set);r=function(n,e){if(y(g,n))throw new h("Object already initialized");return e.facade=n,x(g,n,e),e},o=function(n){return b(g,n)||{}},a=function(n){return y(g,n)}}else{var j=v("state");m[j]=!0,r=function(n,e){if(p(n,j))throw new h("Object already initialized");return e.facade=n,u(n,j,e),e},o=function(n){return p(n,j)?n[j]:{}},a=function(n){return p(n,j)}}n.exports={set:r,get:o,has:a,enforce:function(n){return a(n)?o(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=o(e)).type!==n)throw h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(2),o=t(0),a=t(63),i=r.WeakMap;n.exports=o(i)&&/native code/.test(a(i))},function(n,e,t){var r=t(16),o=t(3),a=t(116),i=t(121),s=t(26),c=o([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(s(n)),t=i.f;return t?c(e,t(n)):e}},function(n,e,t){var r=t(100),o=t(96).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,o)}},function(n,e,t){var r=t(29),o=t(118),a=t(48),i=function(n){return function(e,t,i){var s,c=r(e),l=a(c),u=o(i,l);if(n&&t!=t){for(;l>u;)if((s=c[u++])!=s)return!0}else for(;l>u;u++)if((n||u in c)&&c[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e,t){var r=t(65),o=Math.max,a=Math.min;n.exports=function(n,e){var t=r(n);return t<0?o(t+e,0):a(t,e)}},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:t)(e)}},function(n,e,t){var r=t(65),o=Math.min;n.exports=function(n){return n>0?o(r(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(4),o=t(0),a=/#|\.prototype\./,i=function(n,e){var t=c[s(n)];return t==u||t!=l&&(o(e)?r(e):!!e)},s=i.normalize=function(n){return String(n).replace(a,".").toLowerCase()},c=i.data={},l=i.NATIVE="N",u=i.POLYFILL="P";n.exports=i},function(n,e,t){var r=t(45),o=t(46),a=t(44),i=t(48),s=TypeError,c=function(n){return function(e,t,c,l){r(t);var u=o(e),p=a(u),d=i(u),v=n?d-1:0,m=n?-1:1;if(c<2)for(;;){if(v in p){l=p[v],v+=m;break}if(v+=m,n?v<0:d<=v)throw s("Reduce of empty array with no initial value")}for(;n?v>=0:d>v;v+=m)v in p&&(l=t(l,p[v],v,u));return l}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var r=t(4);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(32),o=t(2);n.exports="process"==r(o.process)},function(n,e,t){var r=t(27),o=t(2),a=t(127),i=t(128),s=o.WebAssembly,c=7!==Error("e",{cause:7}).cause,l=function(n,e){var t={};t[n]=i(n,e,c),r({global:!0,constructor:!0,arity:1,forced:c},t)},u=function(n,e){if(s&&s[n]){var t={};t[n]=i("WebAssembly."+n,e,c),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:c},t)}};l("Error",(function(n){return function(e){return a(n,this,arguments)}})),l("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),l("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),l("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),l("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),l("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),l("URIError",(function(n){return function(e){return a(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){var r=t(28),o=Function.prototype,a=o.apply,i=o.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?i.bind(a):function(){return i.apply(a,arguments)})},function(n,e,t){"use strict";var r=t(16),o=t(6),a=t(18),i=t(55),s=t(66),c=t(64),l=t(130),u=t(131),p=t(132),d=t(136),v=t(137),m=t(138),h=t(8),f=t(60);n.exports=function(n,e,t,g){var b=g?2:1,y=n.split("."),x=y[y.length-1],j=r.apply(null,y);if(j){var k=j.prototype;if(!f&&o(k,"cause")&&delete k.cause,!t)return j;var w=r("Error"),_=e((function(n,e){var t=p(g?e:n,void 0),r=g?new j(n):new j;return void 0!==t&&a(r,"message",t),m&&a(r,"stack",v(r.stack,2)),this&&i(k,this)&&u(r,this,_),arguments.length>b&&d(r,arguments[b]),r}));if(_.prototype=k,"Error"!==x?s?s(_,w):c(_,w,{name:!0}):h&&"stackTraceLimit"in j&&(l(_,j,"stackTraceLimit"),l(_,j,"prepareStackTrace")),c(_,j),!f)try{k.name!==x&&a(k,"name",x),k.constructor=_}catch(n){}return _}}},function(n,e,t){var r=t(0),o=String,a=TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw a("Can't set "+o(n)+" as a prototype")}},function(n,e,t){var r=t(13).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var r=t(0),o=t(9),a=t(66);n.exports=function(n,e,t){var i,s;return a&&r(i=e.constructor)&&i!==t&&o(s=i.prototype)&&s!==t.prototype&&a(n,s),n}},function(n,e,t){var r=t(133);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){var r=t(134),o=String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return o(n)}},function(n,e,t){var r=t(135),o=t(0),a=t(32),i=t(17)("toStringTag"),s=Object,c="Arguments"==a(function(){return arguments}());n.exports=r?a:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),i))?t:c?a(e):"Object"==(r=a(e))&&o(e.callee)?"Arguments":r}},function(n,e,t){var r={};r[t(17)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(9),o=t(18);n.exports=function(n,e){r(e)&&"cause"in e&&o(n,"cause",e.cause)}},function(n,e,t){var r=t(3),o=Error,a=r("".replace),i=String(o("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,c=s.test(i);n.exports=function(n,e){if(c&&"string"==typeof n&&!o.prepareStackTrace)for(;e--;)n=a(n,s,"");return n}},function(n,e,t){var r=t(4),o=t(31);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",o(1,7)),7!==n.stack)}))},function(n,e,t){var r=t(67),o=t(140);n.exports=function n(e,t,a,i,s){var c=-1,l=e.length;for(a||(a=o),s||(s=[]);++c<l;){var u=e[c];t>0&&a(u)?t>1?n(u,t-1,a,i,s):r(s,u):i||(s[s.length]=u)}return s}},function(n,e,t){var r=t(15),o=t(35),a=t(5),i=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||o(n)||!!(i&&n&&n[i])}},function(n,e,t){var r=t(14),o=t(12);n.exports=function(n){return o(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(15),o=Object.prototype,a=o.hasOwnProperty,i=o.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=a.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var o=i.call(n);return r&&(e?n[s]=t:delete n[s]),o}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(145),o=t(201),a=t(43),i=t(5),s=t(212);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?i(n)?o(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(146),o=t(200),a=t(84);n.exports=function(n){var e=o(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(69),o=t(73);n.exports=function(n,e,t,a){var i=t.length,s=i,c=!a;if(null==n)return!s;for(n=Object(n);i--;){var l=t[i];if(c&&l[2]?l[1]!==n[l[0]]:!(l[0]in n))return!1}for(;++i<s;){var u=(l=t[i])[0],p=n[u],d=l[1];if(c&&l[2]){if(void 0===p&&!(u in n))return!1}else{var v=new r;if(a)var m=a(p,d,u,n,e,v);if(!(void 0===m?o(d,p,3,a,v):m))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(20),o=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():o.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(20);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(20);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(20);n.exports=function(n,e){var t=this.__data__,o=r(t,n);return o<0?(++this.size,t.push([n,e])):t[o][1]=e,this}},function(n,e,t){var r=t(19);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(19),o=t(36),a=t(38);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var i=t.__data__;if(!o||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(71),o=t(158),a=t(37),i=t(72),s=/^\[object .+?Constructor\]$/,c=Function.prototype,l=Object.prototype,u=c.toString,p=l.hasOwnProperty,d=RegExp("^"+u.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||o(n))&&(r(n)?d:s).test(i(n))}},function(n,e,t){var r,o=t(159),a=(r=/[^.]+$/.exec(o&&o.keys&&o.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var r=t(7)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(162),o=t(19),a=t(36);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||o),string:new r}}},function(n,e,t){var r=t(163),o=t(164),a=t(165),i=t(166),s=t(167);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=o,c.prototype.get=a,c.prototype.has=i,c.prototype.set=s,n.exports=c},function(n,e,t){var r=t(21);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(21),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return o.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(21),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:o.call(e,n)}},function(n,e,t){var r=t(21);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(22);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(22);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(22);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(22);n.exports=function(n,e){var t=r(this,n),o=t.size;return t.set(n,e),this.size+=t.size==o?0:1,this}},function(n,e,t){var r=t(69),o=t(74),a=t(177),i=t(180),s=t(196),c=t(5),l=t(78),u=t(80),p="[object Object]",d=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,v,m,h){var f=c(n),g=c(e),b=f?"[object Array]":s(n),y=g?"[object Array]":s(e),x=(b="[object Arguments]"==b?p:b)==p,j=(y="[object Arguments]"==y?p:y)==p,k=b==y;if(k&&l(n)){if(!l(e))return!1;f=!0,x=!1}if(k&&!x)return h||(h=new r),f||u(n)?o(n,e,t,v,m,h):a(n,e,b,t,v,m,h);if(!(1&t)){var w=x&&d.call(n,"__wrapped__"),_=j&&d.call(e,"__wrapped__");if(w||_){var S=w?n.value():n,I=_?e.value():e;return h||(h=new r),m(S,I,t,v,h)}}return!!k&&(h||(h=new r),i(n,e,t,v,m,h))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(15),o=t(178),a=t(70),i=t(74),s=t(179),c=t(39),l=r?r.prototype:void 0,u=l?l.valueOf:void 0;n.exports=function(n,e,t,r,l,p,d){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!p(new o(n),new o(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var v=s;case"[object Set]":var m=1&r;if(v||(v=c),n.size!=e.size&&!m)return!1;var h=d.get(n);if(h)return h==e;r|=2,d.set(n,e);var f=i(v(n),v(e),r,l,p,d);return d.delete(n),f;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var r=t(7).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(181),o=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,i,s){var c=1&t,l=r(n),u=l.length;if(u!=r(e).length&&!c)return!1;for(var p=u;p--;){var d=l[p];if(!(c?d in e:o.call(e,d)))return!1}var v=s.get(n),m=s.get(e);if(v&&m)return v==e&&m==n;var h=!0;s.set(n,e),s.set(e,n);for(var f=c;++p<u;){var g=n[d=l[p]],b=e[d];if(a)var y=c?a(b,g,d,e,n,s):a(g,b,d,n,e,s);if(!(void 0===y?g===b||i(g,b,t,a,s):y)){h=!1;break}f||(f="constructor"==d)}if(h&&!f){var x=n.constructor,j=e.constructor;x==j||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof j&&j instanceof j||(h=!1)}return s.delete(n),s.delete(e),h}},function(n,e,t){var r=t(182),o=t(183),a=t(77);n.exports=function(n){return r(n,a,o)}},function(n,e,t){var r=t(67),o=t(5);n.exports=function(n,e,t){var a=e(n);return o(n)?a:r(a,t(n))}},function(n,e,t){var r=t(184),o=t(185),a=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),r(i(n),(function(e){return a.call(n,e)})))}:o;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=0,a=[];++t<r;){var i=n[t];e(i,t,n)&&(a[o++]=i)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(187),o=t(35),a=t(5),i=t(78),s=t(79),c=t(80),l=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),u=!t&&o(n),p=!t&&!u&&i(n),d=!t&&!u&&!p&&c(n),v=t||u||p||d,m=v?r(n.length,String):[],h=m.length;for(var f in n)!e&&!l.call(n,f)||v&&("length"==f||p&&("offset"==f||"parent"==f)||d&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||s(f,h))||m.push(f);return m}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(14),o=t(40),a=t(12),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&o(n.length)&&!!i[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(68),o=e&&!e.nodeType&&e,a=o&&"object"==typeof n&&n&&!n.nodeType&&n,i=a&&a.exports===o&&r.process,s=function(){try{var n=a&&a.require&&a.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=s}).call(this,t(49)(n))},function(n,e,t){var r=t(193),o=t(194),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return o(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(195)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(197),o=t(36),a=t(198),i=t(82),s=t(199),c=t(14),l=t(72),u=l(r),p=l(o),d=l(a),v=l(i),m=l(s),h=c;(r&&"[object DataView]"!=h(new r(new ArrayBuffer(1)))||o&&"[object Map]"!=h(new o)||a&&"[object Promise]"!=h(a.resolve())||i&&"[object Set]"!=h(new i)||s&&"[object WeakMap]"!=h(new s))&&(h=function(n){var e=c(n),t="[object Object]"==e?n.constructor:void 0,r=t?l(t):"";if(r)switch(r){case u:return"[object DataView]";case p:return"[object Map]";case d:return"[object Promise]";case v:return"[object Set]";case m:return"[object WeakMap]"}return e}),n.exports=h},function(n,e,t){var r=t(10)(t(7),"DataView");n.exports=r},function(n,e,t){var r=t(10)(t(7),"Promise");n.exports=r},function(n,e,t){var r=t(10)(t(7),"WeakMap");n.exports=r},function(n,e,t){var r=t(83),o=t(77);n.exports=function(n){for(var e=o(n),t=e.length;t--;){var a=e[t],i=n[a];e[t]=[a,i,r(i)]}return e}},function(n,e,t){var r=t(73),o=t(202),a=t(209),i=t(41),s=t(83),c=t(84),l=t(23);n.exports=function(n,e){return i(n)&&s(e)?c(l(n),e):function(t){var i=o(t,n);return void 0===i&&i===e?a(t,n):r(e,i,3)}}},function(n,e,t){var r=t(85);n.exports=function(n,e,t){var o=null==n?void 0:r(n,e);return void 0===o?t:o}},function(n,e,t){var r=t(204),o=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,i=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(o,(function(n,t,r,o){e.push(r?o.replace(a,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var r=t(205);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(38);function o(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,o=e?e.apply(this,r):r[0],a=t.cache;if(a.has(o))return a.get(o);var i=n.apply(this,r);return t.cache=a.set(o,i)||a,i};return t.cache=new(o.Cache||r),t}o.Cache=r,n.exports=o},function(n,e,t){var r=t(207);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(15),o=t(208),a=t(5),i=t(42),s=r?r.prototype:void 0,c=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return o(e,n)+"";if(i(e))return c?c.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=Array(r);++t<r;)o[t]=e(n[t],t,n);return o}},function(n,e,t){var r=t(210),o=t(211);n.exports=function(n,e){return null!=n&&o(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(86),o=t(35),a=t(5),i=t(79),s=t(40),c=t(23);n.exports=function(n,e,t){for(var l=-1,u=(e=r(e,n)).length,p=!1;++l<u;){var d=c(e[l]);if(!(p=null!=n&&t(n,d)))break;n=n[d]}return p||++l!=u?p:!!(u=null==n?0:n.length)&&s(u)&&i(d,u)&&(a(n)||o(n))}},function(n,e,t){var r=t(213),o=t(214),a=t(41),i=t(23);n.exports=function(n){return a(n)?r(i(n)):o(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(85);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(43),o=t(216),a=t(218);n.exports=function(n,e){return a(o(n,e,r),n+"")}},function(n,e,t){var r=t(217),o=Math.max;n.exports=function(n,e,t){return e=o(void 0===e?n.length-1:e,0),function(){for(var a=arguments,i=-1,s=o(a.length-e,0),c=Array(s);++i<s;)c[i]=a[e+i];i=-1;for(var l=Array(e+1);++i<e;)l[i]=a[i];return l[e]=t(c),r(n,this,l)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(219),o=t(222)(r);n.exports=o},function(n,e,t){var r=t(220),o=t(221),a=t(43),i=o?function(n,e){return o(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:a;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(10),o=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=o},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var o=t(),a=16-(o-r);if(r=o,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(75),o=t(224),a=t(229),i=t(76),s=t(230),c=t(39);n.exports=function(n,e,t){var l=-1,u=o,p=n.length,d=!0,v=[],m=v;if(t)d=!1,u=a;else if(p>=200){var h=e?null:s(n);if(h)return c(h);d=!1,u=i,m=new r}else m=e?[]:v;n:for(;++l<p;){var f=n[l],g=e?e(f):f;if(f=t||0!==f?f:0,d&&g==g){for(var b=m.length;b--;)if(m[b]===g)continue n;e&&m.push(g),v.push(f)}else u(m,g,t)||(m!==v&&m.push(g),v.push(f))}return v}},function(n,e,t){var r=t(225);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(226),o=t(227),a=t(228);n.exports=function(n,e,t){return e==e?a(n,e,t):r(n,o,t)}},function(n,e){n.exports=function(n,e,t,r){for(var o=n.length,a=t+(r?1:-1);r?a--:++a<o;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,o=n.length;++r<o;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,o=null==n?0:n.length;++r<o;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(82),o=t(231),a=t(39),i=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:o;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(81),o=t(12);n.exports=function(n){return o(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(87)},function(n,e,t){"use strict";t(88)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(89)},function(n,e,t){var r=t(27),o=t(2),a=t(241);r({global:!0},{Reflect:{}}),a(o.Reflect,"Reflect",!0)},function(n,e,t){var r=t(13).f,o=t(6),a=t(17)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!o(n,a)&&r(n,a,{configurable:!0,value:e})}},function(n,e){},function(n,e){function t(n,e){for(var t=0,r=n.length-1;r>=0;r--){var o=n[r];"."===o?n.splice(r,1):".."===o?(n.splice(r,1),t++):t&&(n.splice(r,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function r(n,e){if(n.filter)return n.filter(e);for(var t=[],r=0;r<n.length;r++)e(n[r],r,n)&&t.push(n[r]);return t}e.resolve=function(){for(var n="",e=!1,o=arguments.length-1;o>=-1&&!e;o--){var a=o>=0?arguments[o]:process.cwd();if("string"!=typeof a)throw new TypeError("Arguments to path.resolve must be strings");a&&(n=a+"/"+n,e="/"===a.charAt(0))}return(e?"/":"")+(n=t(r(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var a=e.isAbsolute(n),i="/"===o(n,-1);return(n=t(r(n.split("/"),(function(n){return!!n})),!a).join("/"))||a||(n="."),n&&i&&(n+="/"),(a?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(r(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function r(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var o=r(n.split("/")),a=r(t.split("/")),i=Math.min(o.length,a.length),s=i,c=0;c<i;c++)if(o[c]!==a[c]){s=c;break}var l=[];for(c=s;c<o.length;c++)l.push("..");return(l=l.concat(a.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,r=-1,o=!0,a=n.length-1;a>=1;--a)if(47===(e=n.charCodeAt(a))){if(!o){r=a;break}}else o=!1;return-1===r?t?"/":".":t&&1===r?"/":n.slice(0,r)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,r=-1,o=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!o){t=e+1;break}}else-1===r&&(o=!1,r=e+1);return-1===r?"":n.slice(t,r)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,r=-1,o=!0,a=0,i=n.length-1;i>=0;--i){var s=n.charCodeAt(i);if(47!==s)-1===r&&(o=!1,r=i+1),46===s?-1===e?e=i:1!==a&&(a=1):-1!==e&&(a=-1);else if(!o){t=i+1;break}}return-1===e||-1===r||0===a||1===a&&e===r-1&&e===t+1?"":n.slice(e,r)};var o="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var r=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(r,"\\$&"):""};var o={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},a=/[&<>'"]/g;function i(n){return o[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(a,i)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var r=0;r<t.length;r++){var o=t[r];void 0!==e[o]&&(n[o]=e[o])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"name":"ejs","description":"Embedded JavaScript templates","keywords":["template","engine","ejs"],"version":"2.7.4","author":"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)","license":"Apache-2.0","main":"./lib/ejs.js","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"bugs":"https://github.com/mde/ejs/issues","homepage":"https://github.com/mde/ejs","dependencies":{},"devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"scripts":{"test":"mocha","postinstall":"node ./postinstall.js"}}')},function(n,e,t){"use strict";t(90)},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.8
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),o=Array.isArray;function a(n){return null==n}function i(n){return null!=n}function s(n){return!0===n}function c(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function l(n){return"function"==typeof n}function u(n){return null!==n&&"object"==typeof n}var p=Object.prototype.toString;function d(n){return"[object Object]"===p.call(n)}function v(n){return"[object RegExp]"===p.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function h(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===p?JSON.stringify(n,null,2):String(n)}function g(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),r=n.split(","),o=0;o<r.length;o++)t[r[o]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var y=b("key,ref,slot,slot-scope,is");function x(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var j=Object.prototype.hasOwnProperty;function k(n,e){return j.call(n,e)}function w(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var _=/-(\w)/g,S=w((function(n){return n.replace(_,(function(n,e){return e?e.toUpperCase():""}))})),I=w((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),E=/\B([A-Z])/g,C=w((function(n){return n.replace(E,"-$1").toLowerCase()}));var T=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function A(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function P(n,e){for(var t in e)n[t]=e[t];return n}function O(n){for(var e={},t=0;t<n.length;t++)n[t]&&P(e,n[t]);return e}function z(n,e,t){}var $=function(n,e,t){return!1},B=function(n){return n};function L(n,e){if(n===e)return!0;var t=u(n),r=u(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var o=Array.isArray(n),a=Array.isArray(e);if(o&&a)return n.length===e.length&&n.every((function(n,t){return L(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(o||a)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return L(n[t],e[t])}))}catch(n){return!1}}function R(n,e){for(var t=0;t<n.length;t++)if(L(n[t],e))return t;return-1}function U(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function D(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var M=["component","directive","filter"],N=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],F={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:$,isReservedAttr:$,isUnknownElement:$,getTagNamespace:z,parsePlatformTagName:B,mustUseProp:$,async:!0,_lifecycleHooks:N},V=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function q(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function H(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var K=new RegExp("[^".concat(V.source,".$_\\d]"));var Z="__proto__"in{},W="undefined"!=typeof window,J=W&&window.navigator.userAgent.toLowerCase(),G=J&&/msie|trident/.test(J),X=J&&J.indexOf("msie 9.0")>0,Y=J&&J.indexOf("edge/")>0;J&&J.indexOf("android");var Q=J&&/iphone|ipad|ipod|ios/.test(J);J&&/chrome\/\d+/.test(J),J&&/phantomjs/.test(J);var nn,en=J&&J.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(W)try{var on={};Object.defineProperty(on,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,on)}catch(n){}var an=function(){return void 0===nn&&(nn=!W&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=W&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function cn(n){return"function"==typeof n&&/native code/.test(n.toString())}var ln,un="undefined"!=typeof Symbol&&cn(Symbol)&&"undefined"!=typeof Reflect&&cn(Reflect.ownKeys);ln="undefined"!=typeof Set&&cn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var pn=null;function dn(n){void 0===n&&(n=null),n||pn&&pn._scope.off(),pn=n,n&&n._scope.on()}var vn=function(){function n(n,e,t,r,o,a,i,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=o,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),mn=function(n){void 0===n&&(n="");var e=new vn;return e.text=n,e.isComment=!0,e};function hn(n){return new vn(void 0,void 0,void 0,String(n))}function fn(n){var e=new vn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var gn=0,bn=function(){function n(){this.id=gn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){x(this.subs,n)},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.slice();for(var t=0,r=e.length;t<r;t++){e[t].update()}},n}();bn.target=null;var yn=[];function xn(n){yn.push(n),bn.target=n}function jn(){yn.pop(),bn.target=yn[yn.length-1]}var kn=Array.prototype,wn=Object.create(kn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=kn[n];H(wn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var o,a=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":o=t;break;case"splice":o=t.slice(2)}return o&&i.observeArray(o),i.dep.notify(),a}))}));var _n=Object.getOwnPropertyNames(wn),Sn={},In=!0;function En(n){In=n}var Cn={notify:z,depend:z,addSub:z,removeSub:z},Tn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?Cn:new bn,this.vmCount=0,H(n,"__ob__",this),o(n)){if(!t)if(Z)n.__proto__=wn;else for(var r=0,a=_n.length;r<a;r++){H(n,s=_n[r],wn[s])}e||this.observeArray(n)}else{var i=Object.keys(n);for(r=0;r<i.length;r++){var s;Pn(n,s=i[r],Sn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)An(n[e],!1,this.mock)},n}();function An(n,e,t){var r;if(!(!u(n)||Un(n)||n instanceof vn))return k(n,"__ob__")&&n.__ob__ instanceof Tn?r=n.__ob__:!In||!t&&an()||!o(n)&&!d(n)||!Object.isExtensible(n)||n.__v_skip||(r=new Tn(n,e,t)),r}function Pn(n,e,t,r,a,i){var s=new bn,c=Object.getOwnPropertyDescriptor(n,e);if(!c||!1!==c.configurable){var l=c&&c.get,u=c&&c.set;l&&!u||t!==Sn&&2!==arguments.length||(t=n[e]);var p=!a&&An(t,!1,i);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=l?l.call(n):t;return bn.target&&(s.depend(),p&&(p.dep.depend(),o(e)&&$n(e))),Un(e)&&!a?e.value:e},set:function(e){var r=l?l.call(n):t;if(D(r,e)){if(u)u.call(n,e);else{if(l)return;if(!a&&Un(r)&&!Un(e))return void(r.value=e);t=e}p=!a&&An(e,!1,i),s.notify()}}}),s}}function On(n,e,t){if(!Rn(n)){var r=n.__ob__;return o(n)&&m(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&An(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(Pn(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function zn(n,e){if(o(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Rn(n)||k(n,e)&&(delete n[e],t&&t.dep.notify())}}function $n(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),o(e)&&$n(e)}function Bn(n){return Ln(n,!0),H(n,"__v_isShallow",!0),n}function Ln(n,e){if(!Rn(n)){An(n,e,an());0}}function Rn(n){return!(!n||!n.__v_isReadonly)}function Un(n){return!(!n||!0!==n.__v_isRef)}function Dn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Un(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Un(r)&&!Un(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Mn;var Nn=function(){function n(n){void 0===n&&(n=!1),this.active=!0,this.effects=[],this.cleanups=[],!n&&Mn&&(this.parent=Mn,this.index=(Mn.scopes||(Mn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Mn;try{return Mn=this,n()}finally{Mn=e}}else 0},n.prototype.on=function(){Mn=this},n.prototype.off=function(){Mn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.active=!1}},n}();function Fn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Vn=w((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function qn(n,e){function t(){var n=t.fns;if(!o(n))return Ie(n,null,arguments,e,"v-on handler");for(var r=n.slice(),a=0;a<r.length;a++)Ie(r[a],null,arguments,e,"v-on handler")}return t.fns=n,t}function Hn(n,e,t,r,o,i){var c,l,u,p;for(c in n)l=n[c],u=e[c],p=Vn(c),a(l)||(a(u)?(a(l.fns)&&(l=n[c]=qn(l,i)),s(p.once)&&(l=n[c]=o(p.name,l,p.capture)),t(p.name,l,p.capture,p.passive,p.params)):l!==u&&(u.fns=l,n[c]=u));for(c in e)a(n[c])&&r((p=Vn(c)).name,e[c],p.capture)}function Kn(n,e,t){var r;n instanceof vn&&(n=n.data.hook||(n.data.hook={}));var o=n[e];function c(){t.apply(this,arguments),x(r.fns,c)}a(o)?r=qn([c]):i(o.fns)&&s(o.merged)?(r=o).fns.push(c):r=qn([o,c]),r.merged=!0,n[e]=r}function Zn(n,e,t,r,o){if(i(e)){if(k(e,t))return n[t]=e[t],o||delete e[t],!0;if(k(e,r))return n[t]=e[r],o||delete e[r],!0}return!1}function Wn(n){return c(n)?[hn(n)]:o(n)?function n(e,t){var r,l,u,p,d=[];for(r=0;r<e.length;r++)a(l=e[r])||"boolean"==typeof l||(u=d.length-1,p=d[u],o(l)?l.length>0&&(Jn((l=n(l,"".concat(t||"","_").concat(r)))[0])&&Jn(p)&&(d[u]=hn(p.text+l[0].text),l.shift()),d.push.apply(d,l)):c(l)?Jn(p)?d[u]=hn(p.text+l):""!==l&&d.push(hn(l)):Jn(l)&&Jn(p)?d[u]=hn(p.text+l.text):(s(e._isVList)&&i(l.tag)&&a(l.key)&&i(t)&&(l.key="__vlist".concat(t,"_").concat(r,"__")),d.push(l)));return d}(n):void 0}function Jn(n){return i(n)&&i(n.text)&&!1===n.isComment}function Gn(n,e){var t,r,a,s,c=null;if(o(n)||"string"==typeof n)for(c=new Array(n.length),t=0,r=n.length;t<r;t++)c[t]=e(n[t],t);else if("number"==typeof n)for(c=new Array(n),t=0;t<n;t++)c[t]=e(t+1,t);else if(u(n))if(un&&n[Symbol.iterator]){c=[];for(var l=n[Symbol.iterator](),p=l.next();!p.done;)c.push(e(p.value,c.length)),p=l.next()}else for(a=Object.keys(n),c=new Array(a.length),t=0,r=a.length;t<r;t++)s=a[t],c[t]=e(n[s],s,t);return i(c)||(c=[]),c._isVList=!0,c}function Xn(n,e,t,r){var o,a=this.$scopedSlots[n];a?(t=t||{},r&&(t=P(P({},r),t)),o=a(t)||(l(e)?e():e)):o=this.$slots[n]||(l(e)?e():e);var i=t&&t.slot;return i?this.$createElement("template",{slot:i},o):o}function Yn(n){return Tt(this.$options,"filters",n,!0)||B}function Qn(n,e){return o(n)?-1===n.indexOf(e):n!==e}function ne(n,e,t,r,o){var a=F.keyCodes[e]||t;return o&&r&&!F.keyCodes[e]?Qn(o,r):a?Qn(a,n):r?C(r)!==e:void 0===n}function ee(n,e,t,r,a){if(t)if(u(t)){o(t)&&(t=O(t));var i=void 0,s=function(o){if("class"===o||"style"===o||y(o))i=n;else{var s=n.attrs&&n.attrs.type;i=r||F.mustUseProp(e,s,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var c=S(o),l=C(o);c in i||l in i||(i[o]=t[o],a&&((n.on||(n.on={}))["update:".concat(o)]=function(n){t[o]=n}))};for(var c in t)s(c)}else;return n}function te(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||oe(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function re(n,e,t){return oe(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function oe(n,e,t){if(o(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&ae(n[r],"".concat(e,"_").concat(r),t);else ae(n,e,t)}function ae(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function ie(n,e){if(e)if(d(e)){var t=n.on=n.on?P({},n.on):{};for(var r in e){var o=t[r],a=e[r];t[r]=o?[].concat(o,a):a}}else;return n}function se(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var i=n[a];o(i)?se(i,e,t):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return r&&(e.$key=r),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function le(n,e){return"string"==typeof n?e+n:n}function ue(n){n._o=re,n._n=g,n._s=f,n._l=Gn,n._t=Xn,n._q=L,n._i=R,n._m=te,n._f=Yn,n._k=ne,n._b=ee,n._v=hn,n._e=mn,n._u=se,n._g=ie,n._d=ce,n._p=le}function pe(n,e){if(!n||!n.length)return{};for(var t={},r=0,o=n.length;r<o;r++){var a=n[r],i=a.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,a.context!==e&&a.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(a);else{var s=i.slot,c=t[s]||(t[s]=[]);"template"===a.tag?c.push.apply(c,a.children||[]):c.push(a)}}for(var l in t)t[l].every(de)&&delete t[l];return t}function de(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ve(n){return n.isComment&&n.asyncFactory}function me(n,e,t,o){var a,i=Object.keys(t).length>0,s=e?!!e.$stable:!i,c=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&o&&o!==r&&c===o.$key&&!i&&!o.$hasNormal)return o;for(var l in a={},e)e[l]&&"$"!==l[0]&&(a[l]=he(n,t,l,e[l]))}else a={};for(var u in t)u in a||(a[u]=fe(t,u));return e&&Object.isExtensible(e)&&(e._normalized=a),H(a,"$stable",s),H(a,"$key",c),H(a,"$hasNormal",i),a}function he(n,e,t,r){var a=function(){var e=pn;dn(n);var t=arguments.length?r.apply(null,arguments):r({}),a=(t=t&&"object"==typeof t&&!o(t)?[t]:Wn(t))&&t[0];return dn(e),t&&(!a||1===t.length&&a.isComment&&!ve(a))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function fe(n,e){return function(){return n[e]}}function ge(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};H(e,"_v_attr_proxy",!0),be(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||be(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||xe(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:T(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Dn(n,e,t)}))}}}function be(n,e,t,r,o){var a=!1;for(var i in e)i in n?e[i]!==t[i]&&(a=!0):(a=!0,ye(n,i,r,o));for(var i in n)i in e||(a=!0,delete n[i]);return a}function ye(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function xe(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var je=null;function ke(n,e){return(n.__esModule||un&&"Module"===n[Symbol.toStringTag])&&(n=n.default),u(n)?e.extend(n):n}function we(n){if(o(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||ve(t)))return t}}function _e(n,e,t,r,p,d){return(o(t)||c(t))&&(p=r,r=t,t=void 0),s(d)&&(p=2),function(n,e,t,r,c){if(i(t)&&i(t.__ob__))return mn();i(t)&&i(t.is)&&(e=t.is);if(!e)return mn();0;o(r)&&l(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===c?r=Wn(r):1===c&&(r=function(n){for(var e=0;e<n.length;e++)if(o(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var p,d;if("string"==typeof e){var v=void 0;d=n.$vnode&&n.$vnode.ns||F.getTagNamespace(e),p=F.isReservedTag(e)?new vn(F.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!i(v=Tt(n.$options,"components",e))?new vn(e,t,r,void 0,void 0,n):yt(v,t,n,r,e)}else p=yt(e,t,n,r);return o(p)?p:i(p)?(i(d)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(i(e.children))for(var o=0,c=e.children.length;o<c;o++){var l=e.children[o];i(l.tag)&&(a(l.ns)||s(r)&&"svg"!==l.tag)&&n(l,t,r)}}(p,d),i(t)&&function(n){u(n.style)&&Ne(n.style);u(n.class)&&Ne(n.class)}(t),p):mn()}(n,e,t,r,p)}function Se(n,e,t){xn();try{if(e)for(var r=e;r=r.$parent;){var o=r.$options.errorCaptured;if(o)for(var a=0;a<o.length;a++)try{if(!1===o[a].call(r,n,e,t))return}catch(n){Ee(n,r,"errorCaptured hook")}}Ee(n,e,t)}finally{jn()}}function Ie(n,e,t,r,o){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&h(a)&&!a._handled&&(a.catch((function(n){return Se(n,r,o+" (Promise/async)")})),a._handled=!0)}catch(n){Se(n,r,o)}return a}function Ee(n,e,t){if(F.errorHandler)try{return F.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ce(e,null,"config.errorHandler")}Ce(n,e,t)}function Ce(n,e,t){if(!W||"undefined"==typeof console)throw n;console.error(n)}var Te,Ae=!1,Pe=[],Oe=!1;function ze(){Oe=!1;var n=Pe.slice(0);Pe.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&cn(Promise)){var $e=Promise.resolve();Te=function(){$e.then(ze),Q&&setTimeout(z)},Ae=!0}else if(G||"undefined"==typeof MutationObserver||!cn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Te="undefined"!=typeof setImmediate&&cn(setImmediate)?function(){setImmediate(ze)}:function(){setTimeout(ze,0)};else{var Be=1,Le=new MutationObserver(ze),Re=document.createTextNode(String(Be));Le.observe(Re,{characterData:!0}),Te=function(){Be=(Be+1)%2,Re.data=String(Be)},Ae=!0}function Ue(n,e){var t;if(Pe.push((function(){if(n)try{n.call(e)}catch(n){Se(n,e,"nextTick")}else t&&t(e)})),Oe||(Oe=!0,Te()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function De(n){return function(e,t){if(void 0===t&&(t=pn),t)return function(n,e,t){var r=n.$options;r[e]=St(r[e],t)}(t,n,e)}}De("beforeMount"),De("mounted"),De("beforeUpdate"),De("updated"),De("beforeDestroy"),De("destroyed"),De("errorCaptured"),De("activated"),De("deactivated"),De("serverPrefetch"),De("renderTracked"),De("renderTriggered");var Me=new ln;function Ne(n){return function n(e,t){var r,a,i=o(e);if(!i&&!u(e)||Object.isFrozen(e)||e instanceof vn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(i)for(r=e.length;r--;)n(e[r],t);else if(Un(e))n(e.value,t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,Me),Me.clear(),n}var Fe,Ve=0,qe=function(){function n(n,e,t,r,o){var a,i;a=this,void 0===(i=Mn||(n?n._scope:void 0))&&(i=Mn),i&&i.active&&i.effects.push(a),(this.vm=n)&&o&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ve,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ln,this.newDepIds=new ln,this.expression="",l(e)?this.getter=e:(this.getter=function(n){if(!K.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=z)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;xn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Se(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ne(n),jn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():pt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||u(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ie(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function He(n,e){Fe.$on(n,e)}function Ke(n,e){Fe.$off(n,e)}function Ze(n,e){var t=Fe;return function r(){var o=e.apply(null,arguments);null!==o&&t.$off(n,r)}}function We(n,e,t){Fe=n,Hn(e,t||{},He,Ke,Ze,n),Fe=void 0}var Je=null;function Ge(n){var e=Je;return Je=n,function(){Je=e}}function Xe(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ye(n,e){if(e){if(n._directInactive=!1,Xe(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ye(n.$children[t]);Qe(n,"activated")}}function Qe(n,e,t,r){void 0===r&&(r=!0),xn();var o=pn;r&&dn(n);var a=n.$options[e],i="".concat(e," hook");if(a)for(var s=0,c=a.length;s<c;s++)Ie(a[s],n,t||null,n,i);n._hasHookEvent&&n.$emit("hook:"+e),r&&dn(o),jn()}var nt=[],et=[],tt={},rt=!1,ot=!1,at=0;var it=0,st=Date.now;if(W&&!G){var ct=window.performance;ct&&"function"==typeof ct.now&&st()>document.createEvent("Event").timeStamp&&(st=function(){return ct.now()})}var lt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ut(){var n,e;for(it=st(),ot=!0,nt.sort(lt),at=0;at<nt.length;at++)(n=nt[at]).before&&n.before(),e=n.id,tt[e]=null,n.run();var t=et.slice(),r=nt.slice();at=nt.length=et.length=0,tt={},rt=ot=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ye(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&Qe(r,"updated")}}(r),sn&&F.devtools&&sn.emit("flush")}function pt(n){var e=n.id;if(null==tt[e]&&(n!==bn.target||!n.noRecurse)){if(tt[e]=!0,ot){for(var t=nt.length-1;t>at&&nt[t].id>n.id;)t--;nt.splice(t+1,0,n)}else nt.push(n);rt||(rt=!0,Ue(ut))}}function dt(n,e){if(n){for(var t=Object.create(null),r=un?Reflect.ownKeys(n):Object.keys(n),o=0;o<r.length;o++){var a=r[o];if("__ob__"!==a){var i=n[a].from;if(i in e._provided)t[a]=e._provided[i];else if("default"in n[a]){var s=n[a].default;t[a]=l(s)?s.call(e):s}else 0}}return t}}function vt(n,e,t,a,i){var c,l=this,u=i.options;k(a,"_uid")?(c=Object.create(a))._original=a:(c=a,a=a._original);var p=s(u._compiled),d=!p;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||r,this.injections=dt(u.inject,a),this.slots=function(){return l.$slots||me(a,n.scopedSlots,l.$slots=pe(t,a)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return me(a,n.scopedSlots,this.slots())}}),p&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=me(a,n.scopedSlots,this.$slots)),u._scopeId?this._c=function(n,e,t,r){var i=_e(c,n,e,t,r,d);return i&&!o(i)&&(i.fnScopeId=u._scopeId,i.fnContext=a),i}:this._c=function(n,e,t,r){return _e(c,n,e,t,r,d)}}function mt(n,e,t,r,o){var a=fn(n);return a.fnContext=t,a.fnOptions=r,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function ht(n,e){for(var t in e)n[S(t)]=e[t]}function ft(n){return n.name||n.__name||n._componentTag}ue(vt.prototype);var gt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;gt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;i(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Je)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,o,a){var i=o.data.scopedSlots,s=n.$scopedSlots,c=!!(i&&!i.$stable||s!==r&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key||!i&&n.$scopedSlots.$key),l=!!(a||n.$options._renderChildren||c),u=n.$vnode;n.$options._parentVnode=o,n.$vnode=o,n._vnode&&(n._vnode.parent=o),n.$options._renderChildren=a;var p=o.data.attrs||r;n._attrsProxy&&be(n._attrsProxy,p,u.data&&u.data.attrs||r,n,"$attrs")&&(l=!0),n.$attrs=p,t=t||r;var d=n.$options._parentListeners;if(n._listenersProxy&&be(n._listenersProxy,t,d||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,We(n,t,d),e&&n.$options.props){En(!1);for(var v=n._props,m=n.$options._propKeys||[],h=0;h<m.length;h++){var f=m[h],g=n.$options.props;v[f]=At(f,g,e,n)}En(!0),n.$options.propsData=e}l&&(n.$slots=pe(a,o.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,Qe(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,et.push(e)):Ye(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Xe(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);Qe(e,"deactivated")}}(e,!0):e.$destroy())}},bt=Object.keys(gt);function yt(n,e,t,c,l){if(!a(n)){var p=t.$options._base;if(u(n)&&(n=p.extend(n)),"function"==typeof n){var d;if(a(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=je;if(t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var r=n.owners=[t],o=!0,c=null,l=null;t.$on("hook:destroyed",(function(){return x(r,t)}));var p=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==c&&(clearTimeout(c),c=null),null!==l&&(clearTimeout(l),l=null))},d=U((function(t){n.resolved=ke(t,e),o?r.length=0:p(!0)})),v=U((function(e){i(n.errorComp)&&(n.error=!0,p(!0))})),m=n(d,v);return u(m)&&(h(m)?a(n.resolved)&&m.then(d,v):h(m.component)&&(m.component.then(d,v),i(m.error)&&(n.errorComp=ke(m.error,e)),i(m.loading)&&(n.loadingComp=ke(m.loading,e),0===m.delay?n.loading=!0:c=setTimeout((function(){c=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,p(!1))}),m.delay||200)),i(m.timeout)&&(l=setTimeout((function(){l=null,a(n.resolved)&&v(null)}),m.timeout)))),o=!1,n.loading?n.loadingComp:n.resolved}}(d=n,p)))return function(n,e,t,r,o){var a=mn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:r,tag:o},a}(d,e,t,c,l);e=e||{},qt(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),s=a[r],c=e.model.callback;i(s)?(o(s)?-1===s.indexOf(c):s!==c)&&(a[r]=[c].concat(s)):a[r]=c}(n.options,e);var v=function(n,e,t){var r=e.options.props;if(!a(r)){var o={},s=n.attrs,c=n.props;if(i(s)||i(c))for(var l in r){var u=C(l);Zn(o,c,l,u,!0)||Zn(o,s,l,u,!1)}return o}}(e,n);if(s(n.options.functional))return function(n,e,t,a,s){var c=n.options,l={},u=c.props;if(i(u))for(var p in u)l[p]=At(p,u,e||r);else i(t.attrs)&&ht(l,t.attrs),i(t.props)&&ht(l,t.props);var d=new vt(t,l,s,a,n),v=c.render.call(null,d._c,d);if(v instanceof vn)return mt(v,t,d.parent,c,d);if(o(v)){for(var m=Wn(v)||[],h=new Array(m.length),f=0;f<m.length;f++)h[f]=mt(m[f],t,d.parent,c,d);return h}}(n,v,e,t,c);var m=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<bt.length;t++){var r=bt[t],o=e[r],a=gt[r];o===a||o&&o._merged||(e[r]=o?xt(a,o):a)}}(e);var g=ft(n.options)||l;return new vn("vue-component-".concat(n.cid).concat(g?"-".concat(g):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:v,listeners:m,tag:l,children:c},d)}}}function xt(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var jt=z,kt=F.optionMergeStrategies;function wt(n,e){if(!e)return n;for(var t,r,o,a=un?Reflect.ownKeys(e):Object.keys(e),i=0;i<a.length;i++)"__ob__"!==(t=a[i])&&(r=n[t],o=e[t],k(n,t)?r!==o&&d(r)&&d(o)&&wt(r,o):On(n,t,o));return n}function _t(n,e,t){return t?function(){var r=l(e)?e.call(t,t):e,o=l(n)?n.call(t,t):n;return r?wt(r,o):o}:e?n?function(){return wt(l(e)?e.call(this,this):e,l(n)?n.call(this,this):n)}:e:n}function St(n,e){var t=e?n?n.concat(e):o(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function It(n,e,t,r){var o=Object.create(n||null);return e?P(o,e):o}kt.data=function(n,e,t){return t?_t(n,e,t):e&&"function"!=typeof e?n:_t(n,e)},N.forEach((function(n){kt[n]=St})),M.forEach((function(n){kt[n+"s"]=It})),kt.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var i in P(a,n),e){var s=a[i],c=e[i];s&&!o(s)&&(s=[s]),a[i]=s?s.concat(c):o(c)?c:[c]}return a},kt.props=kt.methods=kt.inject=kt.computed=function(n,e,t,r){if(!n)return e;var o=Object.create(null);return P(o,n),e&&P(o,e),o},kt.provide=_t;var Et=function(n,e){return void 0===e?n:e};function Ct(n,e,t){if(l(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,i={};if(o(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(i[S(a)]={type:null});else if(d(t))for(var s in t)a=t[s],i[S(s)]=d(a)?a:{type:a};else 0;n.props=i}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(o(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(d(t))for(var i in t){var s=t[i];r[i]=d(s)?P({from:i},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];l(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Ct(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=Ct(n,e.mixins[r],t);var i,s={};for(i in n)c(i);for(i in e)k(n,i)||c(i);function c(r){var o=kt[r]||Et;s[r]=o(n[r],e[r],t,r)}return s}function Tt(n,e,t,r){if("string"==typeof t){var o=n[e];if(k(o,t))return o[t];var a=S(t);if(k(o,a))return o[a];var i=I(a);return k(o,i)?o[i]:o[t]||o[a]||o[i]}}function At(n,e,t,r){var o=e[n],a=!k(t,n),i=t[n],s=$t(Boolean,o.type);if(s>-1)if(a&&!k(o,"default"))i=!1;else if(""===i||i===C(n)){var c=$t(String,o.type);(c<0||s<c)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!k(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return l(r)&&"Function"!==Ot(e.type)?r.call(n):r}(r,o,n);var u=In;En(!0),An(i),En(u)}return i}var Pt=/^\s*function (\w+)/;function Ot(n){var e=n&&n.toString().match(Pt);return e?e[1]:""}function zt(n,e){return Ot(n)===Ot(e)}function $t(n,e){if(!o(e))return zt(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(zt(e[t],n))return t;return-1}var Bt={enumerable:!0,configurable:!0,get:z,set:z};function Lt(n,e,t){Bt.get=function(){return this[e][t]},Bt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Bt)}function Rt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=Bn({}),o=n.$options._propKeys=[];n.$parent&&En(!1);var a=function(a){o.push(a);var i=At(a,e,t,n);Pn(r,a,i),a in n||Lt(n,"_props",a)};for(var i in e)a(i);En(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=ge(n);dn(n),xn();var o=Ie(t,null,[n._props||Bn({}),r],n,"setup");if(jn(),dn(),l(o))e.render=o;else if(u(o))if(n._setupState=o,o.__sfc){var a=n._setupProxy={};for(var i in o)"__sfc"!==i&&Dn(a,o,i)}else for(var i in o)q(i)||Dn(n,o,i);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?z:T(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;d(e=n._data=l(e)?function(n,e){xn();try{return n.call(e,e)}catch(n){return Se(n,e,"data()"),{}}finally{jn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,o=(n.$options.methods,t.length);for(;o--;){var a=t[o];0,r&&k(r,a)||q(a)||Lt(n,"_data",a)}var i=An(e);i&&i.vmCount++}(n);else{var t=An(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=an();for(var o in e){var a=e[o],i=l(a)?a:a.get;0,r||(t[o]=new qe(n,i||z,z,Ut)),o in n||Dt(n,o,a)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(o(r))for(var a=0;a<r.length;a++)Ft(n,t,r[a]);else Ft(n,t,r)}}(n,e.watch)}var Ut={lazy:!0};function Dt(n,e,t){var r=!an();l(t)?(Bt.get=r?Mt(e):Nt(t),Bt.set=z):(Bt.get=t.get?r&&!1!==t.cache?Mt(e):Nt(t.get):z,Bt.set=t.set||z),Object.defineProperty(n,e,Bt)}function Mt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),bn.target&&e.depend(),e.value}}function Nt(n){return function(){return n.call(this,this)}}function Ft(n,e,t,r){return d(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Vt=0;function qt(n){var e=n.options;if(n.super){var t=qt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var o in t)t[o]!==r[o]&&(e||(e={}),e[o]=t[o]);return e}(n);r&&P(n.extendOptions,r),(e=n.options=Ct(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Ht(n){this._init(n)}function Kt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,o=n._Ctor||(n._Ctor={});if(o[r])return o[r];var a=ft(n)||ft(t.options);var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=Ct(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)Lt(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)Dt(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,M.forEach((function(n){i[n]=t[n]})),a&&(i.options.components[a]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=P({},i.options),o[r]=i,i}}function Zt(n){return n&&(ft(n.Ctor.options)||n.tag)}function Wt(n,e){return o(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!v(n)&&n.test(e)}function Jt(n,e){var t=n.cache,r=n.keys,o=n._vnode;for(var a in t){var i=t[a];if(i){var s=i.name;s&&!e(s)&&Gt(t,a,r,o)}}}function Gt(n,e,t,r){var o=n[e];!o||r&&o.tag===r.tag||o.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Vt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Nn(!0),n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var o=r.componentOptions;t.propsData=o.propsData,t._parentListeners=o.listeners,t._renderChildren=o.children,t._componentTag=o.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Ct(qt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&We(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,o=t&&t.context;n.$slots=pe(e._renderChildren,o),n.$scopedSlots=t?me(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,o){return _e(n,e,t,r,o,!1)},n.$createElement=function(e,t,r,o){return _e(n,e,t,r,o,!0)};var a=t&&t.data;Pn(n,"$attrs",a&&a.attrs||r,null,!0),Pn(n,"$listeners",e._parentListeners||r,null,!0)}(e),Qe(e,"beforeCreate",void 0,!1),function(n){var e=dt(n.$options.inject,n);e&&(En(!1),Object.keys(e).forEach((function(t){Pn(n,t,e[t])})),En(!0))}(e),Rt(e),function(n){var e=n.$options.provide;if(e){var t=l(e)?e.call(n):e;if(!u(t))return;for(var r=Fn(n),o=un?Reflect.ownKeys(t):Object.keys(t),a=0;a<o.length;a++){var i=o[a];Object.defineProperty(r,i,Object.getOwnPropertyDescriptor(t,i))}}}(e),Qe(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Ht),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=On,n.prototype.$delete=zn,n.prototype.$watch=function(n,e,t){if(d(e))return Ft(this,n,e,t);(t=t||{}).user=!0;var r=new qe(this,n,e,t);if(t.immediate){var o='callback for immediate watcher "'.concat(r.expression,'"');xn(),Ie(e,this,[r.value],this,o),jn()}return function(){r.teardown()}}}(Ht),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(o(n))for(var a=0,i=n.length;a<i;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(o(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var i,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var c=s.length;c--;)if((i=s[c])===e||i.fn===e){s.splice(c,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?A(t):t;for(var r=A(arguments,1),o='event handler for "'.concat(n,'"'),a=0,i=t.length;a<i;a++)Ie(t[a],e,r,e,o)}return e}}(Ht),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,o=t._vnode,a=Ge(t);t._vnode=n,t.$el=o?t.__patch__(o,n):t.__patch__(t.$el,n,e,!1),a(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){Qe(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),Qe(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Ht),function(n){ue(n.prototype),n.prototype.$nextTick=function(n){return Ue(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,a=t._parentVnode;a&&e._isMounted&&(e.$scopedSlots=me(e.$parent,a.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&xe(e._slotsProxy,e.$scopedSlots)),e.$vnode=a;try{dn(e),je=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Se(t,e,"render"),n=e._vnode}finally{je=null,dn()}return o(n)&&1===n.length&&(n=n[0]),n instanceof vn||(n=mn()),n.parent=a,n}}(Ht);var Xt=[String,RegExp,Array],Yt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Xt,exclude:Xt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var o=t.tag,a=t.componentInstance,i=t.componentOptions;n[r]={name:Zt(i),tag:o,componentInstance:a},e.push(r),this.max&&e.length>parseInt(this.max)&&Gt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Gt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Jt(n,(function(n){return Wt(e,n)}))})),this.$watch("exclude",(function(e){Jt(n,(function(n){return!Wt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=we(n),t=e&&e.componentOptions;if(t){var r=Zt(t),o=this.include,a=this.exclude;if(o&&(!r||!Wt(o,r))||a&&r&&Wt(a,r))return e;var i=this.cache,s=this.keys,c=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;i[c]?(e.componentInstance=i[c].componentInstance,x(s,c),s.push(c)):(this.vnodeToCache=e,this.keyToCache=c),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return F}};Object.defineProperty(n,"config",e),n.util={warn:jt,extend:P,mergeOptions:Ct,defineReactive:Pn},n.set=On,n.delete=zn,n.nextTick=Ue,n.observable=function(n){return An(n),n},n.options=Object.create(null),M.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,P(n.options.components,Yt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=A(arguments,1);return t.unshift(this),l(n.install)?n.install.apply(n,t):l(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Ct(this.options,n),this}}(n),Kt(n),function(n){M.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&l(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Ht),Object.defineProperty(Ht.prototype,"$isServer",{get:an}),Object.defineProperty(Ht.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Ht,"FunctionalRenderContext",{value:vt}),Ht.version="2.7.8";var Qt=b("style,class"),nr=b("input,textarea,option,select,progress"),er=b("contenteditable,draggable,spellcheck"),tr=b("events,caret,typing,plaintext-only"),rr=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),or="http://www.w3.org/1999/xlink",ar=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},ir=function(n){return ar(n)?n.slice(6,n.length):""},sr=function(n){return null==n||!1===n};function cr(n){for(var e=n.data,t=n,r=n;i(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=lr(r.data,e));for(;i(t=t.parent);)t&&t.data&&(e=lr(e,t.data));return function(n,e){if(i(n)||i(e))return ur(n,pr(e));return""}(e.staticClass,e.class)}function lr(n,e){return{staticClass:ur(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function ur(n,e){return n?e?n+" "+e:n:e||""}function pr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,o=n.length;r<o;r++)i(e=pr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):u(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var dr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},vr=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),mr=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),hr=function(n){return vr(n)||mr(n)};var fr=Object.create(null);var gr=b("text,number,password,search,email,tel,url");var br=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(dr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),yr={create:function(n,e){xr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(xr(n,!0),xr(e))},destroy:function(n){xr(n,!0)}};function xr(n,e){var t=n.data.ref;if(i(t)){var r=n.context,a=n.componentInstance||n.elm,s=e?null:a,c=e?void 0:a;if(l(t))Ie(t,r,[s],r,"template ref function");else{var u=n.data.refInFor,p="string"==typeof t||"number"==typeof t,d=Un(t),v=r.$refs;if(p||d)if(u){var m=p?v[t]:t.value;e?o(m)&&x(m,a):o(m)?m.includes(a)||m.push(a):p?(v[t]=[a],jr(r,t,v[t])):t.value=[a]}else if(p){if(e&&v[t]!==a)return;v[t]=c,jr(r,t,s)}else if(d){if(e&&t.value!==a)return;t.value=s}else 0}}}function jr(n,e,t){var r=n._setupState;r&&k(r,e)&&(Un(r[e])?r[e].value=t:r[e]=t)}var kr=new vn("",{},[]),wr=["create","activate","update","remove","destroy"];function _r(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=i(t=n.data)&&i(t=t.attrs)&&t.type,o=i(t=e.data)&&i(t=t.attrs)&&t.type;return r===o||gr(r)&&gr(o)}(n,e)||s(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function Sr(n,e,t){var r,o,a={};for(r=e;r<=t;++r)i(o=n[r].key)&&(a[o]=r);return a}var Ir={create:Er,update:Er,destroy:function(n){Er(n,kr)}};function Er(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,o,a=n===kr,i=e===kr,s=Tr(n.data.directives,n.context),c=Tr(e.data.directives,e.context),l=[],u=[];for(t in c)r=s[t],o=c[t],r?(o.oldValue=r.value,o.oldArg=r.arg,Pr(o,"update",e,n),o.def&&o.def.componentUpdated&&u.push(o)):(Pr(o,"bind",e,n),o.def&&o.def.inserted&&l.push(o));if(l.length){var p=function(){for(var t=0;t<l.length;t++)Pr(l[t],"inserted",e,n)};a?Kn(e,"insert",p):p()}u.length&&Kn(e,"postpatch",(function(){for(var t=0;t<u.length;t++)Pr(u[t],"componentUpdated",e,n)}));if(!a)for(t in s)c[t]||Pr(s[t],"unbind",n,n,i)}(n,e)}var Cr=Object.create(null);function Tr(n,e){var t,r,o=Object.create(null);if(!n)return o;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=Cr),o[Ar(r)]=r,e._setupState&&e._setupState.__sfc&&(r.def=r.def||Tt(e,"_setupState","v-"+r.name)),r.def=r.def||Tt(e.$options,"directives",r.name);return o}function Ar(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Pr(n,e,t,r,o){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,r,o)}catch(r){Se(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Or=[yr,Ir];function zr(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,o,c=e.elm,l=n.data.attrs||{},u=e.data.attrs||{};for(r in(i(u.__ob__)||s(u._v_attr_proxy))&&(u=e.data.attrs=P({},u)),u)o=u[r],l[r]!==o&&$r(c,r,o,e.data.pre);for(r in(G||Y)&&u.value!==l.value&&$r(c,"value",u.value),l)a(u[r])&&(ar(r)?c.removeAttributeNS(or,ir(r)):er(r)||c.removeAttribute(r))}}function $r(n,e,t,r){r||n.tagName.indexOf("-")>-1?Br(n,e,t):rr(e)?sr(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):er(e)?n.setAttribute(e,function(n,e){return sr(e)||"false"===e?"false":"contenteditable"===n&&tr(e)?e:"true"}(e,t)):ar(e)?sr(t)?n.removeAttributeNS(or,ir(e)):n.setAttributeNS(or,e,t):Br(n,e,t)}function Br(n,e,t){if(sr(t))n.removeAttribute(e);else{if(G&&!X&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Lr={create:zr,update:zr};function Rr(n,e){var t=e.elm,r=e.data,o=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(o)||a(o.staticClass)&&a(o.class)))){var s=cr(e),c=t._transitionClasses;i(c)&&(s=ur(s,pr(c))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Ur,Dr={create:Rr,update:Rr};function Mr(n,e,t){var r=Ur;return function o(){var a=e.apply(null,arguments);null!==a&&Vr(n,o,t,r)}}var Nr=Ae&&!(en&&Number(en[1])<=53);function Fr(n,e,t,r){if(Nr){var o=it,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=o||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}Ur.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function Vr(n,e,t,r){(r||Ur).removeEventListener(n,e._wrapper||e,t)}function qr(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Ur=e.elm||n.elm,function(n){if(i(n.__r)){var e=G?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Hn(t,r,Fr,Vr,Mr,e.context),Ur=void 0}}var Hr,Kr={create:qr,update:qr,destroy:function(n){return qr(n,kr)}};function Zr(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,o=e.elm,c=n.data.domProps||{},l=e.data.domProps||{};for(t in(i(l.__ob__)||s(l._v_attr_proxy))&&(l=e.data.domProps=P({},l)),c)t in l||(o[t]="");for(t in l){if(r=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===c[t])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===t&&"PROGRESS"!==o.tagName){o._value=r;var u=a(r)?"":String(r);Wr(o,u)&&(o.value=u)}else if("innerHTML"===t&&mr(o.tagName)&&a(o.innerHTML)){(Hr=Hr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var p=Hr.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;p.firstChild;)o.appendChild(p.firstChild)}else if(r!==c[t])try{o[t]=r}catch(n){}}}}function Wr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(i(r)){if(r.number)return g(t)!==g(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Jr={create:Zr,update:Zr},Gr=w((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Xr(n){var e=Yr(n.style);return n.staticStyle?P(n.staticStyle,e):e}function Yr(n){return Array.isArray(n)?O(n):"string"==typeof n?Gr(n):n}var Qr,no=/^--/,eo=/\s*!important$/,to=function(n,e,t){if(no.test(e))n.style.setProperty(e,t);else if(eo.test(t))n.style.setProperty(C(e),t.replace(eo,""),"important");else{var r=oo(e);if(Array.isArray(t))for(var o=0,a=t.length;o<a;o++)n.style[r]=t[o];else n.style[r]=t}},ro=["Webkit","Moz","ms"],oo=w((function(n){if(Qr=Qr||document.createElement("div").style,"filter"!==(n=S(n))&&n in Qr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ro.length;t++){var r=ro[t]+e;if(r in Qr)return r}}));function ao(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var o,s,c=e.elm,l=r.staticStyle,u=r.normalizedStyle||r.style||{},p=l||u,d=Yr(e.data.style)||{};e.data.normalizedStyle=i(d.__ob__)?P({},d):d;var v=function(n,e){var t,r={};if(e)for(var o=n;o.componentInstance;)(o=o.componentInstance._vnode)&&o.data&&(t=Xr(o.data))&&P(r,t);(t=Xr(n.data))&&P(r,t);for(var a=n;a=a.parent;)a.data&&(t=Xr(a.data))&&P(r,t);return r}(e,!0);for(s in p)a(v[s])&&to(c,s,"");for(s in v)(o=v[s])!==p[s]&&to(c,s,null==o?"":o)}}var io={create:ao,update:ao},so=/\s+/;function co(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(so).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function lo(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(so).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function uo(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&P(e,po(n.name||"v")),P(e,n),e}return"string"==typeof n?po(n):void 0}}var po=w((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),vo=W&&!X,mo="transition",ho="transitionend",fo="animation",go="animationend";vo&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(mo="WebkitTransition",ho="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(fo="WebkitAnimation",go="webkitAnimationEnd"));var bo=W?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function yo(n){bo((function(){bo(n)}))}function xo(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),co(n,e))}function jo(n,e){n._transitionClasses&&x(n._transitionClasses,e),lo(n,e)}function ko(n,e,t){var r=_o(n,e),o=r.type,a=r.timeout,i=r.propCount;if(!o)return t();var s="transition"===o?ho:go,c=0,l=function(){n.removeEventListener(s,u),t()},u=function(e){e.target===n&&++c>=i&&l()};setTimeout((function(){c<i&&l()}),a+1),n.addEventListener(s,u)}var wo=/\b(transform|all)(,|$)/;function _o(n,e){var t,r=window.getComputedStyle(n),o=(r[mo+"Delay"]||"").split(", "),a=(r[mo+"Duration"]||"").split(", "),i=So(o,a),s=(r[fo+"Delay"]||"").split(", "),c=(r[fo+"Duration"]||"").split(", "),l=So(s,c),u=0,p=0;return"transition"===e?i>0&&(t="transition",u=i,p=a.length):"animation"===e?l>0&&(t="animation",u=l,p=c.length):p=(t=(u=Math.max(i,l))>0?i>l?"transition":"animation":null)?"transition"===t?a.length:c.length:0,{type:t,timeout:u,propCount:p,hasTransform:"transition"===t&&wo.test(r[mo+"Property"])}}function So(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Io(e)+Io(n[t])})))}function Io(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Eo(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=uo(n.data.transition);if(!a(r)&&!i(t._enterCb)&&1===t.nodeType){for(var o=r.css,s=r.type,c=r.enterClass,p=r.enterToClass,d=r.enterActiveClass,v=r.appearClass,m=r.appearToClass,h=r.appearActiveClass,f=r.beforeEnter,b=r.enter,y=r.afterEnter,x=r.enterCancelled,j=r.beforeAppear,k=r.appear,w=r.afterAppear,_=r.appearCancelled,S=r.duration,I=Je,E=Je.$vnode;E&&E.parent;)I=E.context,E=E.parent;var C=!I._isMounted||!n.isRootInsert;if(!C||k||""===k){var T=C&&v?v:c,A=C&&h?h:d,P=C&&m?m:p,O=C&&j||f,z=C&&l(k)?k:b,$=C&&w||y,B=C&&_||x,L=g(u(S)?S.enter:S);0;var R=!1!==o&&!X,D=Ao(z),M=t._enterCb=U((function(){R&&(jo(t,P),jo(t,A)),M.cancelled?(R&&jo(t,T),B&&B(t)):$&&$(t),t._enterCb=null}));n.data.show||Kn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),z&&z(t,M)})),O&&O(t),R&&(xo(t,T),xo(t,A),yo((function(){jo(t,T),M.cancelled||(xo(t,P),D||(To(L)?setTimeout(M,L):ko(t,s,M)))}))),n.data.show&&(e&&e(),z&&z(t,M)),R||D||M()}}}function Co(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=uo(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var o=r.css,s=r.type,c=r.leaveClass,l=r.leaveToClass,p=r.leaveActiveClass,d=r.beforeLeave,v=r.leave,m=r.afterLeave,h=r.leaveCancelled,f=r.delayLeave,b=r.duration,y=!1!==o&&!X,x=Ao(v),j=g(u(b)?b.leave:b);0;var k=t._leaveCb=U((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(jo(t,l),jo(t,p)),k.cancelled?(y&&jo(t,c),h&&h(t)):(e(),m&&m(t)),t._leaveCb=null}));f?f(w):w()}function w(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),d&&d(t),y&&(xo(t,c),xo(t,p),yo((function(){jo(t,c),k.cancelled||(xo(t,l),x||(To(j)?setTimeout(k,j):ko(t,s,k)))}))),v&&v(t,k),y||x||k())}}function To(n){return"number"==typeof n&&!isNaN(n)}function Ao(n){if(a(n))return!1;var e=n.fns;return i(e)?Ao(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Po(n,e){!0!==e.data.show&&Eo(e)}var Oo=function(n){var e,t,r={},l=n.modules,u=n.nodeOps;for(e=0;e<wr.length;++e)for(r[wr[e]]=[],t=0;t<l.length;++t)i(l[t][wr[e]])&&r[wr[e]].push(l[t][wr[e]]);function p(n){var e=u.parentNode(n);i(e)&&u.removeChild(e,n)}function d(n,e,t,o,a,c,l){if(i(n.elm)&&i(c)&&(n=c[l]=fn(n)),n.isRootInsert=!a,!function(n,e,t,o){var a=n.data;if(i(a)){var c=i(n.componentInstance)&&a.keepAlive;if(i(a=a.hook)&&i(a=a.init)&&a(n,!1),i(n.componentInstance))return v(n,e),m(t,n.elm,o),s(c)&&function(n,e,t,o){var a,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,i(a=s.data)&&i(a=a.transition)){for(a=0;a<r.activate.length;++a)r.activate[a](kr,s);e.push(s);break}m(t,n.elm,o)}(n,e,t,o),!0}}(n,e,t,o)){var p=n.data,d=n.children,f=n.tag;i(f)?(n.elm=n.ns?u.createElementNS(n.ns,f):u.createElement(f,n),y(n),h(n,d,e),i(p)&&g(n,e),m(t,n.elm,o)):s(n.isComment)?(n.elm=u.createComment(n.text),m(t,n.elm,o)):(n.elm=u.createTextNode(n.text),m(t,n.elm,o))}}function v(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(g(n,e),y(n)):(xr(n),e.push(n))}function m(n,e,t){i(n)&&(i(t)?u.parentNode(t)===n&&u.insertBefore(n,e,t):u.appendChild(n,e))}function h(n,e,t){if(o(e)){0;for(var r=0;r<e.length;++r)d(e[r],t,n.elm,null,!0,e,r)}else c(n.text)&&u.appendChild(n.elm,u.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function g(n,t){for(var o=0;o<r.create.length;++o)r.create[o](kr,n);i(e=n.data.hook)&&(i(e.create)&&e.create(kr,n),i(e.insert)&&t.push(n))}function y(n){var e;if(i(e=n.fnScopeId))u.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e),t=t.parent;i(e=Je)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e)}function x(n,e,t,r,o,a){for(;r<=o;++r)d(t[r],a,n,e,!1,t,r)}function j(n){var e,t,o=n.data;if(i(o))for(i(e=o.hook)&&i(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)j(n.children[t])}function k(n,e,t){for(;e<=t;++e){var r=n[e];i(r)&&(i(r.tag)?(w(r),j(r)):p(r.elm))}}function w(n,e){if(i(e)||i(n.data)){var t,o=r.remove.length+1;for(i(e)?e.listeners+=o:e=function(n,e){function t(){0==--t.listeners&&p(n)}return t.listeners=e,t}(n.elm,o),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&w(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else p(n.elm)}function _(n,e,t,r){for(var o=t;o<r;o++){var a=e[o];if(i(a)&&_r(n,a))return o}}function S(n,e,t,o,c,l){if(n!==e){i(e.elm)&&i(o)&&(e=o[c]=fn(e));var p=e.elm=n.elm;if(s(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?C(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var v,m=e.data;i(m)&&i(v=m.hook)&&i(v=v.prepatch)&&v(n,e);var h=n.children,g=e.children;if(i(m)&&f(e)){for(v=0;v<r.update.length;++v)r.update[v](n,e);i(v=m.hook)&&i(v=v.update)&&v(n,e)}a(e.text)?i(h)&&i(g)?h!==g&&function(n,e,t,r,o){var s,c,l,p=0,v=0,m=e.length-1,h=e[0],f=e[m],g=t.length-1,b=t[0],y=t[g],j=!o;for(0;p<=m&&v<=g;)a(h)?h=e[++p]:a(f)?f=e[--m]:_r(h,b)?(S(h,b,r,t,v),h=e[++p],b=t[++v]):_r(f,y)?(S(f,y,r,t,g),f=e[--m],y=t[--g]):_r(h,y)?(S(h,y,r,t,g),j&&u.insertBefore(n,h.elm,u.nextSibling(f.elm)),h=e[++p],y=t[--g]):_r(f,b)?(S(f,b,r,t,v),j&&u.insertBefore(n,f.elm,h.elm),f=e[--m],b=t[++v]):(a(s)&&(s=Sr(e,p,m)),a(c=i(b.key)?s[b.key]:_(b,e,p,m))?d(b,r,n,h.elm,!1,t,v):_r(l=e[c],b)?(S(l,b,r,t,v),e[c]=void 0,j&&u.insertBefore(n,l.elm,h.elm)):d(b,r,n,h.elm,!1,t,v),b=t[++v]);p>m?x(n,a(t[g+1])?null:t[g+1].elm,t,v,g,r):v>g&&k(e,p,m)}(p,h,g,t,l):i(g)?(i(n.text)&&u.setTextContent(p,""),x(p,null,g,0,g.length-1,t)):i(h)?k(h,0,h.length-1):i(n.text)&&u.setTextContent(p,""):n.text!==e.text&&u.setTextContent(p,e.text),i(m)&&i(v=m.hook)&&i(v=v.postpatch)&&v(n,e)}}}function I(n,e,t){if(s(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var E=b("attrs,class,staticClass,staticStyle,key");function C(n,e,t,r){var o,a=e.tag,c=e.data,l=e.children;if(r=r||c&&c.pre,e.elm=n,s(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(c)&&(i(o=c.hook)&&i(o=o.init)&&o(e,!0),i(o=e.componentInstance)))return v(e,t),!0;if(i(a)){if(i(l))if(n.hasChildNodes())if(i(o=c)&&i(o=o.domProps)&&i(o=o.innerHTML)){if(o!==n.innerHTML)return!1}else{for(var u=!0,p=n.firstChild,d=0;d<l.length;d++){if(!p||!C(p,l[d],t,r)){u=!1;break}p=p.nextSibling}if(!u||p)return!1}else h(e,l,t);if(i(c)){var m=!1;for(var f in c)if(!E(f)){m=!0,g(e,t);break}!m&&c.class&&Ne(c.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,o){if(!a(e)){var c,l=!1,p=[];if(a(n))l=!0,d(e,p);else{var v=i(n.nodeType);if(!v&&_r(n,e))S(n,e,p,null,null,o);else{if(v){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&C(n,e,p))return I(e,p,!0),n;c=n,n=new vn(u.tagName(c).toLowerCase(),{},[],void 0,c)}var m=n.elm,h=u.parentNode(m);if(d(e,p,m._leaveCb?null:h,u.nextSibling(m)),i(e.parent))for(var g=e.parent,b=f(e);g;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](g);if(g.elm=e.elm,b){for(var x=0;x<r.create.length;++x)r.create[x](kr,g);var w=g.data.hook.insert;if(w.merged)for(var _=1;_<w.fns.length;_++)w.fns[_]()}else xr(g);g=g.parent}i(h)?k([n],0,0):i(n.tag)&&j(n)}}return I(e,p,l),e.elm}i(n)&&j(n)}}({nodeOps:br,modules:[Lr,Dr,Kr,Jr,io,W?{create:Po,activate:Po,remove:function(n,e){!0!==n.data.show?Co(n,e):e()}}:{}].concat(Or)});X&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Mo(n,"input")}));var zo={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Kn(t,"postpatch",(function(){zo.componentUpdated(n,e,t)})):$o(n,e,t.context),n._vOptions=[].map.call(n.options,Ro)):("textarea"===t.tag||gr(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Uo),n.addEventListener("compositionend",Do),n.addEventListener("change",Do),X&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){$o(n,e,t.context);var r=n._vOptions,o=n._vOptions=[].map.call(n.options,Ro);if(o.some((function(n,e){return!L(n,r[e])})))(n.multiple?e.value.some((function(n){return Lo(n,o)})):e.value!==e.oldValue&&Lo(e.value,o))&&Mo(n,"change")}}};function $o(n,e,t){Bo(n,e,t),(G||Y)&&setTimeout((function(){Bo(n,e,t)}),0)}function Bo(n,e,t){var r=e.value,o=n.multiple;if(!o||Array.isArray(r)){for(var a,i,s=0,c=n.options.length;s<c;s++)if(i=n.options[s],o)a=R(r,Ro(i))>-1,i.selected!==a&&(i.selected=a);else if(L(Ro(i),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));o||(n.selectedIndex=-1)}}function Lo(n,e){return e.every((function(e){return!L(e,n)}))}function Ro(n){return"_value"in n?n._value:n.value}function Uo(n){n.target.composing=!0}function Do(n){n.target.composing&&(n.target.composing=!1,Mo(n.target,"input"))}function Mo(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function No(n){return!n.componentInstance||n.data&&n.data.transition?n:No(n.componentInstance._vnode)}var Fo={model:zo,show:{bind:function(n,e,t){var r=e.value,o=(t=No(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&o?(t.data.show=!0,Eo(t,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=No(t)).data&&t.data.transition?(t.data.show=!0,r?Eo(t,(function(){n.style.display=n.__vOriginalDisplay})):Co(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,o){o||(n.style.display=n.__vOriginalDisplay)}}},Vo={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function qo(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?qo(we(e.children)):n}function Ho(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var o=t._parentListeners;for(var r in o)e[S(r)]=o[r];return e}function Ko(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Zo=function(n){return n.tag||ve(n)},Wo=function(n){return"show"===n.name},Jo={name:"transition",props:Vo,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Zo)).length){0;var r=this.mode;0;var o=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return o;var a=qo(o);if(!a)return o;if(this._leaving)return Ko(n,o);var i="__transition-".concat(this._uid,"-");a.key=null==a.key?a.isComment?i+"comment":i+a.tag:c(a.key)?0===String(a.key).indexOf(i)?a.key:i+a.key:a.key;var s=(a.data||(a.data={})).transition=Ho(this),l=this._vnode,u=qo(l);if(a.data.directives&&a.data.directives.some(Wo)&&(a.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,u)&&!ve(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var p=u.data.transition=P({},s);if("out-in"===r)return this._leaving=!0,Kn(p,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Ko(n,o);if("in-out"===r){if(ve(a))return l;var d,v=function(){d()};Kn(s,"afterEnter",v),Kn(s,"enterCancelled",v),Kn(p,"delayLeave",(function(n){d=n}))}}return o}}},Go=P({tag:String,moveClass:String},Vo);function Xo(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Yo(n){n.data.newPos=n.elm.getBoundingClientRect()}function Qo(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,o=e.top-t.top;if(r||o){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate(".concat(r,"px,").concat(o,"px)"),a.transitionDuration="0s"}}delete Go.mode;var na={Transition:Jo,TransitionGroup:{props:Go,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var o=Ge(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,o(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,o=this.$slots.default||[],a=this.children=[],i=Ho(this),s=0;s<o.length;s++){if((u=o[s]).tag)if(null!=u.key&&0!==String(u.key).indexOf("__vlist"))a.push(u),t[u.key]=u,(u.data||(u.data={})).transition=i;else;}if(r){var c=[],l=[];for(s=0;s<r.length;s++){var u;(u=r[s]).data.transition=i,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?c.push(u):l.push(u)}this.kept=n(e,null,c),this.removed=l}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Xo),n.forEach(Yo),n.forEach(Qo),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;xo(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(ho,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(ho,n),t._moveCb=null,jo(t,e))})}})))},methods:{hasMove:function(n,e){if(!vo)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){lo(t,n)})),co(t,e),t.style.display="none",this.$el.appendChild(t);var r=_o(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function ea(n,e){for(var t in e)n[t]=e[t];return n}Ht.config.mustUseProp=function(n,e,t){return"value"===t&&nr(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Ht.config.isReservedTag=hr,Ht.config.isReservedAttr=Qt,Ht.config.getTagNamespace=function(n){return mr(n)?"svg":"math"===n?"math":void 0},Ht.config.isUnknownElement=function(n){if(!W)return!0;if(hr(n))return!1;if(n=n.toLowerCase(),null!=fr[n])return fr[n];var e=document.createElement(n);return n.indexOf("-")>-1?fr[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:fr[n]=/HTMLUnknownElement/.test(e.toString())},P(Ht.options.directives,Fo),P(Ht.options.components,na),Ht.prototype.__patch__=W?Oo:z,Ht.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=mn),Qe(n,"beforeMount"),r=function(){n._update(n._render(),t)},new qe(n,r,z,{before:function(){n._isMounted&&!n._isDestroyed&&Qe(n,"beforeUpdate")}},!0),t=!1;var o=n._preWatchers;if(o)for(var a=0;a<o.length;a++)o[a].run();return null==n.$vnode&&(n._isMounted=!0,Qe(n,"mounted")),n}(this,n=n&&W?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},W&&setTimeout((function(){F.devtools&&sn&&sn.emit("init",Ht)}),0);var ta=/[!'()*]/g,ra=function(n){return"%"+n.charCodeAt(0).toString(16)},oa=/%2C/g,aa=function(n){return encodeURIComponent(n).replace(ta,ra).replace(oa,",")};function ia(n){try{return decodeURIComponent(n)}catch(n){0}return n}var sa=function(n){return null==n||"object"==typeof n?n:String(n)};function ca(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=ia(t.shift()),o=t.length>0?ia(t.join("=")):null;void 0===e[r]?e[r]=o:Array.isArray(e[r])?e[r].push(o):e[r]=[e[r],o]})),e):e}function la(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return aa(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(aa(e)):r.push(aa(e)+"="+aa(n)))})),r.join("&")}return aa(e)+"="+aa(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var ua=/\/?$/;function pa(n,e,t,r){var o=r&&r.options.stringifyQuery,a=e.query||{};try{a=da(a)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:ha(e,o),matched:n?ma(n):[]};return t&&(i.redirectedFrom=ha(t,o)),Object.freeze(i)}function da(n){if(Array.isArray(n))return n.map(da);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=da(n[t]);return e}return n}var va=pa(null,{path:"/"});function ma(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function ha(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var o=n.hash;return void 0===o&&(o=""),(t||"/")+(e||la)(r)+o}function fa(n,e,t){return e===va?n===e:!!e&&(n.path&&e.path?n.path.replace(ua,"")===e.path.replace(ua,"")&&(t||n.hash===e.hash&&ga(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&ga(n.query,e.query)&&ga(n.params,e.params))))}function ga(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,o){var a=n[t];if(r[o]!==t)return!1;var i=e[t];return null==a||null==i?a===i:"object"==typeof a&&"object"==typeof i?ga(a,i):String(a)===String(i)}))}function ba(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var o=t.instances[r],a=t.enteredCbs[r];if(o&&a){delete t.enteredCbs[r];for(var i=0;i<a.length;i++)o._isBeingDestroyed||a[i](o)}}}}var ya={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,o=e.parent,a=e.data;a.routerView=!0;for(var i=o.$createElement,s=t.name,c=o.$route,l=o._routerViewCache||(o._routerViewCache={}),u=0,p=!1;o&&o._routerRoot!==o;){var d=o.$vnode?o.$vnode.data:{};d.routerView&&u++,d.keepAlive&&o._directInactive&&o._inactive&&(p=!0),o=o.$parent}if(a.routerViewDepth=u,p){var v=l[s],m=v&&v.component;return m?(v.configProps&&xa(m,a,v.route,v.configProps),i(m,a,r)):i()}var h=c.matched[u],f=h&&h.components[s];if(!h||!f)return l[s]=null,i();l[s]={component:f},a.registerRouteInstance=function(n,e){var t=h.instances[s];(e&&t!==n||!e&&t===n)&&(h.instances[s]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){h.instances[s]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==h.instances[s]&&(h.instances[s]=n.componentInstance),ba(c)};var g=h.props&&h.props[s];return g&&(ea(l[s],{route:c,configProps:g}),xa(f,a,c,g)),i(f,a,r)}};function xa(n,e,t,r){var o=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(o){o=e.props=ea({},o);var a=e.attrs=e.attrs||{};for(var i in o)n.props&&i in n.props||(a[i]=o[i],delete o[i])}}function ja(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var o=e.split("/");t&&o[o.length-1]||o.pop();for(var a=n.replace(/^\//,"").split("/"),i=0;i<a.length;i++){var s=a[i];".."===s?o.pop():"."!==s&&o.push(s)}return""!==o[0]&&o.unshift(""),o.join("/")}function ka(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var wa=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},_a=Ua,Sa=Aa,Ia=function(n,e){return Oa(Aa(n,e),e)},Ea=Oa,Ca=Ra,Ta=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Aa(n,e){for(var t,r=[],o=0,a=0,i="",s=e&&e.delimiter||"/";null!=(t=Ta.exec(n));){var c=t[0],l=t[1],u=t.index;if(i+=n.slice(a,u),a=u+c.length,l)i+=l[1];else{var p=n[a],d=t[2],v=t[3],m=t[4],h=t[5],f=t[6],g=t[7];i&&(r.push(i),i="");var b=null!=d&&null!=p&&p!==d,y="+"===f||"*"===f,x="?"===f||"*"===f,j=t[2]||s,k=m||h;r.push({name:v||o++,prefix:d||"",delimiter:j,optional:x,repeat:y,partial:b,asterisk:!!g,pattern:k?$a(k):g?".*":"[^"+za(j)+"]+?"})}}return a<n.length&&(i+=n.substr(a)),i&&r.push(i),r}function Pa(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Oa(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",La(e)));return function(e,r){for(var o="",a=e||{},i=(r||{}).pretty?Pa:encodeURIComponent,s=0;s<n.length;s++){var c=n[s];if("string"!=typeof c){var l,u=a[c.name];if(null==u){if(c.optional){c.partial&&(o+=c.prefix);continue}throw new TypeError('Expected "'+c.name+'" to be defined')}if(wa(u)){if(!c.repeat)throw new TypeError('Expected "'+c.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(c.optional)continue;throw new TypeError('Expected "'+c.name+'" to not be empty')}for(var p=0;p<u.length;p++){if(l=i(u[p]),!t[s].test(l))throw new TypeError('Expected all "'+c.name+'" to match "'+c.pattern+'", but received `'+JSON.stringify(l)+"`");o+=(0===p?c.prefix:c.delimiter)+l}}else{if(l=c.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(u),!t[s].test(l))throw new TypeError('Expected "'+c.name+'" to match "'+c.pattern+'", but received "'+l+'"');o+=c.prefix+l}}else o+=c}return o}}function za(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function $a(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Ba(n,e){return n.keys=e,n}function La(n){return n&&n.sensitive?"":"i"}function Ra(n,e,t){wa(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,o=!1!==t.end,a="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)a+=za(s);else{var c=za(s.prefix),l="(?:"+s.pattern+")";e.push(s),s.repeat&&(l+="(?:"+c+l+")*"),a+=l=s.optional?s.partial?c+"("+l+")?":"(?:"+c+"("+l+"))?":c+"("+l+")"}}var u=za(t.delimiter||"/"),p=a.slice(-u.length)===u;return r||(a=(p?a.slice(0,-u.length):a)+"(?:"+u+"(?=$))?"),a+=o?"$":r&&p?"":"(?="+u+"|$)",Ba(new RegExp("^"+a,La(t)),e)}function Ua(n,e,t){return wa(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Ba(n,e)}(n,e):wa(n)?function(n,e,t){for(var r=[],o=0;o<n.length;o++)r.push(Ua(n[o],e,t).source);return Ba(new RegExp("(?:"+r.join("|")+")",La(t)),e)}(n,e,t):function(n,e,t){return Ra(Aa(n,t),e,t)}(n,e,t)}_a.parse=Sa,_a.compile=Ia,_a.tokensToFunction=Ea,_a.tokensToRegExp=Ca;var Da=Object.create(null);function Ma(n,e,t){e=e||{};try{var r=Da[n]||(Da[n]=_a.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Na(n,e,t,r){var o="string"==typeof n?{path:n}:n;if(o._normalized)return o;if(o.name){var a=(o=ea({},n)).params;return a&&"object"==typeof a&&(o.params=ea({},a)),o}if(!o.path&&o.params&&e){(o=ea({},o))._normalized=!0;var i=ea(ea({},e.params),o.params);if(e.name)o.name=e.name,o.params=i;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;o.path=Ma(s,i,e.path)}else 0;return o}var c=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var o=n.indexOf("?");return o>=0&&(t=n.slice(o+1),n=n.slice(0,o)),{path:n,query:t,hash:e}}(o.path||""),l=e&&e.path||"/",u=c.path?ja(c.path,l,t||o.append):l,p=function(n,e,t){void 0===e&&(e={});var r,o=t||ca;try{r=o(n||"")}catch(n){r={}}for(var a in e){var i=e[a];r[a]=Array.isArray(i)?i.map(sa):sa(i)}return r}(c.query,o.query,r&&r.options.parseQuery),d=o.hash||c.hash;return d&&"#"!==d.charAt(0)&&(d="#"+d),{_normalized:!0,path:u,query:p,hash:d}}var Fa,Va=function(){},qa={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,o=t.resolve(this.to,r,this.append),a=o.location,i=o.route,s=o.href,c={},l=t.options.linkActiveClass,u=t.options.linkExactActiveClass,p=null==l?"router-link-active":l,d=null==u?"router-link-exact-active":u,v=null==this.activeClass?p:this.activeClass,m=null==this.exactActiveClass?d:this.exactActiveClass,h=i.redirectedFrom?pa(null,Na(i.redirectedFrom),null,t):i;c[m]=fa(r,h,this.exactPath),c[v]=this.exact||this.exactPath?c[m]:function(n,e){return 0===n.path.replace(ua,"/").indexOf(e.path.replace(ua,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,h);var f=c[m]?this.ariaCurrentValue:null,g=function(n){Ha(n)&&(e.replace?t.replace(a,Va):t.push(a,Va))},b={click:Ha};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=g})):b[this.event]=g;var y={class:c},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:i,navigate:g,isActive:c[v],isExactActive:c[m]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=b,y.attrs={href:s,"aria-current":f};else{var j=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(j){j.isStatic=!1;var k=j.data=ea({},j.data);for(var w in k.on=k.on||{},k.on){var _=k.on[w];w in b&&(k.on[w]=Array.isArray(_)?_:[_])}for(var S in b)S in k.on?k.on[S].push(b[S]):k.on[S]=g;var I=j.data.attrs=ea({},j.data.attrs);I.href=s,I["aria-current"]=f}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Ha(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Ka="undefined"!=typeof window;function Za(n,e,t,r,o){var a=e||[],i=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,o,a,i){var s=o.path,c=o.name;0;var l=o.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return ka(e.path+"/"+n)}(s,a,l.strict);"boolean"==typeof o.caseSensitive&&(l.sensitive=o.caseSensitive);var p={path:u,regex:Wa(u,l),components:o.components||{default:o.component},alias:o.alias?"string"==typeof o.alias?[o.alias]:o.alias:[],instances:{},enteredCbs:{},name:c,parent:a,matchAs:i,redirect:o.redirect,beforeEnter:o.beforeEnter,meta:o.meta||{},props:null==o.props?{}:o.components?o.props:{default:o.props}};o.children&&o.children.forEach((function(o){var a=i?ka(i+"/"+o.path):void 0;n(e,t,r,o,p,a)}));t[p.path]||(e.push(p.path),t[p.path]=p);if(void 0!==o.alias)for(var d=Array.isArray(o.alias)?o.alias:[o.alias],v=0;v<d.length;++v){0;var m={path:d[v],children:o.children};n(e,t,r,m,a,p.path||"/")}c&&(r[c]||(r[c]=p))}(a,i,s,n,o)}));for(var c=0,l=a.length;c<l;c++)"*"===a[c]&&(a.push(a.splice(c,1)[0]),l--,c--);return{pathList:a,pathMap:i,nameMap:s}}function Wa(n,e){return _a(n,[],e)}function Ja(n,e){var t=Za(n),r=t.pathList,o=t.pathMap,a=t.nameMap;function i(n,t,i){var s=Na(n,t,!1,e),l=s.name;if(l){var u=a[l];if(!u)return c(null,s);var p=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var d in t.params)!(d in s.params)&&p.indexOf(d)>-1&&(s.params[d]=t.params[d]);return s.path=Ma(u.path,s.params),c(u,s,i)}if(s.path){s.params={};for(var v=0;v<r.length;v++){var m=r[v],h=o[m];if(Ga(h.regex,s.path,s.params))return c(h,s,i)}}return c(null,s)}function s(n,t){var r=n.redirect,o="function"==typeof r?r(pa(n,t,null,e)):r;if("string"==typeof o&&(o={path:o}),!o||"object"!=typeof o)return c(null,t);var s=o,l=s.name,u=s.path,p=t.query,d=t.hash,v=t.params;if(p=s.hasOwnProperty("query")?s.query:p,d=s.hasOwnProperty("hash")?s.hash:d,v=s.hasOwnProperty("params")?s.params:v,l){a[l];return i({_normalized:!0,name:l,query:p,hash:d,params:v},void 0,t)}if(u){var m=function(n,e){return ja(n,e.parent?e.parent.path:"/",!0)}(u,n);return i({_normalized:!0,path:Ma(m,v),query:p,hash:d},void 0,t)}return c(null,t)}function c(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=i({_normalized:!0,path:Ma(t,e.params)});if(r){var o=r.matched,a=o[o.length-1];return e.params=r.params,c(a,e)}return c(null,e)}(0,t,n.matchAs):pa(n,t,r,e)}return{match:i,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Za([e||n],r,o,a,t),t&&t.alias.length&&Za(t.alias.map((function(n){return{path:n,children:[e]}})),r,o,a,t)},getRoutes:function(){return r.map((function(n){return o[n]}))},addRoutes:function(n){Za(n,r,o,a)}}}function Ga(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var o=1,a=r.length;o<a;++o){var i=n.keys[o-1];i&&(t[i.name||"pathMatch"]="string"==typeof r[o]?ia(r[o]):r[o])}return!0}var Xa=Ka&&window.performance&&window.performance.now?window.performance:Date;function Ya(){return Xa.now().toFixed(3)}var Qa=Ya();function ni(){return Qa}function ei(n){return Qa=n}var ti=Object.create(null);function ri(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ea({},window.history.state);return t.key=ni(),window.history.replaceState(t,"",e),window.addEventListener("popstate",ii),function(){window.removeEventListener("popstate",ii)}}function oi(n,e,t,r){if(n.app){var o=n.options.scrollBehavior;o&&n.app.$nextTick((function(){var a=function(){var n=ni();if(n)return ti[n]}(),i=o.call(n,e,t,r?a:null);i&&("function"==typeof i.then?i.then((function(n){pi(n,a)})).catch((function(n){0})):pi(i,a))}))}}function ai(){var n=ni();n&&(ti[n]={x:window.pageXOffset,y:window.pageYOffset})}function ii(n){ai(),n.state&&n.state.key&&ei(n.state.key)}function si(n){return li(n.x)||li(n.y)}function ci(n){return{x:li(n.x)?n.x:window.pageXOffset,y:li(n.y)?n.y:window.pageYOffset}}function li(n){return"number"==typeof n}var ui=/^#\d/;function pi(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var o=ui.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(o){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(o,a={x:li((t=a).x)?t.x:0,y:li(t.y)?t.y:0})}else si(n)&&(e=ci(n))}else r&&si(n)&&(e=ci(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var di,vi=Ka&&((-1===(di=window.navigator.userAgent).indexOf("Android 2.")&&-1===di.indexOf("Android 4.0")||-1===di.indexOf("Mobile Safari")||-1!==di.indexOf("Chrome")||-1!==di.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function mi(n,e){ai();var t=window.history;try{if(e){var r=ea({},t.state);r.key=ni(),t.replaceState(r,"",n)}else t.pushState({key:ei(Ya())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function hi(n){mi(n,!0)}function fi(n,e,t){var r=function(o){o>=n.length?t():n[o]?e(n[o],(function(){r(o+1)})):r(o+1)};r(0)}var gi={redirected:2,aborted:4,cancelled:8,duplicated:16};function bi(n,e){return xi(n,e,gi.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return ji.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function yi(n,e){return xi(n,e,gi.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function xi(n,e,t,r){var o=new Error(r);return o._isRouter=!0,o.from=n,o.to=e,o.type=t,o}var ji=["params","query","hash"];function ki(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function wi(n,e){return ki(n)&&n._isRouter&&(null==e||n.type===e)}function _i(n){return function(e,t,r){var o=!1,a=0,i=null;Si(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){o=!0,a++;var c,l=Ci((function(e){var o;((o=e).__esModule||Ei&&"Module"===o[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Fa.extend(e),t.components[s]=e,--a<=0&&r()})),u=Ci((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=ki(n)?n:new Error(e),r(i))}));try{c=n(l,u)}catch(n){u(n)}if(c)if("function"==typeof c.then)c.then(l,u);else{var p=c.component;p&&"function"==typeof p.then&&p.then(l,u)}}})),o||r()}}function Si(n,e){return Ii(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Ii(n){return Array.prototype.concat.apply([],n)}var Ei="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Ci(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var Ti=function(n,e){this.router=n,this.base=function(n){if(!n)if(Ka){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=va,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Ai(n,e,t,r){var o=Si(n,(function(n,r,o,a){var i=function(n,e){"function"!=typeof n&&(n=Fa.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,r,o,a)})):t(i,r,o,a)}));return Ii(r?o.reverse():o)}function Pi(n,e){if(e)return function(){return n.apply(e,arguments)}}Ti.prototype.listen=function(n){this.cb=n},Ti.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Ti.prototype.onError=function(n){this.errorCbs.push(n)},Ti.prototype.transitionTo=function(n,e,t){var r,o=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(r,(function(){o.updateRoute(r),e&&e(r),o.ensureURL(),o.router.afterHooks.forEach((function(n){n&&n(r,a)})),o.ready||(o.ready=!0,o.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!o.ready&&(wi(n,gi.redirected)&&a===va||(o.ready=!0,o.readyErrorCbs.forEach((function(e){e(n)}))))}))},Ti.prototype.confirmTransition=function(n,e,t){var r=this,o=this.current;this.pending=n;var a,i,s=function(n){!wi(n)&&ki(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},c=n.matched.length-1,l=o.matched.length-1;if(fa(n,o)&&c===l&&n.matched[c]===o.matched[l])return this.ensureURL(),n.hash&&oi(this.router,o,n,!1),s(((i=xi(a=o,n,gi.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",i));var u=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),p=u.updated,d=u.deactivated,v=u.activated,m=[].concat(function(n){return Ai(n,"beforeRouteLeave",Pi,!0)}(d),this.router.beforeHooks,function(n){return Ai(n,"beforeRouteUpdate",Pi)}(p),v.map((function(n){return n.beforeEnter})),_i(v)),h=function(e,t){if(r.pending!==n)return s(yi(o,n));try{e(n,o,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return xi(n,e,gi.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(o,n))):ki(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(bi(o,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};fi(m,h,(function(){fi(function(n){return Ai(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,o,a){return n(r,o,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,r)}))}(v).concat(r.router.resolveHooks),h,(function(){if(r.pending!==n)return s(yi(o,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){ba(n)}))}))}))},Ti.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Ti.prototype.setupListeners=function(){},Ti.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=va,this.pending=null};var Oi=function(n){function e(e,t){n.call(this,e,t),this._startLocation=zi(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=vi&&t;r&&this.listeners.push(ri());var o=function(){var t=n.current,o=zi(n.base);n.current===va&&o===n._startLocation||n.transitionTo(o,(function(n){r&&oi(e,n,t,!0)}))};window.addEventListener("popstate",o),this.listeners.push((function(){window.removeEventListener("popstate",o)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){mi(ka(r.base+n.fullPath)),oi(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){hi(ka(r.base+n.fullPath)),oi(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(zi(this.base)!==this.current.fullPath){var e=ka(this.base+this.current.fullPath);n?mi(e):hi(e)}},e.prototype.getCurrentLocation=function(){return zi(this.base)},e}(Ti);function zi(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(ka(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var $i=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=zi(n);if(!/^\/#/.test(e))return window.location.replace(ka(n+"/#"+e)),!0}(this.base)||Bi()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=vi&&e;t&&this.listeners.push(ri());var r=function(){var e=n.current;Bi()&&n.transitionTo(Li(),(function(r){t&&oi(n.router,r,e,!0),vi||Di(r.fullPath)}))},o=vi?"popstate":"hashchange";window.addEventListener(o,r),this.listeners.push((function(){window.removeEventListener(o,r)}))}},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){Ui(n.fullPath),oi(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){Di(n.fullPath),oi(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Li()!==e&&(n?Ui(e):Di(e))},e.prototype.getCurrentLocation=function(){return Li()},e}(Ti);function Bi(){var n=Li();return"/"===n.charAt(0)||(Di("/"+n),!1)}function Li(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Ri(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Ui(n){vi?mi(Ri(n)):window.location.hash=n}function Di(n){vi?hi(Ri(n)):window.location.replace(Ri(n))}var Mi=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){wi(n,gi.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Ti),Ni=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Ja(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!vi&&!1!==n.fallback,this.fallback&&(e="hash"),Ka||(e="abstract"),this.mode=e,e){case"history":this.history=new Oi(this,n.base);break;case"hash":this.history=new $i(this,n.base,this.fallback);break;case"abstract":this.history=new Mi(this,n.base);break;default:0}},Fi={currentRoute:{configurable:!0}};function Vi(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Ni.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Fi.currentRoute.get=function(){return this.history&&this.history.current},Ni.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Oi||t instanceof $i){var r=function(n){t.setupListeners(),function(n){var r=t.current,o=e.options.scrollBehavior;vi&&o&&"fullPath"in n&&oi(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Ni.prototype.beforeEach=function(n){return Vi(this.beforeHooks,n)},Ni.prototype.beforeResolve=function(n){return Vi(this.resolveHooks,n)},Ni.prototype.afterEach=function(n){return Vi(this.afterHooks,n)},Ni.prototype.onReady=function(n,e){this.history.onReady(n,e)},Ni.prototype.onError=function(n){this.history.onError(n)},Ni.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Ni.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Ni.prototype.go=function(n){this.history.go(n)},Ni.prototype.back=function(){this.go(-1)},Ni.prototype.forward=function(){this.go(1)},Ni.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Ni.prototype.resolve=function(n,e,t){var r=Na(n,e=e||this.history.current,t,this),o=this.match(r,e),a=o.redirectedFrom||o.fullPath;return{location:r,route:o,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?ka(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:o}},Ni.prototype.getRoutes=function(){return this.matcher.getRoutes()},Ni.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==va&&this.history.transitionTo(this.history.getCurrentLocation())},Ni.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==va&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Ni.prototype,Fi),Ni.install=function n(e){if(!n.installed||Fa!==e){n.installed=!0,Fa=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",ya),e.component("RouterLink",qa);var o=e.config.optionMergeStrategies;o.beforeRouteEnter=o.beforeRouteLeave=o.beforeRouteUpdate=o.created}},Ni.version="3.5.4",Ni.isNavigationFailure=wi,Ni.NavigationFailureType=gi,Ni.START_LOCATION=va,Ka&&window.Vue&&window.Vue.use(Ni);var qi=Ni;t(103);t(126);var Hi={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,333)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,332))},Ki={"v-5e840b50":()=>t.e(5).then(t.bind(null,336)),"v-d5604794":()=>t.e(6).then(t.bind(null,337)),"v-06567194":()=>t.e(7).then(t.bind(null,338)),"v-7ac129d6":()=>t.e(8).then(t.bind(null,339)),"v-68ff1b36":()=>t.e(9).then(t.bind(null,340)),"v-e1cf8cac":()=>t.e(10).then(t.bind(null,341)),"v-24bc85d0":()=>t.e(11).then(t.bind(null,342)),"v-73de5164":()=>t.e(12).then(t.bind(null,343)),"v-e08cd448":()=>t.e(13).then(t.bind(null,344)),"v-08ae0b36":()=>t.e(14).then(t.bind(null,345)),"v-d7b0d4dc":()=>t.e(15).then(t.bind(null,346)),"v-42a5ab7e":()=>t.e(16).then(t.bind(null,347)),"v-629eea80":()=>t.e(17).then(t.bind(null,348)),"v-13383ab2":()=>t.e(18).then(t.bind(null,349)),"v-a49916ba":()=>t.e(19).then(t.bind(null,350)),"v-5eead728":()=>t.e(20).then(t.bind(null,351)),"v-73f54546":()=>t.e(21).then(t.bind(null,352)),"v-1293b6fa":()=>t.e(22).then(t.bind(null,353)),"v-ebbc0b9e":()=>t.e(23).then(t.bind(null,354)),"v-43156d4a":()=>t.e(24).then(t.bind(null,334)),"v-28f80f80":()=>t.e(25).then(t.bind(null,355)),"v-dd8aeb38":()=>t.e(26).then(t.bind(null,356)),"v-13e9637e":()=>t.e(27).then(t.bind(null,357)),"v-3352929f":()=>t.e(28).then(t.bind(null,358)),"v-dfc1e590":()=>t.e(29).then(t.bind(null,359)),"v-3c50469e":()=>t.e(30).then(t.bind(null,360)),"v-4ba573aa":()=>t.e(31).then(t.bind(null,361)),"v-50bc8525":()=>t.e(32).then(t.bind(null,362)),"v-537ab085":()=>t.e(33).then(t.bind(null,363)),"v-2f058aa5":()=>t.e(34).then(t.bind(null,364)),"v-09f2a40f":()=>t.e(35).then(t.bind(null,365)),"v-653cdd76":()=>t.e(36).then(t.bind(null,366)),"v-390e40a1":()=>t.e(37).then(t.bind(null,367)),"v-02ad9e44":()=>t.e(38).then(t.bind(null,368)),"v-1133a448":()=>t.e(39).then(t.bind(null,369)),"v-7bd86066":()=>t.e(40).then(t.bind(null,370)),"v-b67a6bf6":()=>t.e(41).then(t.bind(null,371)),"v-21153691":()=>t.e(42).then(t.bind(null,372)),"v-f4fd4036":()=>t.e(43).then(t.bind(null,373)),"v-d814e4ee":()=>t.e(44).then(t.bind(null,374)),"v-13d384c5":()=>t.e(45).then(t.bind(null,375)),"v-3c4ee536":()=>t.e(46).then(t.bind(null,376)),"v-9f0855b6":()=>t.e(47).then(t.bind(null,377)),"v-75939a25":()=>t.e(48).then(t.bind(null,378)),"v-eb1da8f6":()=>t.e(49).then(t.bind(null,379)),"v-74ab1dd5":()=>t.e(50).then(t.bind(null,380)),"v-62bb08c9":()=>t.e(51).then(t.bind(null,381)),"v-1f70189d":()=>t.e(52).then(t.bind(null,382)),"v-92c74e7e":()=>t.e(53).then(t.bind(null,383)),"v-11d9b8ac":()=>t.e(54).then(t.bind(null,335)),"v-8baa32f8":()=>t.e(55).then(t.bind(null,384)),"v-46ea4296":()=>t.e(56).then(t.bind(null,385)),"v-080301c7":()=>t.e(57).then(t.bind(null,386)),"v-8adb67f4":()=>t.e(58).then(t.bind(null,387)),"v-490a2e94":()=>t.e(59).then(t.bind(null,388)),"v-2c9d4562":()=>t.e(60).then(t.bind(null,389)),"v-964a6848":()=>t.e(61).then(t.bind(null,390)),"v-50fdf4f7":()=>t.e(62).then(t.bind(null,391)),"v-d38315a6":()=>t.e(63).then(t.bind(null,392)),"v-27c99f0a":()=>t.e(64).then(t.bind(null,393)),"v-2b5187de":()=>t.e(65).then(t.bind(null,394)),"v-2ad5ddba":()=>t.e(66).then(t.bind(null,395)),"v-13888698":()=>t.e(67).then(t.bind(null,396)),"v-266ce9eb":()=>t.e(68).then(t.bind(null,397)),"v-f4156710":()=>t.e(69).then(t.bind(null,398)),"v-ab5313be":()=>t.e(70).then(t.bind(null,399)),"v-1ab3ab88":()=>t.e(71).then(t.bind(null,400)),"v-4a1889c6":()=>t.e(72).then(t.bind(null,401)),"v-540c7b98":()=>t.e(73).then(t.bind(null,402)),"v-70c71972":()=>t.e(74).then(t.bind(null,403)),"v-fb433546":()=>t.e(75).then(t.bind(null,404)),"v-0447f706":()=>t.e(76).then(t.bind(null,405)),"v-d37c0f4a":()=>t.e(77).then(t.bind(null,406)),"v-ebc99984":()=>t.e(78).then(t.bind(null,407))};function Zi(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Wi=/-(\w)/g,Ji=Zi(n=>n.replace(Wi,(n,e)=>e?e.toUpperCase():"")),Gi=/\B([A-Z])/g,Xi=Zi(n=>n.replace(Gi,"-$1").toLowerCase()),Yi=Zi(n=>n.charAt(0).toUpperCase()+n.slice(1));function Qi(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Yi(Ji(e))):n(Yi(e))||n(Xi(e))}const ns=Object.assign({},Hi,Ki),es=n=>ns[n],ts=n=>Ki[n],rs=n=>Hi[n],os=n=>Ht.component(n);function as(n){return Qi(ts,n)}function is(n){return Qi(rs,n)}function ss(n){return Qi(es,n)}function cs(n){return Qi(os,n)}function ls(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!cs(n)&&ss(n)){const e=await ss(n)();Ht.component(n,e.default)}}))}function us(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ps=t(92),ds=t.n(ps),vs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${n[t]}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=hs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=fs(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ds()([{name:"description",content:this.$description}],n,this.siteMeta,gs)},updateCanonicalLink(){ms(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",hs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){fs(null,this.currentMetaTags),ms()}};function ms(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function hs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function fs(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function gs(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var bs=t(50),ys={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(bs)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),o=window.innerHeight+t;for(let n=0;n<e.length;n++){const a=e[n],i=e[n+1],s=0===n&&0===t||t>=a.parentElement.offsetTop+10&&(!i||t<i.parentElement.offsetTop-10),c=decodeURIComponent(this.$route.hash);if(s&&c!==decodeURIComponent(a.hash)){const t=a;if(o===r)for(let t=n+1;t<e.length;t++)if(c===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},xs=t(24),js=t.n(xs),ks={mounted(){js.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Ht.component(n.name)||js.a.start(),t()}),this.$router.afterEach(()=>{js.a.done(),this.isSidebarOpen=!1})}};t(233),t(234);class ws{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var _s={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new ws).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],o=document.createElement("style");o.type="text/css","top"===t&&r.firstChild?r.insertBefore(o,r.firstChild):r.appendChild(o),o.styleSheet?o.styleSheet.cssText=n:o.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Ss={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Is={},Es=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Cs=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Ss[n]},Ts=function n(e,t,r){var o=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))o[n]=t[n];else{var e=n.replace("data","");o.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,a=e.children;o.appendChild(n(t,r,a))})),o},As=function(n,e,t){var r,o=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==o.length||t?o:o[0]},Ps=function(n,e){var t,r,o=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<template>([\s\S]+)<\/template>/),i=n.match(/<script>([\s\S]+)<\/script>/),s={css:o&&o[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=Es(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),o=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,a=[eval][0](o);return a.template=e,a}(s.js,s.html);var c=Cs("vue");return s.jsLib.unshift(c),s},Os=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<html>([\s\S]+)<\/html>/),a=n.match(/<script>([\s\S]+)<\/script>/),i={css:r&&r[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return i.htmlTpl=i.html,i.jsTpl=i.js,i.script=(t=i.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),i},zs=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function $s(){var n=As(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=As(n,"vuepress-plugin-demo-block__code"),t=As(n,"vuepress-plugin-demo-block__display"),r=As(n,"vuepress-plugin-demo-block__footer"),o=As(t,"vuepress-plugin-demo-block__app"),a=decodeURIComponent(n.dataset.code),i=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);i=i?JSON.parse(i):{};var c=e.querySelector("div").clientHeight,l="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),o=new Function("return ".concat(r))(),a={js:o,css:o.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:zs(n),htmlTpl:Es("")},i=Cs("react"),s=Cs("reactDOM");return a.jsLib.unshift(i,s),a}(a,i):"vanilla"===s?Os(a,i):Ps(a,i),u=Ts("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(u),u.addEventListener("click",Bs.bind(null,u,c,e,r)),Cs("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,o=n.jsLib,a=n.cssLib,i=o.concat(a).concat(Cs("cssLib")).concat(Cs("jsLib")).join(",");return Ts("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:i}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(l)),Cs("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,o=n.jsLib,a=n.cssLib,i=JSON.stringify({css:e,html:t,js:r,js_external:o.concat(Cs("jsLib")).join(";"),css_external:a.concat(Cs("cssLib")).join(";"),layout:Cs("codepenLayout"),js_pre_processor:Cs("codepenJsProcessor"),editors:Cs("codepenEditors")});return Ts("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:i}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(l)),void 0!==i.horizontal?i.horizontal:Cs("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var p=e.firstChild.cloneNode(!0);p.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(p)}if(l.css&&function(n){if(!Is[n]){var e=Ts("style",{innerHTML:n});document.body.appendChild(e),Is[n]=!0}}(l.css),"react"===s)ReactDOM.render(React.createElement(l.js),o);else if("vue"===s){var d=(new(Vue.extend(l.script))).$mount();o.appendChild(d.$el)}else"vanilla"===s&&(o.innerHTML=l.html,new Function("return (function(){".concat(l.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){$s()}),300)}function Bs(n,e,t,r){var o="1"!==n.dataset.isExpand;t.style.height=o?"".concat(e,"px"):0,o?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=o?"1":"0"}var Ls={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},$s()},updated:function(){$s()}},Rs="auto",Us="zoom-in",Ds="zoom-out",Ms="grab",Ns="move";function Fs(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o={passive:!1};r?n.addEventListener(e,t,o):n.removeEventListener(e,t,o)}function Vs(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function qs(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Hs(n,e,t){!function(n){var e=Ks,t=Zs;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var o=n.transform;delete n.transform,n[t]=o}}(e);var r=n.style,o={};for(var a in e)t&&(o[a]=r[a]||""),r[a]=e[a];return o}var Ks="transition",Zs="transform",Ws="transform",Js="transitionend";var Gs=function(){},Xs={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Gs,onClose:Gs,onGrab:Gs,onMove:Gs,onRelease:Gs,onBeforeOpen:Gs,onBeforeClose:Gs,onBeforeGrab:Gs,onBeforeRelease:Gs,onImageLoading:Gs,onImageLoaded:Gs},Ys={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),nc(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,o=this.lastScrollPosition.y-t,a=this.options.scrollThreshold;(Math.abs(o)>=a||Math.abs(r)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Qs(n)&&!nc(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Qs(n)&&!nc(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Qs(n){return 0===n.button}function nc(n){return n.metaKey||n.ctrlKey}var ec={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Hs(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Fs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Hs(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},tc="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},rc=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),oc=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},ac={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=qs(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,o=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Ms:Ds,transition:Ws+"\n        "+r+"s\n        "+o,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Hs(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Hs(this.el,{transform:"none"})},grab:function(n,e,t){var r=ic(),o=r.x-n,a=r.y-e;Hs(this.el,{cursor:Ns,transform:"translate3d(\n        "+(this.translate.x+o)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=ic(),o=r.x-n,a=r.y-e;Hs(this.el,{transition:Ws,transform:"translate3d(\n        "+(this.translate.x+o)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Hs(this.el,this.styleClose)},restoreOpenStyle:function(){Hs(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=ic(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,o=r.customSize,a=r.scaleBase;if(!o&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(o&&"object"===(void 0===o?"undefined":tc(o)))return{x:o.width/this.rect.width,y:o.height/this.rect.height};var i=this.rect.width/2,s=this.rect.height/2,c=ic(),l={x:c.x-i,y:c.y-s},u=l.x/i,p=l.y/s,d=a+Math.min(u,p);if(o&&"string"==typeof o){var v=t||this.el.naturalWidth,m=e||this.el.naturalHeight,h=parseFloat(o)*v/(100*this.rect.width),f=parseFloat(o)*m/(100*this.rect.height);if(d>h||d>f)return{x:h,y:f}}return{x:d,y:d}}};function ic(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function sc(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Fs(n,r,e[r],t)}))}var cc=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ac),this.overlay=Object.create(ec),this.handler=Object.create(Ys),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=oc({},Xs,e),this.overlay.init(this),this.handler.init(this)}return rc(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Us,Fs(n,"click",this.handler.click),this.options.preloadImage&&Vs(qs(n)));return this}},{key:"config",value:function(n){return n?(oc(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var o=this.target.srcOriginal;null!=o&&(this.options.onImageLoading(r),Vs(o,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Fs(document,"scroll",this.handler.scroll),Fs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Fs(window,"resize",this.handler.resizeWindow);var a=function n(){Fs(r,Js,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&sc(document,e.handler,!0),t(r)};return Fs(r,Js,a),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Rs,this.overlay.fadeOut(),this.target.zoomOut(),Fs(document,"scroll",this.handler.scroll,!1),Fs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Fs(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Fs(t,Js,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&sc(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Fs(t,Js,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var o=this.target.el;this.options.onBeforeGrab(o),this.released=!1,this.target.grab(n,e,t);var a=function n(){Fs(o,Js,n,!1),r(o)};return Fs(o,Js,a),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Ns,this.target.move(n,e,t);var o=this.target.el,a=function n(){Fs(o,Js,n,!1),r(o)};return Fs(o,Js,a),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Rs,this.target.restoreOpenStyle();var r=function r(){Fs(t,Js,r,!1),n.lock=!1,n.released=!0,e(t)};return Fs(t,Js,r),this}}}]),n}();const lc=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),uc=Number("500");class pc{constructor(){this.instance=new cc(lc)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=uc){setTimeout(()=>this.update(n),e)}}var dc=[vs,ys,ks,_s,Ls,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new pc,this.$vuepress.zooming.updateDelay()}}],vc={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return us("layout",n),Ht.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},mc=t(1),hc=Object(mc.a)(vc,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(hc,"mixins",dc);const fc=[{name:"v-5e840b50",path:"/project/di/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-5e840b50").then(t)}},{path:"/project/di/index.html",redirect:"/project/di/"},{path:"/00.目录页/00.di.html",redirect:"/project/di/"},{name:"v-d5604794",path:"/project/use-vue-service/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-d5604794").then(t)}},{path:"/project/use-vue-service/index.html",redirect:"/project/use-vue-service/"},{path:"/00.目录页/01.use-vue-service.html",redirect:"/project/use-vue-service/"},{name:"v-06567194",path:"/project/use-react-service/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-06567194").then(t)}},{path:"/project/use-react-service/index.html",redirect:"/project/use-react-service/"},{path:"/00.目录页/02.use-react-service.html",redirect:"/project/use-react-service/"},{name:"v-7ac129d6",path:"/project/use-solid-service/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-7ac129d6").then(t)}},{path:"/project/use-solid-service/index.html",redirect:"/project/use-solid-service/"},{path:"/00.目录页/03.use-solid-service.html",redirect:"/project/use-solid-service/"},{name:"v-68ff1b36",path:"/project/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-68ff1b36").then(t)}},{path:"/project/index.html",redirect:"/project/"},{path:"/00.目录页/99.project.html",redirect:"/project/"},{name:"v-e1cf8cac",path:"/pages/358991/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-e1cf8cac").then(t)}},{path:"/pages/358991/index.html",redirect:"/pages/358991/"},{path:"/30.项目文档/00.di/00.快速开始.html",redirect:"/pages/358991/"},{name:"v-24bc85d0",path:"/pages/8dfb90/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-24bc85d0").then(t)}},{path:"/pages/8dfb90/index.html",redirect:"/pages/8dfb90/"},{path:"/30.项目文档/00.di/01.什么是服务.html",redirect:"/pages/8dfb90/"},{name:"v-73de5164",path:"/pages/4828a1/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-73de5164").then(t)}},{path:"/pages/4828a1/index.html",redirect:"/pages/4828a1/"},{path:"/30.项目文档/00.di/02.什么是Provider.html",redirect:"/pages/4828a1/"},{name:"v-e08cd448",path:"/pages/d699f9/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-e08cd448").then(t)}},{path:"/pages/d699f9/index.html",redirect:"/pages/d699f9/"},{path:"/30.项目文档/00.di/03.什么是Injector.html",redirect:"/pages/d699f9/"},{name:"v-08ae0b36",path:"/pages/53952f/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-08ae0b36").then(t)}},{path:"/pages/53952f/index.html",redirect:"/pages/53952f/"},{path:"/30.项目文档/00.di/04.什么是依赖注入.html",redirect:"/pages/53952f/"},{name:"v-d7b0d4dc",path:"/pages/b09aca/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-d7b0d4dc").then(t)}},{path:"/pages/b09aca/index.html",redirect:"/pages/b09aca/"},{path:"/30.项目文档/00.di/80.在服务中注入其他服务.html",redirect:"/pages/b09aca/"},{name:"v-42a5ab7e",path:"/pages/64784b/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-42a5ab7e").then(t)}},{path:"/pages/64784b/index.html",redirect:"/pages/64784b/"},{path:"/30.项目文档/00.di/90.API文档.html",redirect:"/pages/64784b/"},{name:"v-629eea80",path:"/pages/762b47/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-629eea80").then(t)}},{path:"/pages/762b47/index.html",redirect:"/pages/762b47/"},{path:"/30.项目文档/00.di/91.faq.html",redirect:"/pages/762b47/"},{name:"v-13383ab2",path:"/pages/b3da0e/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-13383ab2").then(t)}},{path:"/pages/b3da0e/index.html",redirect:"/pages/b3da0e/"},{path:"/30.项目文档/00.di/92.案例.html",redirect:"/pages/b3da0e/"},{name:"v-a49916ba",path:"/pages/71016c/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-a49916ba").then(t)}},{path:"/pages/71016c/index.html",redirect:"/pages/71016c/"},{path:"/30.项目文档/00.di/93.资源.html",redirect:"/pages/71016c/"},{name:"v-5eead728",path:"/pages/46481f/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-5eead728").then(t)}},{path:"/pages/46481f/index.html",redirect:"/pages/46481f/"},{path:"/30.项目文档/01.use-vue-service/00.快速开始.html",redirect:"/pages/46481f/"},{name:"v-73f54546",path:"/pages/4497fd/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-73f54546").then(t)}},{path:"/pages/4497fd/index.html",redirect:"/pages/4497fd/"},{path:"/30.项目文档/01.use-vue-service/01.基础教程.html",redirect:"/pages/4497fd/"},{name:"v-1293b6fa",path:"/pages/a03917/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-1293b6fa").then(t)}},{path:"/pages/a03917/index.html",redirect:"/pages/a03917/"},{path:"/30.项目文档/01.use-vue-service/02.进阶教程.html",redirect:"/pages/a03917/"},{name:"v-ebbc0b9e",path:"/pages/3a3a6b/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-ebbc0b9e").then(t)}},{path:"/pages/3a3a6b/index.html",redirect:"/pages/3a3a6b/"},{path:"/30.项目文档/01.use-vue-service/03.应用服务化.html",redirect:"/pages/3a3a6b/"},{name:"v-43156d4a",path:"/pages/60ce48/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-43156d4a").then(t)}},{path:"/pages/60ce48/index.html",redirect:"/pages/60ce48/"},{path:"/30.项目文档/01.use-vue-service/04.组件与Injector.html",redirect:"/pages/60ce48/"},{name:"v-28f80f80",path:"/pages/36ae88/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-28f80f80").then(t)}},{path:"/pages/36ae88/index.html",redirect:"/pages/36ae88/"},{path:"/30.项目文档/01.use-vue-service/90.API文档.html",redirect:"/pages/36ae88/"},{name:"v-dd8aeb38",path:"/pages/e83ee6/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-dd8aeb38").then(t)}},{path:"/pages/e83ee6/index.html",redirect:"/pages/e83ee6/"},{path:"/30.项目文档/01.use-vue-service/91.faq.html",redirect:"/pages/e83ee6/"},{name:"v-13e9637e",path:"/pages/c72e25/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-13e9637e").then(t)}},{path:"/pages/c72e25/index.html",redirect:"/pages/c72e25/"},{path:"/30.项目文档/01.use-vue-service/92.案例.html",redirect:"/pages/c72e25/"},{name:"v-3352929f",path:"/pages/c70da9/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-3352929f").then(t)}},{path:"/pages/c70da9/index.html",redirect:"/pages/c70da9/"},{path:"/30.项目文档/01.use-vue-service/93.资源.html",redirect:"/pages/c70da9/"},{name:"v-dfc1e590",path:"/pages/ac9306/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-dfc1e590").then(t)}},{path:"/pages/ac9306/index.html",redirect:"/pages/ac9306/"},{path:"/30.项目文档/02.use-react-service/00.快速开始.html",redirect:"/pages/ac9306/"},{name:"v-3c50469e",path:"/pages/550423/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-3c50469e").then(t)}},{path:"/pages/550423/index.html",redirect:"/pages/550423/"},{path:"/30.项目文档/03.use-solid-service/00.快速开始.html",redirect:"/pages/550423/"},{name:"v-4ba573aa",path:"/pages/0129d5/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-4ba573aa").then(t)}},{path:"/pages/0129d5/index.html",redirect:"/pages/0129d5/"},{path:"/30.项目文档/04.use-svelte-service/00.快速开始.html",redirect:"/pages/0129d5/"},{name:"v-50bc8525",path:"/archives/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-50bc8525").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-537ab085",path:"/categories/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-537ab085").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-2f058aa5",path:"/tags/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-2f058aa5").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-09f2a40f",path:"/pages/1684b4/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-09f2a40f").then(t)}},{path:"/pages/1684b4/index.html",redirect:"/pages/1684b4/"},{path:"/_posts/2022/01.Nestjs笔记.html",redirect:"/pages/1684b4/"},{name:"v-653cdd76",path:"/pages/b17e7e/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-653cdd76").then(t)}},{path:"/pages/b17e7e/index.html",redirect:"/pages/b17e7e/"},{path:"/_posts/93.component.html",redirect:"/pages/b17e7e/"},{name:"v-390e40a1",path:"/pages/44aecd/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-390e40a1").then(t)}},{path:"/pages/44aecd/index.html",redirect:"/pages/44aecd/"},{path:"/_posts/99.API文档.html",redirect:"/pages/44aecd/"},{name:"v-02ad9e44",path:"/pages/51372a/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-02ad9e44").then(t)}},{path:"/pages/51372a/index.html",redirect:"/pages/51372a/"},{path:"/_posts/A记录与CNAME记录.html",redirect:"/pages/51372a/"},{name:"v-1133a448",path:"/pages/29b8e0/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-1133a448").then(t)}},{path:"/pages/29b8e0/index.html",redirect:"/pages/29b8e0/"},{path:"/_posts/Pure ESM.html",redirect:"/pages/29b8e0/"},{name:"v-7bd86066",path:"/about/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-7bd86066").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/_posts/about.html",redirect:"/about/"},{name:"v-b67a6bf6",path:"/pages/c8faae/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-b67a6bf6").then(t)}},{path:"/pages/c8faae/index.html",redirect:"/pages/c8faae/"},{path:"/_posts/best-practices.html",redirect:"/pages/c8faae/"},{name:"v-21153691",path:"/pages/46748c/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-21153691").then(t)}},{path:"/pages/46748c/index.html",redirect:"/pages/46748c/"},{path:"/_posts/circular_dependency.html",redirect:"/pages/46748c/"},{name:"v-f4fd4036",path:"/pages/45cf91/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-f4fd4036").then(t)}},{path:"/pages/45cf91/index.html",redirect:"/pages/45cf91/"},{path:"/_posts/communication-between-components.html",redirect:"/pages/45cf91/"},{name:"v-d814e4ee",path:"/pages/747704/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-d814e4ee").then(t)}},{path:"/pages/747704/index.html",redirect:"/pages/747704/"},{path:"/_posts/component-and-service.html",redirect:"/pages/747704/"},{name:"v-13d384c5",path:"/pages/6bada4/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-13d384c5").then(t)}},{path:"/pages/6bada4/index.html",redirect:"/pages/6bada4/"},{path:"/_posts/dependency-injection.html",redirect:"/pages/6bada4/"},{name:"v-3c4ee536",path:"/pages/bfd17a/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-3c4ee536").then(t)}},{path:"/pages/bfd17a/index.html",redirect:"/pages/bfd17a/"},{path:"/_posts/frame-analysis.html",redirect:"/pages/bfd17a/"},{name:"v-9f0855b6",path:"/pages/8b25d1/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-9f0855b6").then(t)}},{path:"/pages/8b25d1/index.html",redirect:"/pages/8b25d1/"},{path:"/_posts/framework-comparison.html",redirect:"/pages/8b25d1/"},{name:"v-75939a25",path:"/friends/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-75939a25").then(t)}},{path:"/friends/index.html",redirect:"/friends/"},{path:"/_posts/friend.html",redirect:"/friends/"},{name:"v-eb1da8f6",path:"/pages/37da4b/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-eb1da8f6").then(t)}},{path:"/pages/37da4b/index.html",redirect:"/pages/37da4b/"},{path:"/_posts/frontend-stage.html",redirect:"/pages/37da4b/"},{name:"v-74ab1dd5",path:"/pages/f9d7e8/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-74ab1dd5").then(t)}},{path:"/pages/f9d7e8/index.html",redirect:"/pages/f9d7e8/"},{path:"/_posts/gitee自动同步和部署.html",redirect:"/pages/f9d7e8/"},{name:"v-62bb08c9",path:"/pages/8ab175/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-62bb08c9").then(t)}},{path:"/pages/8ab175/index.html",redirect:"/pages/8ab175/"},{path:"/_posts/json schema入门.html",redirect:"/pages/8ab175/"},{name:"v-1f70189d",path:"/pages/acbdc0/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-1f70189d").then(t)}},{path:"/pages/acbdc0/index.html",redirect:"/pages/acbdc0/"},{path:"/_posts/kubernetes基础概念.html",redirect:"/pages/acbdc0/"},{name:"v-92c74e7e",path:"/pages/84b761/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-92c74e7e").then(t)}},{path:"/pages/84b761/index.html",redirect:"/pages/84b761/"},{path:"/_posts/linux 命令.html",redirect:"/pages/84b761/"},{name:"v-11d9b8ac",path:"/pages/6e93a2/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-11d9b8ac").then(t)}},{path:"/pages/6e93a2/index.html",redirect:"/pages/6e93a2/"},{path:"/_posts/markdown示例文章.html",redirect:"/pages/6e93a2/"},{name:"v-8baa32f8",path:"/pages/8255ce/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-8baa32f8").then(t)}},{path:"/pages/8255ce/index.html",redirect:"/pages/8255ce/"},{path:"/_posts/npmrc总结.html",redirect:"/pages/8255ce/"},{name:"v-46ea4296",path:"/pages/91c82f/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-46ea4296").then(t)}},{path:"/pages/91c82f/index.html",redirect:"/pages/91c82f/"},{path:"/_posts/pnpm使用总结.html",redirect:"/pages/91c82f/"},{name:"v-080301c7",path:"/pages/8b786e/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-080301c7").then(t)}},{path:"/pages/8b786e/index.html",redirect:"/pages/8b786e/"},{path:"/_posts/reactive-analysis.html",redirect:"/pages/8b786e/"},{name:"v-8adb67f4",path:"/pages/5b7b92/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-8adb67f4").then(t)}},{path:"/pages/5b7b92/index.html",redirect:"/pages/5b7b92/"},{path:"/_posts/",redirect:"/pages/5b7b92/"},{name:"v-490a2e94",path:"/pages/fff5cd/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-490a2e94").then(t)}},{path:"/pages/fff5cd/index.html",redirect:"/pages/fff5cd/"},{path:"/_posts/toke和cookie.html",redirect:"/pages/fff5cd/"},{name:"v-2c9d4562",path:"/pages/b11568/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-2c9d4562").then(t)}},{path:"/pages/b11568/index.html",redirect:"/pages/b11568/"},{path:"/_posts/vite支持decorator.html",redirect:"/pages/b11568/"},{name:"v-964a6848",path:"/pages/7dfa32/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-964a6848").then(t)}},{path:"/pages/7dfa32/index.html",redirect:"/pages/7dfa32/"},{path:"/_posts/代理方案调研.html",redirect:"/pages/7dfa32/"},{name:"v-50fdf4f7",path:"/pages/3d42c5/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-50fdf4f7").then(t)}},{path:"/pages/3d42c5/index.html",redirect:"/pages/3d42c5/"},{path:"/_posts/代码托管服务总结.html",redirect:"/pages/3d42c5/"},{name:"v-d38315a6",path:"/pages/7426c9/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-d38315a6").then(t)}},{path:"/pages/7426c9/index.html",redirect:"/pages/7426c9/"},{path:"/_posts/公共服务.html",redirect:"/pages/7426c9/"},{name:"v-27c99f0a",path:"/pages/1fac03/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-27c99f0a").then(t)}},{path:"/pages/1fac03/index.html",redirect:"/pages/1fac03/"},{path:"/_posts/删除git中的敏感数据.html",redirect:"/pages/1fac03/"},{name:"v-2b5187de",path:"/pages/c86144/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-2b5187de").then(t)}},{path:"/pages/c86144/index.html",redirect:"/pages/c86144/"},{path:"/_posts/刻板印象.html",redirect:"/pages/c86144/"},{name:"v-2ad5ddba",path:"/pages/2ac946/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-2ad5ddba").then(t)}},{path:"/pages/2ac946/index.html",redirect:"/pages/2ac946/"},{path:"/_posts/前端和后端的思考.html",redirect:"/pages/2ac946/"},{name:"v-13888698",path:"/pages/de158a/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-13888698").then(t)}},{path:"/pages/de158a/index.html",redirect:"/pages/de158a/"},{path:"/_posts/名言金句.html",redirect:"/pages/de158a/"},{name:"v-266ce9eb",path:"/pages/925b67/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-266ce9eb").then(t)}},{path:"/pages/925b67/index.html",redirect:"/pages/925b67/"},{path:"/_posts/小规模纳税人报税.html",redirect:"/pages/925b67/"},{name:"v-f4156710",path:"/pages/1d6b00/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-f4156710").then(t)}},{path:"/pages/1d6b00/index.html",redirect:"/pages/1d6b00/"},{path:"/_posts/德州扑克之夜.html",redirect:"/pages/1d6b00/"},{name:"v-ab5313be",path:"/pages/46bf00/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-ab5313be").then(t)}},{path:"/pages/46bf00/index.html",redirect:"/pages/46bf00/"},{path:"/_posts/我要做商城.html",redirect:"/pages/46bf00/"},{name:"v-1ab3ab88",path:"/pages/cd1a6e/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-1ab3ab88").then(t)}},{path:"/pages/cd1a6e/index.html",redirect:"/pages/cd1a6e/"},{path:"/_posts/技术内容.html",redirect:"/pages/cd1a6e/"},{name:"v-4a1889c6",path:"/pages/4c0878/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-4a1889c6").then(t)}},{path:"/pages/4c0878/index.html",redirect:"/pages/4c0878/"},{path:"/_posts/生活内容.html",redirect:"/pages/4c0878/"},{name:"v-540c7b98",path:"/pages/67fd5e/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-540c7b98").then(t)}},{path:"/pages/67fd5e/index.html",redirect:"/pages/67fd5e/"},{path:"/_posts/电影观看记录.html",redirect:"/pages/67fd5e/"},{name:"v-70c71972",path:"/pages/0e5286/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-70c71972").then(t)}},{path:"/pages/0e5286/index.html",redirect:"/pages/0e5286/"},{path:"/_posts/空间定位法.html",redirect:"/pages/0e5286/"},{name:"v-fb433546",path:"/pages/942cef/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-fb433546").then(t)}},{path:"/pages/942cef/index.html",redirect:"/pages/942cef/"},{path:"/_posts/通过api获取npm包的所有版本.html",redirect:"/pages/942cef/"},{name:"v-0447f706",path:"/pages/c782dd/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-0447f706").then(t)}},{path:"/pages/c782dd/index.html",redirect:"/pages/c782dd/"},{path:"/_posts/链接库.html",redirect:"/pages/c782dd/"},{name:"v-d37c0f4a",path:"/pages/3734eb/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-d37c0f4a").then(t)}},{path:"/pages/3734eb/index.html",redirect:"/pages/3734eb/"},{path:"/_posts/预渲染原理.html",redirect:"/pages/3734eb/"},{name:"v-ebc99984",path:"/",component:hc,beforeEnter:(n,e,t)=>{ls("Layout","v-ebc99984").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:hc}],gc={title:"kaokei's blog",description:"web前端技术博客,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,React,python,css3,html5,Node,git,github等技术文章。",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["meta",{name:"keywords",content:"前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown"}],["meta",{name:"baidu-site-verification",content:"code-JzonidIhwe"}],["meta",{name:"theme-color",content:"#11a8cd"}],["script",{"data-ad-client":"ca-pub-3912182864105528",async:"async",src:"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"}]],pages:[{title:"di",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"30.项目文档/00.di",imgUrl:"/img/web.png",description:"di"}},title:"di",permalink:"/project/di",sidebar:!1,article:!1,comment:!1,editLink:!1,date:"2021-12-17T10:25:37.000Z"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/00.di.html",relativePath:"00.目录页/00.di.md",key:"v-5e840b50",path:"/project/di/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"use-vue-service",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"30.项目文档/01.use-vue-service",imgUrl:"/img/web.png",description:"use-vue-service"}},title:"use-vue-service",permalink:"/project/use-vue-service",sidebar:!1,article:!1,comment:!1,editLink:!1,date:"2021-12-17T10:25:40.000Z"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.use-vue-service.html",relativePath:"00.目录页/01.use-vue-service.md",key:"v-d5604794",path:"/project/use-vue-service/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"use-react-service",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"30.项目文档/02.use-react-service",imgUrl:"/img/web.png",description:"use-react-service"}},title:"use-react-service",permalink:"/project/use-react-service",sidebar:!1,article:!1,comment:!1,editLink:!1,date:"2021-12-17T10:25:42.000Z"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.use-react-service.html",relativePath:"00.目录页/02.use-react-service.md",key:"v-06567194",path:"/project/use-react-service/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"use-solid-service",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"30.项目文档/03.use-solid-service",imgUrl:"/img/web.png",description:"use-solid-service"}},title:"use-solid-service",permalink:"/project/use-solid-service",sidebar:!1,article:!1,comment:!1,editLink:!1,date:"2021-12-17T10:25:45.000Z"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.use-solid-service.html",relativePath:"00.目录页/03.use-solid-service.md",key:"v-7ac129d6",path:"/project/use-solid-service/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"项目文档",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"30.项目文档",imgUrl:"/img/web.png",description:"项目文档"}},title:"项目文档",permalink:"/project",sidebar:!1,article:!1,comment:!1,editLink:!1,date:"2021-12-17T11:18:27.000Z"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/99.project.html",relativePath:"00.目录页/99.project.md",key:"v-68ff1b36",path:"/project/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"快速开始",frontmatter:{title:"快速开始",date:"2021-12-17T10:30:44.000Z",permalink:"/pages/358991/",categories:["项目文档","di"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/00.di/00.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B.html",relativePath:"30.项目文档/00.di/00.快速开始.md",key:"v-e1cf8cac",path:"/pages/358991/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:11},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:158},{level:2,title:"基本使用",slug:"基本使用",normalizedTitle:"基本使用",charIndex:388},{level:2,title:"使用建议",slug:"使用建议",normalizedTitle:"使用建议",charIndex:1184}],headersStr:"简介 安装 基本使用 使用建议",content:'# 快速开始\n\n\n# 简介\n\n本库是利用 typescript 的 decorator 实现了依赖注入能力的小型工具库。实现过程参考了 Spring, Angular, typedi, InversifyJS等类似的开源实现。\n\n本库一般不是直接用于业务开发，而是作为其他库的依赖，提供统一的依赖注入能力。\n\n\n# 安装\n\nnpm install @kaokei/di reflect-metadata\n\n\n1\n\n\n注意到我们同时安装了 reflect-metadata，这是因为我们需要获取 ts 提供的类型信息。\n\n还需要注意本库是强依赖 typescript 环境的，需要在 tsconfig.js 文件中配置如下两个字段。\n\n提示\n\n"emitDecoratorMetadata": true,\n"experimentalDecorators": true,\n\n\n# 基本使用\n\n最常见的使用场景就是代替手动 new 一个类来获取实例对象，可以通过本库自动获取对象。\n\nimport { Injectable, Injector } from "@kaokei/di";\n\n@Injectable()\nexport class LoggerService {\n  public log(...msg: any[]) {\n    console.log("from logger service ==>", ...msg);\n  }\n}\n\n@Injectable()\nexport class CountService {\n  public count = 0;\n  constructor(private logger: LoggerService) {}\n\n  public addOne() {\n    this.count++;\n    this.logger.log("addOne ==> ", this.count);\n  }\n}\n\n// 实例化一个注入器对象\nconst injector = new Injector();\n\n// 通过注入器对象获取CountService类的实例对象\n// 并且本库会自动注入LoggerService类的实例对象作为CountService的依赖\nconst countService = injector.get(CountService);\n\n// 注意到我们并没有手动的维护LoggerService的注入过程\n// 但是this.logger.log依然可以打印出相应的日志\ncountService.addOne();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 使用建议\n\n建议直接看源码即可，总共也就 400 行代码。\n\n建议搭配测试用例服用效果更佳。单元测试覆盖率已经达到 100%。',normalizedContent:'# 快速开始\n\n\n# 简介\n\n本库是利用 typescript 的 decorator 实现了依赖注入能力的小型工具库。实现过程参考了 spring, angular, typedi, inversifyjs等类似的开源实现。\n\n本库一般不是直接用于业务开发，而是作为其他库的依赖，提供统一的依赖注入能力。\n\n\n# 安装\n\nnpm install @kaokei/di reflect-metadata\n\n\n1\n\n\n注意到我们同时安装了 reflect-metadata，这是因为我们需要获取 ts 提供的类型信息。\n\n还需要注意本库是强依赖 typescript 环境的，需要在 tsconfig.js 文件中配置如下两个字段。\n\n提示\n\n"emitdecoratormetadata": true,\n"experimentaldecorators": true,\n\n\n# 基本使用\n\n最常见的使用场景就是代替手动 new 一个类来获取实例对象，可以通过本库自动获取对象。\n\nimport { injectable, injector } from "@kaokei/di";\n\n@injectable()\nexport class loggerservice {\n  public log(...msg: any[]) {\n    console.log("from logger service ==>", ...msg);\n  }\n}\n\n@injectable()\nexport class countservice {\n  public count = 0;\n  constructor(private logger: loggerservice) {}\n\n  public addone() {\n    this.count++;\n    this.logger.log("addone ==> ", this.count);\n  }\n}\n\n// 实例化一个注入器对象\nconst injector = new injector();\n\n// 通过注入器对象获取countservice类的实例对象\n// 并且本库会自动注入loggerservice类的实例对象作为countservice的依赖\nconst countservice = injector.get(countservice);\n\n// 注意到我们并没有手动的维护loggerservice的注入过程\n// 但是this.logger.log依然可以打印出相应的日志\ncountservice.addone();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 使用建议\n\n建议直接看源码即可，总共也就 400 行代码。\n\n建议搭配测试用例服用效果更佳。单元测试覆盖率已经达到 100%。',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"什么是服务",frontmatter:{title:"什么是服务",date:"2022-01-29T20:55:29.000Z",permalink:"/pages/8dfb90/",categories:["项目文档","di"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/00.di/01.%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1.html",relativePath:"30.项目文档/00.di/01.什么是服务.md",key:"v-24bc85d0",path:"/pages/8dfb90/",headers:[{level:2,title:"服务与服务工厂",slug:"服务与服务工厂",normalizedTitle:"服务与服务工厂",charIndex:114}],headersStr:"服务与服务工厂",content:'# 什么是服务\n\n服务是从英文单词Service翻译过来的。我理解的服务是一个由数据和方法组成的对象，可能只有数据，也可能只有方法。\n\n提示\n\n所以任何数据都可以是服务，只不过一个标准的服务应该既包含数据，也包含方法。\n\n\n# 服务与服务工厂\n\n一个典型的例子就是类与实例化对象。实例化对象是一个服务，类则是服务工厂。\n\nclass CountService {\n  public count = 0;\n\n  public addOne() {\n    this.count++;\n  }\n}\n\nconst countService = new CountService();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上方例子中，CountService就是服务工厂，countService则是服务，这个服务有数据count属性，也有方法addOne。\n\n服务是由服务工厂生产的。在这里就是由类实例化而来。类的实例化过程是一个由抽象到具体的过程。服务的生产过程也是一个由抽象到具体的过程。\n\n服务也可以只有数据，比如现在有一个字符串变量代表网站的主题颜色，希望以服务的形式来表达。\n\nconst theme = "red";\n\nconst useValue = (v) => v;\n\nconst themeService = useValue(theme);\n\n\n1\n2\n3\n4\n5\n\n\n注意到theme完全就是一个字符串而已，最终themeService也只是一摸一样的字符串，那么为什么需要定义一个 useValue 这样的函数呢？\n\n因为想要特意表达出一种抽象到具体的过程。theme只是服务的定义，themeService才是真正的服务对象。\n\n和上面的例子做对比来看：\n\n * theme相当于CountService\n * themeService相当于countService\n * useValue则相当于new关键字。\n\n提示\n\n这里列举的两个例子只是想清晰的解释服务和服务工厂的区别，以及到底什么是服务。 更多的服务和服务工厂的例子请参考什么是Provider。',normalizedContent:'# 什么是服务\n\n服务是从英文单词service翻译过来的。我理解的服务是一个由数据和方法组成的对象，可能只有数据，也可能只有方法。\n\n提示\n\n所以任何数据都可以是服务，只不过一个标准的服务应该既包含数据，也包含方法。\n\n\n# 服务与服务工厂\n\n一个典型的例子就是类与实例化对象。实例化对象是一个服务，类则是服务工厂。\n\nclass countservice {\n  public count = 0;\n\n  public addone() {\n    this.count++;\n  }\n}\n\nconst countservice = new countservice();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上方例子中，countservice就是服务工厂，countservice则是服务，这个服务有数据count属性，也有方法addone。\n\n服务是由服务工厂生产的。在这里就是由类实例化而来。类的实例化过程是一个由抽象到具体的过程。服务的生产过程也是一个由抽象到具体的过程。\n\n服务也可以只有数据，比如现在有一个字符串变量代表网站的主题颜色，希望以服务的形式来表达。\n\nconst theme = "red";\n\nconst usevalue = (v) => v;\n\nconst themeservice = usevalue(theme);\n\n\n1\n2\n3\n4\n5\n\n\n注意到theme完全就是一个字符串而已，最终themeservice也只是一摸一样的字符串，那么为什么需要定义一个 usevalue 这样的函数呢？\n\n因为想要特意表达出一种抽象到具体的过程。theme只是服务的定义，themeservice才是真正的服务对象。\n\n和上面的例子做对比来看：\n\n * theme相当于countservice\n * themeservice相当于countservice\n * usevalue则相当于new关键字。\n\n提示\n\n这里列举的两个例子只是想清晰的解释服务和服务工厂的区别，以及到底什么是服务。 更多的服务和服务工厂的例子请参考什么是provider。',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"什么是Provider",frontmatter:{title:"什么是Provider",date:"2022-01-30T12:29:43.000Z",permalink:"/pages/4828a1/",categories:["项目文档","di"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/00.di/02.%E4%BB%80%E4%B9%88%E6%98%AFProvider.html",relativePath:"30.项目文档/00.di/02.什么是Provider.md",key:"v-73de5164",path:"/pages/4828a1/",headers:[{level:2,title:"4 种不同的 Provider",slug:"_4-种不同的-provider",normalizedTitle:"4 种不同的 provider",charIndex:121},{level:3,title:"useClass",slug:"useclass",normalizedTitle:"useclass",charIndex:291},{level:3,title:"useValue",slug:"usevalue",normalizedTitle:"usevalue",charIndex:223},{level:3,title:"useExisting",slug:"useexisting",normalizedTitle:"useexisting",charIndex:360},{level:3,title:"useFactory",slug:"usefactory",normalizedTitle:"usefactory",charIndex:442}],headersStr:"4 种不同的 Provider useClass useValue useExisting useFactory",content:"# 什么是 Provider\n\n在了解了什么是服务之后，Provider 非常容易理解。Provider 是一个对象，包含了服务名和服务工厂。\n\n服务名又叫作服务标识符，或者叫作Token。\n\n服务工厂代表如何生产一个服务对象出来。\n\n\n# 4 种不同的 Provider\n\nconst injector = new Injector([\n  SomeClass,\n  {\n    provide: someUseValueToken,\n    useValue: 'someValue',\n  },\n  {\n    provide: someUseClassToken,\n    useClass: SomeClass,\n  },\n  {\n    provide: someUseExistingToken,\n    useExisting: AnotherExistingToken,\n  },\n  {\n    provide: someUseFactoryToken,\n    useFactory: (dep1, dep2, dep3...) => {\n      return someValue\n    },\n    deps: [dep1Token, dep2Token, dep3Token...],\n  },\n]);\n\nconst service1 = injector.get(SomeClass);\nconst service2 = injector.get(someUseValueToken);\nconst service3 = injector.get(someUseClassToken);\nconst service4 = injector.get(someUseExistingToken);\nconst service5 = injector.get(someUseFactoryToken);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n上面代码看似有 5 种不同的 Provider，是因为第一种的SomeClass是一种简写的 Provider，完整版本的代码是这样的。\n\n{\n  provide: SomeClass,\n  useClass: SomeClass,\n}\n\n\n1\n2\n3\n4\n\n\n也就是说 SomeClass 既可以作为服务名，又可以作为服务工厂。这也是用类来定义服务的优点。\n\nProvider 中的 provide 参数代表服务名，服务名是用于后续获取服务时提供的参数，也就是injector.get(服务名)。服务名基本可以是除了 Falsy 值以外的任意数据。常见的服务名有类，字符串，Symbol。\n\nProvider 中的另一个useXXX属性定义了服务工厂，也就是定义了如何来生产一个服务对象。\n\n目前这 4 种 Provider 是完全参考的 Angular 的概念。\n\n\n# useClass\n\nuseClass 属性一定是一个类，本库会采用new关键字来生产一个服务对象。\n\n\n# useValue\n\nuseValue 属性可以是任意数据，包括函数。因为它会直接返回该数据作为服务对象。\n\n\n# useExisting\n\nuseExisting 属性一定是一个已经声明的服务名。它的作用是用这个新的服务名来生成一个服务对象。\n\n\n# useFactory\n\nuseFactory 属性一定是一个函数，该函数的返回值作为服务对象。该函数可以有若干参数，参数需要通过deps属性来定义，deps 是一个服务名数组。",normalizedContent:"# 什么是 provider\n\n在了解了什么是服务之后，provider 非常容易理解。provider 是一个对象，包含了服务名和服务工厂。\n\n服务名又叫作服务标识符，或者叫作token。\n\n服务工厂代表如何生产一个服务对象出来。\n\n\n# 4 种不同的 provider\n\nconst injector = new injector([\n  someclass,\n  {\n    provide: someusevaluetoken,\n    usevalue: 'somevalue',\n  },\n  {\n    provide: someuseclasstoken,\n    useclass: someclass,\n  },\n  {\n    provide: someuseexistingtoken,\n    useexisting: anotherexistingtoken,\n  },\n  {\n    provide: someusefactorytoken,\n    usefactory: (dep1, dep2, dep3...) => {\n      return somevalue\n    },\n    deps: [dep1token, dep2token, dep3token...],\n  },\n]);\n\nconst service1 = injector.get(someclass);\nconst service2 = injector.get(someusevaluetoken);\nconst service3 = injector.get(someuseclasstoken);\nconst service4 = injector.get(someuseexistingtoken);\nconst service5 = injector.get(someusefactorytoken);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n上面代码看似有 5 种不同的 provider，是因为第一种的someclass是一种简写的 provider，完整版本的代码是这样的。\n\n{\n  provide: someclass,\n  useclass: someclass,\n}\n\n\n1\n2\n3\n4\n\n\n也就是说 someclass 既可以作为服务名，又可以作为服务工厂。这也是用类来定义服务的优点。\n\nprovider 中的 provide 参数代表服务名，服务名是用于后续获取服务时提供的参数，也就是injector.get(服务名)。服务名基本可以是除了 falsy 值以外的任意数据。常见的服务名有类，字符串，symbol。\n\nprovider 中的另一个usexxx属性定义了服务工厂，也就是定义了如何来生产一个服务对象。\n\n目前这 4 种 provider 是完全参考的 angular 的概念。\n\n\n# useclass\n\nuseclass 属性一定是一个类，本库会采用new关键字来生产一个服务对象。\n\n\n# usevalue\n\nusevalue 属性可以是任意数据，包括函数。因为它会直接返回该数据作为服务对象。\n\n\n# useexisting\n\nuseexisting 属性一定是一个已经声明的服务名。它的作用是用这个新的服务名来生成一个服务对象。\n\n\n# usefactory\n\nusefactory 属性一定是一个函数，该函数的返回值作为服务对象。该函数可以有若干参数，参数需要通过deps属性来定义，deps 是一个服务名数组。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"什么是Injector",frontmatter:{title:"什么是Injector",date:"2022-02-06T17:48:17.000Z",permalink:"/pages/d699f9/",categories:["项目文档","di"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/00.di/03.%E4%BB%80%E4%B9%88%E6%98%AFInjector.html",relativePath:"30.项目文档/00.di/03.什么是Injector.md",key:"v-e08cd448",path:"/pages/d699f9/",headers:[{level:2,title:"如果没有 Injector",slug:"如果没有-injector",normalizedTitle:"如果没有 injector",charIndex:167}],headersStr:"如果没有 Injector",content:'# 什么是 Injector\n\nInjector 是代码实现的产物，并不是一定需要它，只不过有了 Injector 可以更好的组织代码。\n\n就像桌子上摆放了一堆水果，我们不会说桌子上摆放了一堆苹果、梨子、香蕉、橘子、菠萝。因为这么说太过于啰嗦了。\n\n提示\n\nInjector 又叫作注入器、Container、依赖注入容器。\n\n\n# 如果没有 Injector\n\n回忆一下什么是 Provider中，我们主要是做了两件事。\n\n第一件事是声明 providers，第二件事是获取服务对象。如果没有 Injector，我们可能需要定义这样的两个 API。\n\n// 定义providers\nconst providers = [...]\n// 声明providers\nsetProviders(providers);\n// 获取服务对象\nconst someService = getService(SomeToken);\n\n\n1\n2\n3\n4\n5\n6\n\n\n可以看出来这样的两个 API 显得比较分散，不够内聚。更加关键的问题是这样的实现隐含着全局只能有一个 providers。 就算我们把setProviders实现成追加模式而不是替换模式。仍然改变不了全局只有一个 providers 的事实。\n\n相反通过 Injector，可以让 API 更加内聚，而且我们可以实例化多个 injector 对象，然后组合这些 injector 对象形成一颗 injector 树。从而支持分级注入的特性。参考这里以及参考这里\n\n// 注意这里只是伪代码，只是用于演示什么是分级注入特性\n// 注意@kaokie/di中的Injector的实际用法和下面的Injector并不一致\nconst parentInjector = new Injector();\nconst childInjector = new Injector();\nchildInjector.parent = parentInjector;\n\nparentInjector.defineKeyValue("tokenA", ClassA);\nchildInjector.defineKeyValue("tokenB", ClassB);\n\n// 注意到childInjector中并没有定义tokenA，但是仍然可以获取到服务实例\nconst serviceA = childInjector.getValueByKey("tokenA");\nconst serviceB = childInjector.getValueByKey("tokenB");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nInjector 源码',normalizedContent:'# 什么是 injector\n\ninjector 是代码实现的产物，并不是一定需要它，只不过有了 injector 可以更好的组织代码。\n\n就像桌子上摆放了一堆水果，我们不会说桌子上摆放了一堆苹果、梨子、香蕉、橘子、菠萝。因为这么说太过于啰嗦了。\n\n提示\n\ninjector 又叫作注入器、container、依赖注入容器。\n\n\n# 如果没有 injector\n\n回忆一下什么是 provider中，我们主要是做了两件事。\n\n第一件事是声明 providers，第二件事是获取服务对象。如果没有 injector，我们可能需要定义这样的两个 api。\n\n// 定义providers\nconst providers = [...]\n// 声明providers\nsetproviders(providers);\n// 获取服务对象\nconst someservice = getservice(sometoken);\n\n\n1\n2\n3\n4\n5\n6\n\n\n可以看出来这样的两个 api 显得比较分散，不够内聚。更加关键的问题是这样的实现隐含着全局只能有一个 providers。 就算我们把setproviders实现成追加模式而不是替换模式。仍然改变不了全局只有一个 providers 的事实。\n\n相反通过 injector，可以让 api 更加内聚，而且我们可以实例化多个 injector 对象，然后组合这些 injector 对象形成一颗 injector 树。从而支持分级注入的特性。参考这里以及参考这里\n\n// 注意这里只是伪代码，只是用于演示什么是分级注入特性\n// 注意@kaokie/di中的injector的实际用法和下面的injector并不一致\nconst parentinjector = new injector();\nconst childinjector = new injector();\nchildinjector.parent = parentinjector;\n\nparentinjector.definekeyvalue("tokena", classa);\nchildinjector.definekeyvalue("tokenb", classb);\n\n// 注意到childinjector中并没有定义tokena，但是仍然可以获取到服务实例\nconst servicea = childinjector.getvaluebykey("tokena");\nconst serviceb = childinjector.getvaluebykey("tokenb");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\ninjector 源码',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"什么是依赖注入",frontmatter:{title:"什么是依赖注入",date:"2022-02-08T21:22:12.000Z",permalink:"/pages/53952f/",categories:["项目文档","di"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/00.di/04.%E4%BB%80%E4%B9%88%E6%98%AF%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html",relativePath:"30.项目文档/00.di/04.什么是依赖注入.md",key:"v-08ae0b36",path:"/pages/53952f/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:14},{level:2,title:"什么是依赖",slug:"什么是依赖",normalizedTitle:"什么是依赖",charIndex:2},{level:2,title:"什么是注入",slug:"什么是注入",normalizedTitle:"什么是注入",charIndex:637},{level:2,title:"依赖注入的简单实现",slug:"依赖注入的简单实现",normalizedTitle:"依赖注入的简单实现",charIndex:2101},{level:2,title:"在 vue 中使用依赖注入",slug:"在-vue-中使用依赖注入",normalizedTitle:"在 vue 中使用依赖注入",charIndex:3827},{level:2,title:"依赖注入 vs import/export",slug:"依赖注入-vs-import-export",normalizedTitle:"依赖注入 vs import/export",charIndex:4341},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:4851}],headersStr:"简介 什么是依赖 什么是注入 依赖注入的简单实现 在 vue 中使用依赖注入 依赖注入 vs import/export 参考文章",content:'# 什么是依赖注入\n\n\n# 简介\n\n依赖注入的概念可以参考 Angular 的文档，Angular 中的依赖注入。\n\n关于什么是依赖注入，我在网上搜索了很多文章，专业术语也有很多，看的我迷迷糊糊的。我尝试记录一下我自己的理解。\n\n首先从名字入手，依赖注入可以分成依赖和注入。\n\n\n# 什么是依赖\n\n在讨论依赖之前，必须先了解什么是服务，不考虑边界情况下，可以把服务理解为数据和方法的集合。\n\n一般我们会通过实例化一个类来得到这个服务对象。我们可以想象这个类的某个实例属性有可能又是另一个类的实例对象。这个过程可以一直进行下去。比如这样的依赖关系图：\n\nA --\x3e B、C、D\nB --\x3e C、D\nC --\x3e D、E\nD --\x3e E、F\nE --\x3e F\nF 没有依赖\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面的依赖图代表 A 这个类有三个实例属性b、c、d分别是B、C、D这三个类的实例对象。意味着A类是依赖B、C、D这 3 个类的。 而B类又是依赖C、D这两个类的。依次类推我们可以知道C、D、E这三个类的依赖，注意到F类是没有依赖的，所以这个例子中不存在循环依赖。\n\n当我们说到依赖这两个字时，其实依赖既可以是动词又可以是名词，作动词时可以说类 A 依赖类 B，C，D。作名词时类 B，C，D 就是类 A 的依赖。\n\n提示\n\n这里的例子是用的类作为服务工厂，抽象的说应该是从服务工厂生产一个服务 A 时，必须先生产另一个服务 B，此时服务 B 就是服务 A 的依赖。\n\n\n# 什么是注入\n\n在了解了什么是依赖之后，注入就非常简单了，比如 A 依赖 B，那么通过某种手段把 B 注入到 A 的过程就是注入。\n\n常用的注入手段有 3 种，构造函数注入，属性注入，setter 注入。\n\n先看看在没有依赖注入框架的帮助下，我们怎么手动实现注入。\n\nclass B {\n  name = "B";\n}\n\nclass A {\n  name = "A";\n  b: B;\n  constructor(b: B) {\n    this.b = b;\n  }\n}\n\nconst b = new B();\n// 手动通过构造函数注入\nconst a = new A(b);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nclass B {\n  name = "B";\n}\nclass A {\n  name = "A";\n  b: B;\n}\n\nconst b = new B();\nconst a = new A();\n// 手动通过属性注入\na.b = b;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nclass B {\n  name = "B";\n}\nclass A {\n  name = "A";\n  b: B;\n\n  setB(b: B) {\n    this.b = b;\n  }\n}\n\nconst b = new B();\nconst a = new A();\n// 手动通过setter注入\na.setB(b);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n以上代码展示了 3 种手动注入的过程，下面介绍依赖注入框架怎么实现类似的功能。\n\nimport { Injectable, Injector } from "@kaokei/di";\n\n@Injectable()\nclass B {\n  name = "B";\n}\n\n@Injectable()\nclass A {\n  name = "A";\n  constructor(public b: B) {}\n}\n\nconst injector = new Injector();\n// 依赖注入框架会自动把B注入到A中-通过构造函数的方式\nconst a = injector.get(A);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nimport { Injectable, Injector, Inject } from "@kaokei/di";\n\n@Injectable()\nclass B {\n  name = "B";\n}\n\n@Injectable()\nclass A {\n  name = "A";\n  @Inject()\n  b: B;\n}\n\nconst injector = new Injector();\n// 依赖注入框架会自动把B注入到A中-通过属性注入的方式\nconst a = injector.get(A);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n提示\n\n虽然有些框架（Spring）实现了 setter 注入，不过本库并没有支持 setter 注入，个人觉得在前端中没有必要。\n\n和上面的手动的实例化过程对比，是不是发现这样写的代码就简单多了，这就是依赖注入框架的魅力，实际上依赖关系越复杂，依赖注入框架的优势就越明显。\n\n\n# 依赖注入的简单实现\n\n我的总结是依赖注入实在没有什么技术含量，也没有什么高大上的地方。不要被陌生的技术名词给吓到了。本质上就是 Key-Value 的魔法。比如：\n\n// 内部使用map来记录对应关系\ndefineKeyValue("tokenA", "valueA");\n// 再通过map.get(key)获取数据即可\nconst value = getValueByKey("tokenA");\n\n\n1\n2\n3\n4\n\n\n可以说这就是最简单的依赖注入的简单实现。但是它实在是太简单了，处理的场景有限，所以价值不大。至少要再加上类的实例化能力。\n\n// 内部使用map来记录对应关系\ndefineKeyValue("tokenA", ClassA);\n// 再通过map.get(key)获取到ClassA，这里判断是一个类，则实例化后返回一个对象，否则直接返回\nconst instanceOfClassA = getValueByKey("tokenA");\n\n\n1\n2\n3\n4\n\n\n现在我们这个简易的依赖注入库实现了两种能力，如果判断是类，则去实例化；否值直接返回。我们可以沿着这个思路继续添加新能力。比如如果是普通函数，那么就当作普通函数来执行，然后把这个函数的返回值当作服务返回，这样我们就有三种能力了。\n\n主要是介绍这种扩展的思路，只要有这种扩展的思路，我们就可以继续扩展更多的能力，无非就是添加一个if-else分支的事情。\n\n排除掉这种扩展思路本身，我们的依赖注入框架还有什么局限性吗？\n\n其实还有命名空间单一的问题。显然上面所有的数据都处于同一个全局命名空间下。因为defineKeyValue和getValueByKey是一个全局函数。那么所有的配置信息就只有一份。这种状况在大多数场景应该也没有什么问题。但是确实还可以继续提升一下。\n\n我们需要继续引入一个新的概念，就是Injector。通过下面的伪代码我们可以快速了解为什么需要 Injector。参考这里可以了解什么是 Injector。\n\n// 注意这里只是伪代码，只是用于演示什么是分级注入特性\n// 注意@kaokie/di中的Injector的实际用法和下面的Injector并不一致\nconst parentInjector = new Injector();\nconst childInjector = new Injector();\nchildInjector.parent = parentInjector;\n\nparentInjector.defineKeyValue("tokenA", ClassA);\nchildInjector.defineKeyValue("tokenB", ClassB);\n\n// 注意到childInjector中并没有定义tokenA，但是仍然可以获取到服务实例\nconst serviceA = childInjector.getValueByKey("tokenA");\nconst serviceB = childInjector.getValueByKey("tokenB");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n以上伪代码展示了分层注入的特性，之所以引入 Injector 这个概念主要是为了避免只有全局一份配置信息。我们可以做到每次实例化一个 Injector 对象，这个 Injector 对象就具有依赖注入的能力；除此之外我们还可以给 Injector 对象增加一个 parent 属性，从而可以把 Injector 对象关联起来，如果当前 Injector 对象中找不到某个服务，就会从其 parent Injector 对象中寻找服务，直到根 Injector 为空。\n\n提示\n\n以上是从服务配置和获取服务这两个角度来剖析了如何简单实现一个依赖注入框架。当然如果要处理依赖的依赖，甚至循环依赖等复杂场景，还需要其他方面的支持。比如 typescript 以及 decorator。不过这属于技术细节，不影响理解整体概念，这里不再细述。有兴趣可以直接参考源代码即可。\n\n\n# 在 vue 中使用依赖注入\n\n以上是从依赖注入本身的角度来思考的，和具体业务是无关的。考虑到在具体前端的场景下，比如在 vue 中，应该怎样去结合使用呢？\n\n这里提供一个适用于 vue 的依赖注入框架@kaokei/use-vue-service，该库参考 angular 把 Injector 绑定在组件上，默认根 Injector 是对应的根组件上，可以理解为公共的全局的命名空间。\n\n如果在业务上认为某个服务和某个组件是绑定的，就需要用到 declareProviders([CountService])。这行代码意味着当前组件会关联一个 Injector，并且配置了一个 CountService 服务。同时也意味着，在当前组件及其子孙组件中调用useService时，一定会从这个 Injector 中获取到 CountService 服务实例（前提是子孙组件不再定义同样的服务declareProviders([CountService])）。这就是上面提到的分层注入的特性。\n\n这种寻找机制和原型链寻找属性的机制非常相似，也就是底层的命名空间中的同名属性会覆盖上层命名空间的同名属性。\n\n具体可以参考文档\n\n\n# 依赖注入 vs import/export\n\n 1. import/export 适合单例，单例可以是服务工厂本身，也可以是已经实例化的服务对象。\n 2. import/export 导致业务强制依赖某个服务，不存在干预服务创建过程的可能性。因为我们一般会直接 import 一个服务本身，然后在业务代码中使用这个服务，这样就导致业务直接依赖这个服务对象。就算我们 import 的是服务工厂，如果我们还是在业务代码中手动通过服务工厂去创建服务，那么仍然是耦合的，而且不同业务代码会得到不同的服务对象。\n 3. 依赖注入功能是离不开 import/export 的，比如在依赖注入场景中类 A 依赖类 B，显然是需要在类 A 中 import 类 B 的。\n 4. 依赖注入使业务解藕了依赖声明和依赖的实例化。比如业务代码声明依赖 LoggerService，但是可以通过配置修改为 OtherLoggerService 的实例。\n 5. Vue3 跨组件共享数据，为何要用 provide/inject？直接 export/import 数据行吗？\n 6. 前端什么时候用 import 什么时候用依赖注入?\n\n\n# 参考文章\n\n * 依赖注入 和 new 一个实例有什么区别吗？\n * 不使用依赖注入到处 new 的优缺点？\n * 自动注入到底比 new 好在哪？\n * 为什么我们需要依赖注入？\n * 为什么前端会出现依赖注入这种东西，什么场景下会用到？',normalizedContent:'# 什么是依赖注入\n\n\n# 简介\n\n依赖注入的概念可以参考 angular 的文档，angular 中的依赖注入。\n\n关于什么是依赖注入，我在网上搜索了很多文章，专业术语也有很多，看的我迷迷糊糊的。我尝试记录一下我自己的理解。\n\n首先从名字入手，依赖注入可以分成依赖和注入。\n\n\n# 什么是依赖\n\n在讨论依赖之前，必须先了解什么是服务，不考虑边界情况下，可以把服务理解为数据和方法的集合。\n\n一般我们会通过实例化一个类来得到这个服务对象。我们可以想象这个类的某个实例属性有可能又是另一个类的实例对象。这个过程可以一直进行下去。比如这样的依赖关系图：\n\na --\x3e b、c、d\nb --\x3e c、d\nc --\x3e d、e\nd --\x3e e、f\ne --\x3e f\nf 没有依赖\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面的依赖图代表 a 这个类有三个实例属性b、c、d分别是b、c、d这三个类的实例对象。意味着a类是依赖b、c、d这 3 个类的。 而b类又是依赖c、d这两个类的。依次类推我们可以知道c、d、e这三个类的依赖，注意到f类是没有依赖的，所以这个例子中不存在循环依赖。\n\n当我们说到依赖这两个字时，其实依赖既可以是动词又可以是名词，作动词时可以说类 a 依赖类 b，c，d。作名词时类 b，c，d 就是类 a 的依赖。\n\n提示\n\n这里的例子是用的类作为服务工厂，抽象的说应该是从服务工厂生产一个服务 a 时，必须先生产另一个服务 b，此时服务 b 就是服务 a 的依赖。\n\n\n# 什么是注入\n\n在了解了什么是依赖之后，注入就非常简单了，比如 a 依赖 b，那么通过某种手段把 b 注入到 a 的过程就是注入。\n\n常用的注入手段有 3 种，构造函数注入，属性注入，setter 注入。\n\n先看看在没有依赖注入框架的帮助下，我们怎么手动实现注入。\n\nclass b {\n  name = "b";\n}\n\nclass a {\n  name = "a";\n  b: b;\n  constructor(b: b) {\n    this.b = b;\n  }\n}\n\nconst b = new b();\n// 手动通过构造函数注入\nconst a = new a(b);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nclass b {\n  name = "b";\n}\nclass a {\n  name = "a";\n  b: b;\n}\n\nconst b = new b();\nconst a = new a();\n// 手动通过属性注入\na.b = b;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nclass b {\n  name = "b";\n}\nclass a {\n  name = "a";\n  b: b;\n\n  setb(b: b) {\n    this.b = b;\n  }\n}\n\nconst b = new b();\nconst a = new a();\n// 手动通过setter注入\na.setb(b);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n以上代码展示了 3 种手动注入的过程，下面介绍依赖注入框架怎么实现类似的功能。\n\nimport { injectable, injector } from "@kaokei/di";\n\n@injectable()\nclass b {\n  name = "b";\n}\n\n@injectable()\nclass a {\n  name = "a";\n  constructor(public b: b) {}\n}\n\nconst injector = new injector();\n// 依赖注入框架会自动把b注入到a中-通过构造函数的方式\nconst a = injector.get(a);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nimport { injectable, injector, inject } from "@kaokei/di";\n\n@injectable()\nclass b {\n  name = "b";\n}\n\n@injectable()\nclass a {\n  name = "a";\n  @inject()\n  b: b;\n}\n\nconst injector = new injector();\n// 依赖注入框架会自动把b注入到a中-通过属性注入的方式\nconst a = injector.get(a);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n提示\n\n虽然有些框架（spring）实现了 setter 注入，不过本库并没有支持 setter 注入，个人觉得在前端中没有必要。\n\n和上面的手动的实例化过程对比，是不是发现这样写的代码就简单多了，这就是依赖注入框架的魅力，实际上依赖关系越复杂，依赖注入框架的优势就越明显。\n\n\n# 依赖注入的简单实现\n\n我的总结是依赖注入实在没有什么技术含量，也没有什么高大上的地方。不要被陌生的技术名词给吓到了。本质上就是 key-value 的魔法。比如：\n\n// 内部使用map来记录对应关系\ndefinekeyvalue("tokena", "valuea");\n// 再通过map.get(key)获取数据即可\nconst value = getvaluebykey("tokena");\n\n\n1\n2\n3\n4\n\n\n可以说这就是最简单的依赖注入的简单实现。但是它实在是太简单了，处理的场景有限，所以价值不大。至少要再加上类的实例化能力。\n\n// 内部使用map来记录对应关系\ndefinekeyvalue("tokena", classa);\n// 再通过map.get(key)获取到classa，这里判断是一个类，则实例化后返回一个对象，否则直接返回\nconst instanceofclassa = getvaluebykey("tokena");\n\n\n1\n2\n3\n4\n\n\n现在我们这个简易的依赖注入库实现了两种能力，如果判断是类，则去实例化；否值直接返回。我们可以沿着这个思路继续添加新能力。比如如果是普通函数，那么就当作普通函数来执行，然后把这个函数的返回值当作服务返回，这样我们就有三种能力了。\n\n主要是介绍这种扩展的思路，只要有这种扩展的思路，我们就可以继续扩展更多的能力，无非就是添加一个if-else分支的事情。\n\n排除掉这种扩展思路本身，我们的依赖注入框架还有什么局限性吗？\n\n其实还有命名空间单一的问题。显然上面所有的数据都处于同一个全局命名空间下。因为definekeyvalue和getvaluebykey是一个全局函数。那么所有的配置信息就只有一份。这种状况在大多数场景应该也没有什么问题。但是确实还可以继续提升一下。\n\n我们需要继续引入一个新的概念，就是injector。通过下面的伪代码我们可以快速了解为什么需要 injector。参考这里可以了解什么是 injector。\n\n// 注意这里只是伪代码，只是用于演示什么是分级注入特性\n// 注意@kaokie/di中的injector的实际用法和下面的injector并不一致\nconst parentinjector = new injector();\nconst childinjector = new injector();\nchildinjector.parent = parentinjector;\n\nparentinjector.definekeyvalue("tokena", classa);\nchildinjector.definekeyvalue("tokenb", classb);\n\n// 注意到childinjector中并没有定义tokena，但是仍然可以获取到服务实例\nconst servicea = childinjector.getvaluebykey("tokena");\nconst serviceb = childinjector.getvaluebykey("tokenb");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n以上伪代码展示了分层注入的特性，之所以引入 injector 这个概念主要是为了避免只有全局一份配置信息。我们可以做到每次实例化一个 injector 对象，这个 injector 对象就具有依赖注入的能力；除此之外我们还可以给 injector 对象增加一个 parent 属性，从而可以把 injector 对象关联起来，如果当前 injector 对象中找不到某个服务，就会从其 parent injector 对象中寻找服务，直到根 injector 为空。\n\n提示\n\n以上是从服务配置和获取服务这两个角度来剖析了如何简单实现一个依赖注入框架。当然如果要处理依赖的依赖，甚至循环依赖等复杂场景，还需要其他方面的支持。比如 typescript 以及 decorator。不过这属于技术细节，不影响理解整体概念，这里不再细述。有兴趣可以直接参考源代码即可。\n\n\n# 在 vue 中使用依赖注入\n\n以上是从依赖注入本身的角度来思考的，和具体业务是无关的。考虑到在具体前端的场景下，比如在 vue 中，应该怎样去结合使用呢？\n\n这里提供一个适用于 vue 的依赖注入框架@kaokei/use-vue-service，该库参考 angular 把 injector 绑定在组件上，默认根 injector 是对应的根组件上，可以理解为公共的全局的命名空间。\n\n如果在业务上认为某个服务和某个组件是绑定的，就需要用到 declareproviders([countservice])。这行代码意味着当前组件会关联一个 injector，并且配置了一个 countservice 服务。同时也意味着，在当前组件及其子孙组件中调用useservice时，一定会从这个 injector 中获取到 countservice 服务实例（前提是子孙组件不再定义同样的服务declareproviders([countservice])）。这就是上面提到的分层注入的特性。\n\n这种寻找机制和原型链寻找属性的机制非常相似，也就是底层的命名空间中的同名属性会覆盖上层命名空间的同名属性。\n\n具体可以参考文档\n\n\n# 依赖注入 vs import/export\n\n 1. import/export 适合单例，单例可以是服务工厂本身，也可以是已经实例化的服务对象。\n 2. import/export 导致业务强制依赖某个服务，不存在干预服务创建过程的可能性。因为我们一般会直接 import 一个服务本身，然后在业务代码中使用这个服务，这样就导致业务直接依赖这个服务对象。就算我们 import 的是服务工厂，如果我们还是在业务代码中手动通过服务工厂去创建服务，那么仍然是耦合的，而且不同业务代码会得到不同的服务对象。\n 3. 依赖注入功能是离不开 import/export 的，比如在依赖注入场景中类 a 依赖类 b，显然是需要在类 a 中 import 类 b 的。\n 4. 依赖注入使业务解藕了依赖声明和依赖的实例化。比如业务代码声明依赖 loggerservice，但是可以通过配置修改为 otherloggerservice 的实例。\n 5. vue3 跨组件共享数据，为何要用 provide/inject？直接 export/import 数据行吗？\n 6. 前端什么时候用 import 什么时候用依赖注入?\n\n\n# 参考文章\n\n * 依赖注入 和 new 一个实例有什么区别吗？\n * 不使用依赖注入到处 new 的优缺点？\n * 自动注入到底比 new 好在哪？\n * 为什么我们需要依赖注入？\n * 为什么前端会出现依赖注入这种东西，什么场景下会用到？',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"在服务中注入其他服务",frontmatter:{title:"在服务中注入其他服务",date:"2022-01-30T12:46:06.000Z",permalink:"/pages/b09aca/",categories:["项目文档","di"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/00.di/80.%E5%9C%A8%E6%9C%8D%E5%8A%A1%E4%B8%AD%E6%B3%A8%E5%85%A5%E5%85%B6%E4%BB%96%E6%9C%8D%E5%8A%A1.html",relativePath:"30.项目文档/00.di/80.在服务中注入其他服务.md",key:"v-d7b0d4dc",path:"/pages/b09aca/",headers:[{level:2,title:"没有依赖的服务",slug:"没有依赖的服务",normalizedTitle:"没有依赖的服务",charIndex:2},{level:2,title:"通过构造函数注入依赖",slug:"通过构造函数注入依赖",normalizedTitle:"通过构造函数注入依赖",charIndex:182},{level:2,title:"通过实例属性注入依赖",slug:"通过实例属性注入依赖",normalizedTitle:"通过实例属性注入依赖",charIndex:750},{level:2,title:"复杂例子",slug:"复杂例子",normalizedTitle:"复杂例子",charIndex:1272}],headersStr:"没有依赖的服务 通过构造函数注入依赖 通过实例属性注入依赖 复杂例子",content:'# 没有依赖的服务\n\nimport { Injectable } from "@kaokei/di";\n\n@Injectable()\nexport class A {\n  name = "A";\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n很显然这是最简单的场景，这个服务没有任何的依赖，只需要使用@Injectable()这个装饰器声明一下这个服务可注入即可。\n\n\n# 通过构造函数注入依赖\n\nimport { Injectable, Inject } from "@kaokei/di";\n\n@Injectable()\nexport class B {\n  name = "B";\n}\n\n@Injectable()\nexport class C {\n  name = "C";\n}\n\n@Injectable()\nexport class A {\n  name = "A";\n  constructor(public b: B, @Inject(C) public c: C) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上方代码展示了类 A 依赖类 B 和类 C。\n\n在注入 b 时，并没有使用@Inject，这是因为本库可以从 b 的类型中推导出来 b 的类型时 B，而 B 是一个类，那么就会注入一个 B 类的实例化对象。\n\n在注入 c 时，则明确使用了@Inject，此时就直接使用@Inject的参数 C 来注入一个实例化对象。当然这里确实时多此一举没有必要，但是在有些特殊场景下，我们可以修改注入其他服务@Inject(AnotherC)，这样实例属性 c 的类型还是 C，但是实际上指向的是一个AnotherC的实例化对象。\n\n\n# 通过实例属性注入依赖\n\nimport { Injectable, Inject } from "@kaokei/di";\n\n@Injectable()\nexport class B {\n  name = "B";\n}\n\n@Injectable()\nexport class C {\n  name = "C";\n}\n\n@Injectable()\nexport class A {\n  name = "A";\n  @Inject()\n  b!: B;\n  @Inject(C)\n  c!: C;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n可以直接在实例属性上使用@Inject来注入服务对象，只不过属性注入的@Inject是不能省略的，而构造函数中可以省略。\n\n虽然属性注入不能省略@Inejct，但是可以省略@Inject的参数。如果没有参数则会通过属性的类型来推导应该注入什么服务。当然也可以不省略进行明确的注入。\n\n提示\n\n虽然上面说到属性注入可以省略@Inject的参数，那也只能省略属性类型是类的场景，如果属性类型是一个 interface，显然是不行的。\n\n\n# 复杂例子\n\n// 这里展示了一个复杂的类之间的依赖关系\nA --\x3e B、C、D\nB --\x3e C、D\nC --\x3e D、E\nD --\x3e E、F\nE --\x3e F\nF 没有依赖\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nimport { Injectable, Inject } from "@kaokei/di";\n\n@Injectable()\nexport class F {\n  name = "F";\n}\n\n@Injectable()\nexport class E {\n  name = "E";\n  @Inject()\n  f!: F;\n}\n\n@Injectable()\nexport class D {\n  name = "D";\n  @Inject()\n  e!: e;\n  @Inject()\n  f!: F;\n}\n\n@Injectable()\nexport class C {\n  name = "C";\n  constructor(public d: D, public e: E) {}\n}\n\n@Injectable()\nexport class B {\n  name = "B";\n  @Inject()\n  c!: C;\n  constructor(public d: D) {}\n}\n\n@Injectable()\nexport class A {\n  name = "A";\n  constructor(public b: B, public c: C, public d: D) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n上面的例子展示了可以混用构造函数注入和属性注入。',normalizedContent:'# 没有依赖的服务\n\nimport { injectable } from "@kaokei/di";\n\n@injectable()\nexport class a {\n  name = "a";\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n很显然这是最简单的场景，这个服务没有任何的依赖，只需要使用@injectable()这个装饰器声明一下这个服务可注入即可。\n\n\n# 通过构造函数注入依赖\n\nimport { injectable, inject } from "@kaokei/di";\n\n@injectable()\nexport class b {\n  name = "b";\n}\n\n@injectable()\nexport class c {\n  name = "c";\n}\n\n@injectable()\nexport class a {\n  name = "a";\n  constructor(public b: b, @inject(c) public c: c) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上方代码展示了类 a 依赖类 b 和类 c。\n\n在注入 b 时，并没有使用@inject，这是因为本库可以从 b 的类型中推导出来 b 的类型时 b，而 b 是一个类，那么就会注入一个 b 类的实例化对象。\n\n在注入 c 时，则明确使用了@inject，此时就直接使用@inject的参数 c 来注入一个实例化对象。当然这里确实时多此一举没有必要，但是在有些特殊场景下，我们可以修改注入其他服务@inject(anotherc)，这样实例属性 c 的类型还是 c，但是实际上指向的是一个anotherc的实例化对象。\n\n\n# 通过实例属性注入依赖\n\nimport { injectable, inject } from "@kaokei/di";\n\n@injectable()\nexport class b {\n  name = "b";\n}\n\n@injectable()\nexport class c {\n  name = "c";\n}\n\n@injectable()\nexport class a {\n  name = "a";\n  @inject()\n  b!: b;\n  @inject(c)\n  c!: c;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n可以直接在实例属性上使用@inject来注入服务对象，只不过属性注入的@inject是不能省略的，而构造函数中可以省略。\n\n虽然属性注入不能省略@inejct，但是可以省略@inject的参数。如果没有参数则会通过属性的类型来推导应该注入什么服务。当然也可以不省略进行明确的注入。\n\n提示\n\n虽然上面说到属性注入可以省略@inject的参数，那也只能省略属性类型是类的场景，如果属性类型是一个 interface，显然是不行的。\n\n\n# 复杂例子\n\n// 这里展示了一个复杂的类之间的依赖关系\na --\x3e b、c、d\nb --\x3e c、d\nc --\x3e d、e\nd --\x3e e、f\ne --\x3e f\nf 没有依赖\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nimport { injectable, inject } from "@kaokei/di";\n\n@injectable()\nexport class f {\n  name = "f";\n}\n\n@injectable()\nexport class e {\n  name = "e";\n  @inject()\n  f!: f;\n}\n\n@injectable()\nexport class d {\n  name = "d";\n  @inject()\n  e!: e;\n  @inject()\n  f!: f;\n}\n\n@injectable()\nexport class c {\n  name = "c";\n  constructor(public d: d, public e: e) {}\n}\n\n@injectable()\nexport class b {\n  name = "b";\n  @inject()\n  c!: c;\n  constructor(public d: d) {}\n}\n\n@injectable()\nexport class a {\n  name = "a";\n  constructor(public b: b, public c: c, public d: d) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n上面的例子展示了可以混用构造函数注入和属性注入。',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"API文档",frontmatter:{title:"API文档",date:"2021-12-19T20:48:09.000Z",permalink:"/pages/64784b/",categories:["项目文档","di"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/00.di/90.API%E6%96%87%E6%A1%A3.html",relativePath:"30.项目文档/00.di/90.API文档.md",key:"v-42a5ab7e",path:"/pages/64784b/",headers:[{level:2,title:"Injector",slug:"injector",normalizedTitle:"injector",charIndex:13},{level:2,title:"@Injectable",slug:"injectable",normalizedTitle:"@injectable",charIndex:1207},{level:2,title:"@Inject",slug:"inject",normalizedTitle:"@inject",charIndex:363},{level:2,title:"@Self",slug:"self",normalizedTitle:"@self",charIndex:4319},{level:2,title:"@Skip",slug:"skip",normalizedTitle:"@skip",charIndex:5606},{level:2,title:"@Optional",slug:"optional",normalizedTitle:"@optional",charIndex:5612},{level:2,title:"forwardRef",slug:"forwardref",normalizedTitle:"forwardref",charIndex:9984},{level:2,title:"InjectionKey",slug:"injectionkey",normalizedTitle:"injectionkey",charIndex:10479}],headersStr:"Injector @Injectable @Inject @Self @Skip @Optional forwardRef InjectionKey",content:'# API 文档\n\n\n# Injector\n\n本身是一个类，提供了依赖注入的核心功能。\n\n主要逻辑是通过配置 providers 来生成 injector 实例，然后通过 injector.get 来自动化获取服务实例，从而避免手动维护依赖关系。\n\n参数：\n\n第一个参数：providers，代表 provider 的配置信息，类型是数组\n\n第二个参数：parent，代表父级 injector，类型还是 Injector\n\n第三个参数：options，代表 injector 的配置属性，类型是一个普通对象\n\n提示\n\noptions.beforeCacheHook\n\n这个配置项是一个函数，作用是在缓存服务对象之前的一个钩子。参考源码\n\noptions.mergePropertyHook\n\n这个配置项是一个函数，作用是通过@Inject 注入的属性需要合并到类实例上。参考源码\n\n用法：\n\nconst injector = new Injector([\n  SomeClass,\n  {\n    provide: someUseValueToken,\n    useValue: \'someValue\',\n  },\n  {\n    provide: someUseClassToken,\n    useClass: SomeClass,\n  },\n  {\n    provide: someUseExistingToken,\n    useExisting: AnotherExistingToken,\n  },\n  {\n    provide: someUseFactoryToken,\n    useFactory: (dep1, dep2, dep3...) => {\n      return someValue\n    },\n    deps: [dep1Token, dep2Token, dep3Token...],\n  },\n]);\n\nconst service1 = injector.get(SomeClass);\nconst service2 = injector.get(someUseValueToken);\nconst service3 = injector.get(someUseClassToken);\nconst service4 = injector.get(someUseExistingToken);\nconst service5 = injector.get(someUseFactoryToken);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n目前提供了以上 5 种配置 provider 的方式，这里主要是参考了 Angular 的概念。\n\n实际上@Injectable 也是另外一种隐式配置 provider 的方式。只不过这种方式只会在root injector中生效。\n\n\n# @Injectable\n\n标志类是可注入的，只有通过@Injectable声明过的类才会参与到依赖注入的过程中。\n\n参数：无\n\n用法：\n\n@Injectable()\nexport class LoggerService {\n  public log(...msg: any[]) {\n    console.log("from logger service ==>", ...msg);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n----------------------------------------\n\nInjectable 装饰器函数\n\nimport { Injectable } from "@kaokei/use-vue-service";\n\n@Injectable()\nexport class LoggerService {\n  public log(...msg: any[]) {\n    console.log("from logger service ==>", ...msg);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nInjectable 这个 api 是最简单的 api，只需要在定义服务类的时候，作为类的装饰器使用即可。\n\nInjectable 内部的实现是非常简单的，只是利用了 reflect-metadata 库简单的记录了服务类的构造函数的参数的类型信息。以便在后续实例化服务类的时候需要使用这些类型信息。\n\n可以理解为在构造函数的参数如果是类的时候，就可以不使用@Inject 的原因就在于@Injectable 已经收集到这些类的信息了。\n\n注意：虽然对于没有构造函数的类可以不使用@Injectable，但是为了保持一致性，还是尽量所有的服务类都使用@Injectable。\n\n\n# @Inject\n\n使用在类的构造函数的参数中和类的实例属性中，作用是手动声明该参数/属性的依赖注入的 token。\n\n首先需要明确一点就是这个装饰器并不是必须的。而是作为某些场景的补充手段。\n\n一般情况下如果指定构造函数的参数/实例属性的类型是某个类。这时候依赖注入对应的 token 就是这个类，那么@Inejct就不是必须的。\n\n但是如果参数类型/属性类型是 interface 或者基本类型。那么就必须要通过@Inject来手动指定依赖注入的 token 了。\n\n因为这个时候默认获取到的 token 其实是 Object/Boolean/Number/String 这些构造函数。那么根据默认逻辑就是实例化这些类。\n\n// 返回空对象{}\nnew Object();\n// 返回Boolean(false)对象\nnew Boolean();\n// 返回Number(0)对象\nnew Number();\n// 返回String(\'\')对象\nnew String();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n以上这些实例化对象绝大多数场景并不会是我们想要的逻辑。所以需要借助@Inject来替换以上的默认逻辑。\n\n参数：基本上除了 js 中的 Falsy 值的任意值，常见的比如类、字符串、Symbol。这也是文档中的 Token 的定义。\n\n用法：\n\ntype Theme = "white" | "black" | "dark" | "light";\nconst themeToken: Theme = Symbol();\n\n@Injectable()\nexport class CountService {\n  public count = 0;\n\n  // 这里演示了实例属性的类型是一个类型，而不是一个类\n  // 所以必须手动指定属性的依赖注入token是themeToken\n  // 注意这里并没有演示具体怎么通过themeToken获取到真正的theme的逻辑，这个逻辑需要在Injector中配置\n  @Inject(themeToken)\n  public theme!: Theme;\n\n  // 这里演示了@Inject注入一个类\n  // 实际上这里并不需要使用@Inject，因为LoggerService本身就是一个类，所以默认就会注入LoggerService对应的类实例\n  // 这里演示了通过@Inject手动配置依赖注入的token变成AnotherLoggerService，这里也体现了依赖注入的灵活性\n  constructor(@Inject(AnotherLoggerService) private logger: LoggerService) {}\n\n  public addOne() {\n    this.count++;\n    this.logger.log("addOne ==> ", this.count);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n----------------------------------------\n\nInject 装饰器函数\n\nimport { Injectable } from "@kaokei/use-vue-service";\nimport { LoggerService } from "./logger.service.ts";\n\n@Injectable()\nexport class CountService {\n  @Inject(LoggerService)\n  private logger1: LoggerService,\n\n  constructor(\n    @Inject(LoggerService) private logger2: LoggerService,\n  ) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n装饰器目前只能用在类上面，所以可以在类组件和类服务上使用。\n\n参考示例代码，可以看出来@Inject装饰器可以在实例属性以及类的构造函数的参数上使用。\n\n@Inject 的作用是在当前类实例化的时候，Injector 会自动帮助我们注入相应的实例属性和构造函数参数。\n\n@Inject 有一个必填的参数，作为需要注入的服务标识符。\n\n在实例属性上，@Inject 是必须的。如果没有这个装饰器，那么就是一个普通的属性。\n\n在构造函数的参数上，如果参数类型是类，比如这里的 logger2 的类型是 LoggerService 是一个类。那么这里其实是可以不使用@Inject 的。代码如下：\n\nconstructor(\n  private logger2: LoggerService,\n) {}\n\n\n1\n2\n3\n\n\n注意：最初的设计在实例属性上，如果属性的类型是一个类，@Inject 的参数是可以省略的，因为装饰器是可以获取到正确的类型的。最终为了代码一致性，把这个特性去掉了，强制要求@Inject 必须指定参数。总结起来就是只有构造函数中可以不使用@Inject，但是如果使用@Inejct 都必须指定参数。还有一点需要注意，实例属性和构造函数的参数的类型可以是interface，但是@Inject 的参数不能是interface。\n\n\n# @Self\n\n必须要意识到 Injector 最大的特色就是支持层级 Injector。直观的表述就是每一个 injector 都可以设置它的parent injector。\n\n类似的数据结构就是 dom 树，每一个 dom 节点都可以有它的parent node。\n\n正是因为层级结构，所以存在如下这样的逻辑。当我们调用如下代码时。\n\nconst injector = new Injector();\nconst parentInjector = new Injector();\ninjector.parent = parentInjector;\ninjector.get(LoggerService);\n\n\n1\n2\n3\n4\n\n\n以上代码的执行逻辑是这样的，因为 injector 中并没有配置 LoggerService，所以在 injector 并不能提供相应的服务对象。\n\n所以会自动进入 parentInjector 中寻找 LoggerService。虽然在 parentInjector 中也没有配置 LoggerService。\n\n但是因为 parentInjector 已经没有 parent，也就是作为root injector，它会自动尝试实例化 LoggerService。\n\n有了以上背景知识，就能理解@Self的作用了。就是强制指定injector.get只会在当前 injector 中寻找相应的服务，而不会从 parentInjector 中寻找服务。\n\n参数：boolean | undefined，当不传参数时，默认为 true\n\n用法：\n\n@Injectable()\nexport class CountService {\n  public count = 0;\n\n  // 这里配置了@Self\n  // 但是实际上还需要看Injector本身的配置\n  // 也就是一定要保证当前injector中存在LoggerService配置\n  constructor(@Self() private logger: LoggerService) {}\n\n  public addOne() {\n    this.count++;\n    this.logger.log("addOne ==> ", this.count);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n提示\n\n需要注意@Self作为一个装饰器，应该在类的构造函数的参数/类的实例属性上使用。 实际上injector.get(token, options)存在第二个参数options，这个 options 中可以指定 self、skip、optional 参数。\n\ninjector.get(LoggerService, { self: true, skip: true, optional: true });\n\n\n1\n\n\n实际上类的依赖注入的实现过程中就是调用的 injector.get 来实现的。也就是本库会把@Self、@Skip、@Optional这些装饰器转化为injector.get的第二个参数。\n\n----------------------------------------\n\nSelf 装饰器函数\n\nimport { Injectable, Self } from "@kaokei/use-vue-service";\nimport { LoggerService } from "./logger.service.ts";\n\n@Injectable()\nexport class CountService {\n  @Self()\n  @Inject(LoggerService)\n  private logger1: LoggerService,\n\n  constructor(\n    @Self()\n    @Inject(LoggerService)\n    private logger2: LoggerService,\n  ) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n同样是属于装饰器函数，配合@Inject 一起使用。\n\n根据函数名应该已经猜到其作用了。它控制了@Inject 只会从当前所属的 Injector 中获取服务实例。 咋一看似乎没什么实际用处。仔细一分析还真是没什么实际作用。\n\n因为是借鉴的 Angular 的 API，所以就给实现了。\n\n我的理解它最大的作用应该是起到警告的作用。比如我只想从当前 Injector 中获取 LoggerService，那么我必须要保证当前 Injector 中已经配置了 LoggerService 的 provider。如果我们手动已经保证了这一点，那么有没有@Self 是没有什么影响的。但是如果无意间我们删除了这个 provider，那么@Self 就会报错找不到服务。如果没有@Self 就有可能自动从更父级的 Injector 中寻找到 LoggerService，使得程序没有抛出异常，但是这可能不是我们想要的业务逻辑。\n\n\n# @Skip\n\n基本作用类似@Self，只不过功能正好相反，一开始就会跳过当前 injector，而是直接从 parentInjector 中寻找服务。\n\n参数：boolean | undefined，当不传参数时，默认为 true\n\n用法：\n\n@Injectable()\nexport class CountService {\n  public count = 0;\n\n  // 这里配置了@Skip\n  // 但是实际上还需要看Injector的配置\n  // 也就是一定要保证父级或者祖先injector中存在LoggerService配置\n  constructor(@Skip() private logger: LoggerService) {}\n\n  public addOne() {\n    this.count++;\n    this.logger.log("addOne ==> ", this.count);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n----------------------------------------\n\nSkip 装饰器函数\n\nimport { Injectable, Skip } from "@kaokei/use-vue-service";\nimport { LoggerService } from "./logger.service.ts";\n\n@Injectable()\nexport class CountService {\n  @Skip()\n  @Inject(LoggerService)\n  private logger1: LoggerService,\n\n  constructor(\n    @Skip()\n    @Inject(LoggerService)\n    private logger2: LoggerService,\n  ) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n同样是属于装饰器函数，配合@Inject 一起使用。\n\n@Skip 主要是控制@Inject 的行为，在没有@Skip 时，@Inject 会从当前的 Injector 中获取对应的服务，如果找不到则会自动从其父级 Injector 中寻找对应的服务，最终一直到根 Injector 中寻找服务。那么@Skip 的作用就是默认从当前的 Injector 的父级 Injector 开始寻找服务，即跳过当前 Injector。\n\n这样的场景不是很多见，比如当前组件中有一个 Student 服务，代表某个学生，显然我们可以直接@Inject 获取一个 Student 服务。假设其父组件中维护也维护着一个 Student 服务，并且父组件中已经有一个服务实例代表该班级最优秀的学生。那么如果在当前的子组件中想要获取这个最优秀的学生就需要用到@Skip 功能了。\n\n我知道有些同学的脑洞比较大，假设有一个更加复杂的场景，在班级最优秀的学生上面还有年级最优秀、学校最优秀、全市最优秀、全国最优秀、全球最优秀。。。那么如何在最底层的组件中获取以上服务实例呢？答案就是做不到。应该说只是借助@Skip 是做不到这个功能的。具体方法可以参考这里。\n\n其实一开始我是有实现@Skip(number)这个功能的，比如@Skip(5)就是向上跳过 5 层。最终考虑到这样的场景毕竟不是很常见的场景，反而因为实现这个功能降低了整个代码的效率。所以最终是去掉了这个功能。\n\n@Skip 有一个缺点，它可能不是从像你理解的那样跳过当前的 Injector。参考这里\n\n\n# @Optional\n\n本库作为依赖注入工具，必须处理一个场景就是当本库找不到对应的服务的时候，应该怎么处理。\n\n目前的处理逻辑是，默认会抛出TokenNotFoundError异常。\n\n但是如果我们认为某个服务是可选的，可以配置@Optional，这样当本库找不到对应的服务的时候，就会返回 undefined，而不是抛出异常了。\n\n参数：boolean | undefined，当不传参数时，默认为 true\n\n用法：\n\n@Injectable()\nexport class CountService {\n  public count = 0;\n\n  // 这里配置了@Optional\n  // 所以logger应该是可选属性\n  constructor(@Optional() private logger?: LoggerService) {}\n\n  public addOne() {\n    this.count++;\n    // 因为this.logger可能是undefined\n    // 所以应该使用可选调用?.\n    this.logger?.log("addOne ==> ", this.count);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n----------------------------------------\n\nOptional 装饰器函数\n\nimport { Injectable, Optional, Self, Skip } from "@kaokei/use-vue-service";\nimport { LoggerService } from "./logger.service.ts";\n\n@Injectable()\nexport class CountService {\n  @Optional()\n  @Inject(LoggerService)\n  private logger1: LoggerService,\n\n  @Optional()\n  @Self()\n  @Inject(LoggerService)\n  private logger2: LoggerService,\n\n  @Optional()\n  @Skip()\n  @Inject(LoggerService)\n  private logger3: LoggerService,\n\n  constructor(\n    @Optional()\n    @Inject(LoggerService)\n    private logger4: LoggerService,\n\n    @Optional()\n    @Self()\n    @Inject(LoggerService)\n    private logger5: LoggerService,\n\n    @Optional()\n    @Skip()\n    @Inject(LoggerService)\n    private logger6: LoggerService,\n  ) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n同样是属于装饰器函数，配合@Inject 一起使用。\n\n之前我们有提到当 Injector 找不到对应的服务的 provider 时，会抛出异常。如果认为某个属性可以是非必须的，就可以使用@Optional，这时如果找不到 provider，就会返回undefined。\n\n注意：因为实例属性可能是 undefined，那么在调用实例属性的方法时就应该判空，像这样this.logger1?.log(\'hello world\');\n\n注意：默认情况下，如果服务的标识符是一个类，那么在找不到这个服务的 provider 时，就会直接实例化这个类当作服务实例。当然如果有@Self 控制@Inject 的话，就不会自动实例化类了。\n\n注意：上面提到的@Self 控制@Inject，所以就不会自动实例化类了。这在本库中是没有问题的。因为本库提供了一个默认的 Injector 作为根 Injector。实际上在@kaokei/di这个库中的实现要稍微复杂一些，当你手动实例时一个 Injector，并且没有指定父级 Injector 时，它自己就会作为根 Injector，而根 Injector 则又会自动实例化类了。具体代码可以参考这里。\n\n\n# forwardRef\n\n这个函数是为了解决@Inject的时候存在循环依赖的问题的。\n\n参数：Function，类似这样的() => someToken\n\n用法：\n\ninterface IA {\n  name: string;\n  b: IB;\n}\ninterface IB {\n  name: string;\n  b: IA;\n}\nclass A {\n  public name = "A";\n  // 类A依赖类B\n  @Inject(forwardRef(() => B))\n  public b!: IB;\n}\nclass B {\n  public name = "B";\n  // 类B依赖类A\n  @Inject(forwardRef(() => A))\n  public a!: IA;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n以上代码演示了 AB 两个类互相依赖，如果缺少 forwardRef，会导致代码编译失败。因为装饰器是立即执行的，所以导致 A 依赖 B 的时候，B 还没有准备好。\n\n\n# InjectionKey\n\n类似 vue 中的 InjectionKey，主要是为了解决类型推导的问题。\n\n注意到 InjectionKey 不是一个函数，而是一个类型范型。\n\n注意到类本身可以自己实例化，而且自带类型信息。但是对于字符串和 Symbol 是没有更多的业务类型信息的。\n\n用法：\n\n// 这里logger1自动推导为LoggerService类型\nconst logger1 = injector.get(LoggerService);\n\n// 假设LoggerServiceStringToken这个token已经指向LoggerService\n// 虽然运行时logger2确实是一个LoggerService类的实例\n// 但是已经丢失了typescript的类型信息\nconst logger2 = injector.get("LoggerServiceStringToken");\n\nconst LoggerServiceStringTokenWithType: InjectionKey<LoggerService> =\n  "LoggerServiceStringToken";\n// 虽然logger3和logger2在运行时并没有什么区别，但是logger3已经可以推导出为LoggerService类型\nconst logger3 = injector.get(LoggerServiceStringTokenWithType);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n',normalizedContent:'# api 文档\n\n\n# injector\n\n本身是一个类，提供了依赖注入的核心功能。\n\n主要逻辑是通过配置 providers 来生成 injector 实例，然后通过 injector.get 来自动化获取服务实例，从而避免手动维护依赖关系。\n\n参数：\n\n第一个参数：providers，代表 provider 的配置信息，类型是数组\n\n第二个参数：parent，代表父级 injector，类型还是 injector\n\n第三个参数：options，代表 injector 的配置属性，类型是一个普通对象\n\n提示\n\noptions.beforecachehook\n\n这个配置项是一个函数，作用是在缓存服务对象之前的一个钩子。参考源码\n\noptions.mergepropertyhook\n\n这个配置项是一个函数，作用是通过@inject 注入的属性需要合并到类实例上。参考源码\n\n用法：\n\nconst injector = new injector([\n  someclass,\n  {\n    provide: someusevaluetoken,\n    usevalue: \'somevalue\',\n  },\n  {\n    provide: someuseclasstoken,\n    useclass: someclass,\n  },\n  {\n    provide: someuseexistingtoken,\n    useexisting: anotherexistingtoken,\n  },\n  {\n    provide: someusefactorytoken,\n    usefactory: (dep1, dep2, dep3...) => {\n      return somevalue\n    },\n    deps: [dep1token, dep2token, dep3token...],\n  },\n]);\n\nconst service1 = injector.get(someclass);\nconst service2 = injector.get(someusevaluetoken);\nconst service3 = injector.get(someuseclasstoken);\nconst service4 = injector.get(someuseexistingtoken);\nconst service5 = injector.get(someusefactorytoken);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n目前提供了以上 5 种配置 provider 的方式，这里主要是参考了 angular 的概念。\n\n实际上@injectable 也是另外一种隐式配置 provider 的方式。只不过这种方式只会在root injector中生效。\n\n\n# @injectable\n\n标志类是可注入的，只有通过@injectable声明过的类才会参与到依赖注入的过程中。\n\n参数：无\n\n用法：\n\n@injectable()\nexport class loggerservice {\n  public log(...msg: any[]) {\n    console.log("from logger service ==>", ...msg);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n----------------------------------------\n\ninjectable 装饰器函数\n\nimport { injectable } from "@kaokei/use-vue-service";\n\n@injectable()\nexport class loggerservice {\n  public log(...msg: any[]) {\n    console.log("from logger service ==>", ...msg);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ninjectable 这个 api 是最简单的 api，只需要在定义服务类的时候，作为类的装饰器使用即可。\n\ninjectable 内部的实现是非常简单的，只是利用了 reflect-metadata 库简单的记录了服务类的构造函数的参数的类型信息。以便在后续实例化服务类的时候需要使用这些类型信息。\n\n可以理解为在构造函数的参数如果是类的时候，就可以不使用@inject 的原因就在于@injectable 已经收集到这些类的信息了。\n\n注意：虽然对于没有构造函数的类可以不使用@injectable，但是为了保持一致性，还是尽量所有的服务类都使用@injectable。\n\n\n# @inject\n\n使用在类的构造函数的参数中和类的实例属性中，作用是手动声明该参数/属性的依赖注入的 token。\n\n首先需要明确一点就是这个装饰器并不是必须的。而是作为某些场景的补充手段。\n\n一般情况下如果指定构造函数的参数/实例属性的类型是某个类。这时候依赖注入对应的 token 就是这个类，那么@inejct就不是必须的。\n\n但是如果参数类型/属性类型是 interface 或者基本类型。那么就必须要通过@inject来手动指定依赖注入的 token 了。\n\n因为这个时候默认获取到的 token 其实是 object/boolean/number/string 这些构造函数。那么根据默认逻辑就是实例化这些类。\n\n// 返回空对象{}\nnew object();\n// 返回boolean(false)对象\nnew boolean();\n// 返回number(0)对象\nnew number();\n// 返回string(\'\')对象\nnew string();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n以上这些实例化对象绝大多数场景并不会是我们想要的逻辑。所以需要借助@inject来替换以上的默认逻辑。\n\n参数：基本上除了 js 中的 falsy 值的任意值，常见的比如类、字符串、symbol。这也是文档中的 token 的定义。\n\n用法：\n\ntype theme = "white" | "black" | "dark" | "light";\nconst themetoken: theme = symbol();\n\n@injectable()\nexport class countservice {\n  public count = 0;\n\n  // 这里演示了实例属性的类型是一个类型，而不是一个类\n  // 所以必须手动指定属性的依赖注入token是themetoken\n  // 注意这里并没有演示具体怎么通过themetoken获取到真正的theme的逻辑，这个逻辑需要在injector中配置\n  @inject(themetoken)\n  public theme!: theme;\n\n  // 这里演示了@inject注入一个类\n  // 实际上这里并不需要使用@inject，因为loggerservice本身就是一个类，所以默认就会注入loggerservice对应的类实例\n  // 这里演示了通过@inject手动配置依赖注入的token变成anotherloggerservice，这里也体现了依赖注入的灵活性\n  constructor(@inject(anotherloggerservice) private logger: loggerservice) {}\n\n  public addone() {\n    this.count++;\n    this.logger.log("addone ==> ", this.count);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n----------------------------------------\n\ninject 装饰器函数\n\nimport { injectable } from "@kaokei/use-vue-service";\nimport { loggerservice } from "./logger.service.ts";\n\n@injectable()\nexport class countservice {\n  @inject(loggerservice)\n  private logger1: loggerservice,\n\n  constructor(\n    @inject(loggerservice) private logger2: loggerservice,\n  ) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n装饰器目前只能用在类上面，所以可以在类组件和类服务上使用。\n\n参考示例代码，可以看出来@inject装饰器可以在实例属性以及类的构造函数的参数上使用。\n\n@inject 的作用是在当前类实例化的时候，injector 会自动帮助我们注入相应的实例属性和构造函数参数。\n\n@inject 有一个必填的参数，作为需要注入的服务标识符。\n\n在实例属性上，@inject 是必须的。如果没有这个装饰器，那么就是一个普通的属性。\n\n在构造函数的参数上，如果参数类型是类，比如这里的 logger2 的类型是 loggerservice 是一个类。那么这里其实是可以不使用@inject 的。代码如下：\n\nconstructor(\n  private logger2: loggerservice,\n) {}\n\n\n1\n2\n3\n\n\n注意：最初的设计在实例属性上，如果属性的类型是一个类，@inject 的参数是可以省略的，因为装饰器是可以获取到正确的类型的。最终为了代码一致性，把这个特性去掉了，强制要求@inject 必须指定参数。总结起来就是只有构造函数中可以不使用@inject，但是如果使用@inejct 都必须指定参数。还有一点需要注意，实例属性和构造函数的参数的类型可以是interface，但是@inject 的参数不能是interface。\n\n\n# @self\n\n必须要意识到 injector 最大的特色就是支持层级 injector。直观的表述就是每一个 injector 都可以设置它的parent injector。\n\n类似的数据结构就是 dom 树，每一个 dom 节点都可以有它的parent node。\n\n正是因为层级结构，所以存在如下这样的逻辑。当我们调用如下代码时。\n\nconst injector = new injector();\nconst parentinjector = new injector();\ninjector.parent = parentinjector;\ninjector.get(loggerservice);\n\n\n1\n2\n3\n4\n\n\n以上代码的执行逻辑是这样的，因为 injector 中并没有配置 loggerservice，所以在 injector 并不能提供相应的服务对象。\n\n所以会自动进入 parentinjector 中寻找 loggerservice。虽然在 parentinjector 中也没有配置 loggerservice。\n\n但是因为 parentinjector 已经没有 parent，也就是作为root injector，它会自动尝试实例化 loggerservice。\n\n有了以上背景知识，就能理解@self的作用了。就是强制指定injector.get只会在当前 injector 中寻找相应的服务，而不会从 parentinjector 中寻找服务。\n\n参数：boolean | undefined，当不传参数时，默认为 true\n\n用法：\n\n@injectable()\nexport class countservice {\n  public count = 0;\n\n  // 这里配置了@self\n  // 但是实际上还需要看injector本身的配置\n  // 也就是一定要保证当前injector中存在loggerservice配置\n  constructor(@self() private logger: loggerservice) {}\n\n  public addone() {\n    this.count++;\n    this.logger.log("addone ==> ", this.count);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n提示\n\n需要注意@self作为一个装饰器，应该在类的构造函数的参数/类的实例属性上使用。 实际上injector.get(token, options)存在第二个参数options，这个 options 中可以指定 self、skip、optional 参数。\n\ninjector.get(loggerservice, { self: true, skip: true, optional: true });\n\n\n1\n\n\n实际上类的依赖注入的实现过程中就是调用的 injector.get 来实现的。也就是本库会把@self、@skip、@optional这些装饰器转化为injector.get的第二个参数。\n\n----------------------------------------\n\nself 装饰器函数\n\nimport { injectable, self } from "@kaokei/use-vue-service";\nimport { loggerservice } from "./logger.service.ts";\n\n@injectable()\nexport class countservice {\n  @self()\n  @inject(loggerservice)\n  private logger1: loggerservice,\n\n  constructor(\n    @self()\n    @inject(loggerservice)\n    private logger2: loggerservice,\n  ) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n同样是属于装饰器函数，配合@inject 一起使用。\n\n根据函数名应该已经猜到其作用了。它控制了@inject 只会从当前所属的 injector 中获取服务实例。 咋一看似乎没什么实际用处。仔细一分析还真是没什么实际作用。\n\n因为是借鉴的 angular 的 api，所以就给实现了。\n\n我的理解它最大的作用应该是起到警告的作用。比如我只想从当前 injector 中获取 loggerservice，那么我必须要保证当前 injector 中已经配置了 loggerservice 的 provider。如果我们手动已经保证了这一点，那么有没有@self 是没有什么影响的。但是如果无意间我们删除了这个 provider，那么@self 就会报错找不到服务。如果没有@self 就有可能自动从更父级的 injector 中寻找到 loggerservice，使得程序没有抛出异常，但是这可能不是我们想要的业务逻辑。\n\n\n# @skip\n\n基本作用类似@self，只不过功能正好相反，一开始就会跳过当前 injector，而是直接从 parentinjector 中寻找服务。\n\n参数：boolean | undefined，当不传参数时，默认为 true\n\n用法：\n\n@injectable()\nexport class countservice {\n  public count = 0;\n\n  // 这里配置了@skip\n  // 但是实际上还需要看injector的配置\n  // 也就是一定要保证父级或者祖先injector中存在loggerservice配置\n  constructor(@skip() private logger: loggerservice) {}\n\n  public addone() {\n    this.count++;\n    this.logger.log("addone ==> ", this.count);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n----------------------------------------\n\nskip 装饰器函数\n\nimport { injectable, skip } from "@kaokei/use-vue-service";\nimport { loggerservice } from "./logger.service.ts";\n\n@injectable()\nexport class countservice {\n  @skip()\n  @inject(loggerservice)\n  private logger1: loggerservice,\n\n  constructor(\n    @skip()\n    @inject(loggerservice)\n    private logger2: loggerservice,\n  ) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n同样是属于装饰器函数，配合@inject 一起使用。\n\n@skip 主要是控制@inject 的行为，在没有@skip 时，@inject 会从当前的 injector 中获取对应的服务，如果找不到则会自动从其父级 injector 中寻找对应的服务，最终一直到根 injector 中寻找服务。那么@skip 的作用就是默认从当前的 injector 的父级 injector 开始寻找服务，即跳过当前 injector。\n\n这样的场景不是很多见，比如当前组件中有一个 student 服务，代表某个学生，显然我们可以直接@inject 获取一个 student 服务。假设其父组件中维护也维护着一个 student 服务，并且父组件中已经有一个服务实例代表该班级最优秀的学生。那么如果在当前的子组件中想要获取这个最优秀的学生就需要用到@skip 功能了。\n\n我知道有些同学的脑洞比较大，假设有一个更加复杂的场景，在班级最优秀的学生上面还有年级最优秀、学校最优秀、全市最优秀、全国最优秀、全球最优秀。。。那么如何在最底层的组件中获取以上服务实例呢？答案就是做不到。应该说只是借助@skip 是做不到这个功能的。具体方法可以参考这里。\n\n其实一开始我是有实现@skip(number)这个功能的，比如@skip(5)就是向上跳过 5 层。最终考虑到这样的场景毕竟不是很常见的场景，反而因为实现这个功能降低了整个代码的效率。所以最终是去掉了这个功能。\n\n@skip 有一个缺点，它可能不是从像你理解的那样跳过当前的 injector。参考这里\n\n\n# @optional\n\n本库作为依赖注入工具，必须处理一个场景就是当本库找不到对应的服务的时候，应该怎么处理。\n\n目前的处理逻辑是，默认会抛出tokennotfounderror异常。\n\n但是如果我们认为某个服务是可选的，可以配置@optional，这样当本库找不到对应的服务的时候，就会返回 undefined，而不是抛出异常了。\n\n参数：boolean | undefined，当不传参数时，默认为 true\n\n用法：\n\n@injectable()\nexport class countservice {\n  public count = 0;\n\n  // 这里配置了@optional\n  // 所以logger应该是可选属性\n  constructor(@optional() private logger?: loggerservice) {}\n\n  public addone() {\n    this.count++;\n    // 因为this.logger可能是undefined\n    // 所以应该使用可选调用?.\n    this.logger?.log("addone ==> ", this.count);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n----------------------------------------\n\noptional 装饰器函数\n\nimport { injectable, optional, self, skip } from "@kaokei/use-vue-service";\nimport { loggerservice } from "./logger.service.ts";\n\n@injectable()\nexport class countservice {\n  @optional()\n  @inject(loggerservice)\n  private logger1: loggerservice,\n\n  @optional()\n  @self()\n  @inject(loggerservice)\n  private logger2: loggerservice,\n\n  @optional()\n  @skip()\n  @inject(loggerservice)\n  private logger3: loggerservice,\n\n  constructor(\n    @optional()\n    @inject(loggerservice)\n    private logger4: loggerservice,\n\n    @optional()\n    @self()\n    @inject(loggerservice)\n    private logger5: loggerservice,\n\n    @optional()\n    @skip()\n    @inject(loggerservice)\n    private logger6: loggerservice,\n  ) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n同样是属于装饰器函数，配合@inject 一起使用。\n\n之前我们有提到当 injector 找不到对应的服务的 provider 时，会抛出异常。如果认为某个属性可以是非必须的，就可以使用@optional，这时如果找不到 provider，就会返回undefined。\n\n注意：因为实例属性可能是 undefined，那么在调用实例属性的方法时就应该判空，像这样this.logger1?.log(\'hello world\');\n\n注意：默认情况下，如果服务的标识符是一个类，那么在找不到这个服务的 provider 时，就会直接实例化这个类当作服务实例。当然如果有@self 控制@inject 的话，就不会自动实例化类了。\n\n注意：上面提到的@self 控制@inject，所以就不会自动实例化类了。这在本库中是没有问题的。因为本库提供了一个默认的 injector 作为根 injector。实际上在@kaokei/di这个库中的实现要稍微复杂一些，当你手动实例时一个 injector，并且没有指定父级 injector 时，它自己就会作为根 injector，而根 injector 则又会自动实例化类了。具体代码可以参考这里。\n\n\n# forwardref\n\n这个函数是为了解决@inject的时候存在循环依赖的问题的。\n\n参数：function，类似这样的() => sometoken\n\n用法：\n\ninterface ia {\n  name: string;\n  b: ib;\n}\ninterface ib {\n  name: string;\n  b: ia;\n}\nclass a {\n  public name = "a";\n  // 类a依赖类b\n  @inject(forwardref(() => b))\n  public b!: ib;\n}\nclass b {\n  public name = "b";\n  // 类b依赖类a\n  @inject(forwardref(() => a))\n  public a!: ia;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n以上代码演示了 ab 两个类互相依赖，如果缺少 forwardref，会导致代码编译失败。因为装饰器是立即执行的，所以导致 a 依赖 b 的时候，b 还没有准备好。\n\n\n# injectionkey\n\n类似 vue 中的 injectionkey，主要是为了解决类型推导的问题。\n\n注意到 injectionkey 不是一个函数，而是一个类型范型。\n\n注意到类本身可以自己实例化，而且自带类型信息。但是对于字符串和 symbol 是没有更多的业务类型信息的。\n\n用法：\n\n// 这里logger1自动推导为loggerservice类型\nconst logger1 = injector.get(loggerservice);\n\n// 假设loggerservicestringtoken这个token已经指向loggerservice\n// 虽然运行时logger2确实是一个loggerservice类的实例\n// 但是已经丢失了typescript的类型信息\nconst logger2 = injector.get("loggerservicestringtoken");\n\nconst loggerservicestringtokenwithtype: injectionkey<loggerservice> =\n  "loggerservicestringtoken";\n// 虽然logger3和logger2在运行时并没有什么区别，但是logger3已经可以推导出为loggerservice类型\nconst logger3 = injector.get(loggerservicestringtokenwithtype);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"FAQ",frontmatter:{title:"FAQ",date:"2022-02-18T10:17:42.000Z",permalink:"/pages/762b47/",categories:["项目文档","di"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/00.di/91.faq.html",relativePath:"30.项目文档/00.di/91.faq.md",key:"v-629eea80",path:"/pages/762b47/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"案例",frontmatter:{title:"案例",date:"2022-02-17T21:28:01.000Z",permalink:"/pages/b3da0e/",categories:["项目文档","di"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/00.di/92.%E6%A1%88%E4%BE%8B.html",relativePath:"30.项目文档/00.di/92.案例.md",key:"v-13383ab2",path:"/pages/b3da0e/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"资源",frontmatter:{title:"资源",date:"2022-02-17T21:27:54.000Z",permalink:"/pages/71016c/",categories:["项目文档","di"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/00.di/93.%E8%B5%84%E6%BA%90.html",relativePath:"30.项目文档/00.di/93.资源.md",key:"v-a49916ba",path:"/pages/71016c/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"快速开始",frontmatter:{title:"快速开始",date:"2021-12-17T10:30:48.000Z",permalink:"/pages/46481f/",categories:["项目文档","use-vue-service"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/01.use-vue-service/00.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B.html",relativePath:"30.项目文档/01.use-vue-service/00.快速开始.md",key:"v-5eead728",path:"/pages/46481f/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:11},{level:2,title:"特性",slug:"特性",normalizedTitle:"特性",charIndex:36},{level:2,title:"初始化项目",slug:"初始化项目",normalizedTitle:"初始化项目",charIndex:445},{level:2,title:"修改配置文件",slug:"修改配置文件",normalizedTitle:"修改配置文件",charIndex:733},{level:2,title:"安装依赖包",slug:"安装依赖包",normalizedTitle:"安装依赖包",charIndex:860},{level:2,title:"定义服务",slug:"定义服务",normalizedTitle:"定义服务",charIndex:1237},{level:2,title:"组织服务",slug:"组织服务",normalizedTitle:"组织服务",charIndex:1349},{level:2,title:"使用服务",slug:"使用服务",normalizedTitle:"使用服务",charIndex:1702}],headersStr:"简介 特性 初始化项目 修改配置文件 安装依赖包 定义服务 组织服务 使用服务",content:'# 快速开始\n\n\n# 简介\n\n本库基于 vue3 的 reactive 特性，借鉴了 angular 的 service 的实现机制，在 vue 环境中实现了基于服务的依赖注入，可以替代 vuex 更加方便的管理数据。\n\n主要是依赖@kaokei/di来实现依赖注入能力。依赖vue3来实现响应式数据。\n\n\n# 特性\n\n数据管理 🌲\n\n通过服务来管理数据，可以代替 vuex\n\n依赖注入 💉\n\n通过 typescript 的 decorator 实现依赖注入\n\n- name: 数据管理 🌲\n  desc: 通过服务来管理数据，可以代替 vuex\n  bgColor: "#F0DFB1"\n  textColor: "#242A38"\n- name: 依赖注入 💉\n  desc: 通过 typescript 的 decorator 实现依赖注入\n  bgColor: "#DFEEE7"\n  textColor: "#2A3344"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 初始化项目\n\n建议使用@vue/cli来初始化项目。\n\nnpm install -g @vue/cli\nvue create projectName\n\n\n1\n2\n\n\n提示\n\n手动选择 vue 版本为 vue3 以及 typescript 选项，取消 vuex 选项，我们不再需要 vuex。\n\n虽然 vue 官网比较推荐使用 vite 搭建项目，但是这里暂时还不能使用 vite 搭建项目。\n\n因为 vite 使用的是 esbuild 而不是 tsc 编译 ts 代码。而 esbuild 暂时还不支持装饰器特性，本库最大的特点就是依赖注入，它是通过装饰器来实现的。\n\n\n# 修改配置文件\n\n在 tsconfig.json 文件中compilerOptions选项中新增以下两行\n\n"experimentalDecorators": true,\n"emitDecoratorMetadata": true,\n\n\n1\n2\n\n\n\n# 安装依赖包\n\n安装 npm 包\n\nnpm install -S reflect-metadata @kaokei/use-vue-service\n\n\n1\n\n\n本库的定位是一个轻量级的依赖注入实现，它并不是一个框架，而且对项目的侵入性比较小。\n\n本库所有的依赖包括：\n\n * typescript：依赖装饰器特性\n   * 需要 tsc 编译器，而不能是 esbuild 编译器\n   * 需要开启实验特性experimentalDecorators和emitDecoratorMetadata\n * vue3：依赖 provide/inject/reactive 等特性，换句话说就是只能在 vue3 项目中使用本库\n * reflect-metadata：获取类型信息，需要在项目入口文件中import \'reflect-metadata\';\n\n\n# 定义服务\n\n接下来就是开始写代码了，第一步就是定义服务，关于服务的概念可以参考@kaokei/di的文档。虽然广义上任意 js 数据都可以作为服务，但是最常见的服务还是类，使用类作为服务定义，最大的好处是自带类型。\n\n\n# 组织服务\n\n第二步是组织这些定义好的服务，所谓组织服务其实就是定义这些服务的作用域。组织方式参考了 angular 的实现方式。\n\n默认情况下，以类定义的服务默认是全局可使用的，但是我们也可以定义为局部可使用的。\n\n非类定义的服务必须定义好如何使用，后续才能正常获取到服务实例。\n\n这里可以具体解释一下，因为类的实例化方法是非常明确的，就是调用new关键字。而且类名也不是单纯的字符串而是指向这个类的引用，当我们把类名作为服务的 token 时，我们就可以通过new实例化类来获取服务。\n\n相反，如果我们拿到的服务对应的 token 是一个字符串，那么我们是不知道怎么通过这个字符串来获取对应的服务的，必须有一个注册的过程，这个注册的过程就是在组织服务。\n\n提示\n\n后续文章有具体介绍如何组织服务\n\n\n# 使用服务\n\n第三步就是通过 api 获取服务实例，拿到服务实例后，就能读取服务的状态以及调用服务的方法更新服务的状态。\n\n这里再回顾一下，假设我们定义服务的时候采用的是类的形式。服务的实例就是类的实例。所以服务的状态就是类的实例的属性，所以可以调用类的实例的方法更新属性。 同时服务已经被reactive处理过，vue 模版可以直接渲染服务的状态。当服务的状态变化时，vue 模版也会自动更新。\n\nimport { useService } from "@kaokei/use-vue-service";\n// SomeService是一个类\nimport { SomeService } from "./some.service.ts";\n// useService会返回SomeService的一个实例对象\n// 且someService已经是一个响应式的对象了\nconst someService = useService(SomeService);\n\n\n1\n2\n3\n4\n5\n6\n\n\n<template>\n  <div>{{ someService.name }}: {{ someService.age }}</div>\n  <button type="button" @click="someService.agePlusOne">年龄+1</button>\n</template>\n\n\n1\n2\n3\n4\n',normalizedContent:'# 快速开始\n\n\n# 简介\n\n本库基于 vue3 的 reactive 特性，借鉴了 angular 的 service 的实现机制，在 vue 环境中实现了基于服务的依赖注入，可以替代 vuex 更加方便的管理数据。\n\n主要是依赖@kaokei/di来实现依赖注入能力。依赖vue3来实现响应式数据。\n\n\n# 特性\n\n数据管理 🌲\n\n通过服务来管理数据，可以代替 vuex\n\n依赖注入 💉\n\n通过 typescript 的 decorator 实现依赖注入\n\n- name: 数据管理 🌲\n  desc: 通过服务来管理数据，可以代替 vuex\n  bgcolor: "#f0dfb1"\n  textcolor: "#242a38"\n- name: 依赖注入 💉\n  desc: 通过 typescript 的 decorator 实现依赖注入\n  bgcolor: "#dfeee7"\n  textcolor: "#2a3344"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 初始化项目\n\n建议使用@vue/cli来初始化项目。\n\nnpm install -g @vue/cli\nvue create projectname\n\n\n1\n2\n\n\n提示\n\n手动选择 vue 版本为 vue3 以及 typescript 选项，取消 vuex 选项，我们不再需要 vuex。\n\n虽然 vue 官网比较推荐使用 vite 搭建项目，但是这里暂时还不能使用 vite 搭建项目。\n\n因为 vite 使用的是 esbuild 而不是 tsc 编译 ts 代码。而 esbuild 暂时还不支持装饰器特性，本库最大的特点就是依赖注入，它是通过装饰器来实现的。\n\n\n# 修改配置文件\n\n在 tsconfig.json 文件中compileroptions选项中新增以下两行\n\n"experimentaldecorators": true,\n"emitdecoratormetadata": true,\n\n\n1\n2\n\n\n\n# 安装依赖包\n\n安装 npm 包\n\nnpm install -s reflect-metadata @kaokei/use-vue-service\n\n\n1\n\n\n本库的定位是一个轻量级的依赖注入实现，它并不是一个框架，而且对项目的侵入性比较小。\n\n本库所有的依赖包括：\n\n * typescript：依赖装饰器特性\n   * 需要 tsc 编译器，而不能是 esbuild 编译器\n   * 需要开启实验特性experimentaldecorators和emitdecoratormetadata\n * vue3：依赖 provide/inject/reactive 等特性，换句话说就是只能在 vue3 项目中使用本库\n * reflect-metadata：获取类型信息，需要在项目入口文件中import \'reflect-metadata\';\n\n\n# 定义服务\n\n接下来就是开始写代码了，第一步就是定义服务，关于服务的概念可以参考@kaokei/di的文档。虽然广义上任意 js 数据都可以作为服务，但是最常见的服务还是类，使用类作为服务定义，最大的好处是自带类型。\n\n\n# 组织服务\n\n第二步是组织这些定义好的服务，所谓组织服务其实就是定义这些服务的作用域。组织方式参考了 angular 的实现方式。\n\n默认情况下，以类定义的服务默认是全局可使用的，但是我们也可以定义为局部可使用的。\n\n非类定义的服务必须定义好如何使用，后续才能正常获取到服务实例。\n\n这里可以具体解释一下，因为类的实例化方法是非常明确的，就是调用new关键字。而且类名也不是单纯的字符串而是指向这个类的引用，当我们把类名作为服务的 token 时，我们就可以通过new实例化类来获取服务。\n\n相反，如果我们拿到的服务对应的 token 是一个字符串，那么我们是不知道怎么通过这个字符串来获取对应的服务的，必须有一个注册的过程，这个注册的过程就是在组织服务。\n\n提示\n\n后续文章有具体介绍如何组织服务\n\n\n# 使用服务\n\n第三步就是通过 api 获取服务实例，拿到服务实例后，就能读取服务的状态以及调用服务的方法更新服务的状态。\n\n这里再回顾一下，假设我们定义服务的时候采用的是类的形式。服务的实例就是类的实例。所以服务的状态就是类的实例的属性，所以可以调用类的实例的方法更新属性。 同时服务已经被reactive处理过，vue 模版可以直接渲染服务的状态。当服务的状态变化时，vue 模版也会自动更新。\n\nimport { useservice } from "@kaokei/use-vue-service";\n// someservice是一个类\nimport { someservice } from "./some.service.ts";\n// useservice会返回someservice的一个实例对象\n// 且someservice已经是一个响应式的对象了\nconst someservice = useservice(someservice);\n\n\n1\n2\n3\n4\n5\n6\n\n\n<template>\n  <div>{{ someservice.name }}: {{ someservice.age }}</div>\n  <button type="button" @click="someservice.ageplusone">年龄+1</button>\n</template>\n\n\n1\n2\n3\n4\n',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"基础教程",frontmatter:{author:"kaokei",title:"基础教程",date:"2021-12-19T16:51:01.000Z",permalink:"/pages/4497fd/",categories:["项目文档","use-vue-service"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/01.use-vue-service/01.%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.html",relativePath:"30.项目文档/01.use-vue-service/01.基础教程.md",key:"v-73f54546",path:"/pages/4497fd/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:11},{level:2,title:"使用步骤",slug:"使用步骤",normalizedTitle:"使用步骤",charIndex:89},{level:3,title:"定义服务",slug:"定义服务",normalizedTitle:"定义服务",charIndex:98},{level:3,title:"使用服务",slug:"使用服务",normalizedTitle:"使用服务",charIndex:822}],headersStr:"简介 使用步骤 定义服务 使用服务",content:'# 基础教程\n\n\n# 简介\n\n本教程介绍最基础的两个 api，通过这两个 api 来大概认识一下怎么使用本库。\n\n * Injectable\n * useService\n\n\n# 使用步骤\n\n\n# 定义服务\n\nimport { Injectable } from "@kaokei/use-vue-service";\n\n@Injectable()\nexport class LoggerService {\n  public log(...msg: any[]) {\n    console.log("from logger service ==>", ...msg);\n  }\n}\n\n@Injectable()\nexport class CountService {\n  public count = 0;\n  constructor(private logger: LoggerService) {}\n\n  public addOne() {\n    this.count++;\n    this.logger.log("addOne ==> ", this.count);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n从上面的代码可以看出来，我们采用类来描述服务。这里的服务就是 typescript 中普通的类，并没有引入新的概念。 所以是非常简单易上手的，只要记住使用@Injectable标记该类是可注入的服务即可。\n\n注意到上面 LoggerService 是没有依赖的，但是 CountService 是依赖 LoggerService 的。因为 LoggerService 出现在 CountService 的构造函数中。最终 CountService 就会有一个 logger 实例属性，且 logger 的类型就是 LoggerService。\n\n\n# 使用服务\n\n<template>\n  <div>\n    <span>{{ countService.count }}</span>\n    <button type="button" @click="countService.addOne()">+1</button>\n  </div>\n</template>\n<script lang="ts">\nimport { defineComponent } from "vue";\nimport { useService } from "@kaokei/use-vue-service";\nimport { CountService } from "../services/count.service";\n\nexport default defineComponent({\n  setup() {\n    // 返回的就是CountService类的实例\n    // 并且是reactive的\n    const countService = useService(CountService);\n    return {\n      // 可以在模板中直接绑定数据和事件\n      countService,\n    };\n  },\n});\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n注意这里是一个 vue 组件的源代码，我们使用 defineComponent 定义组件。很明显最关键的一行代码就是const countService = useService(CountService);。本库提供了一个方法useService，该方法从名字可以看出来是一个 hooks 方法，只能在setup函数中使用。\n\n在这个例子中，我们传入参数CountService，返回一个对象countService，注意 countService 的类型就是 CountService，也就是说 countService 是 CountService 类的一个实例。\n\n正如上面代码中的注释所说，countService 对象本身是一个 reactive 对象，所以 vue 模版可以直接渲染 countService.count，当 countService.count 变化时，组件也会自动更新。\n\n到这里为止，聪明的你一定已经发现了很多问题。\n\n * 为什么我们不自己 new CountService()，而要通过 useService 获取实例对象？\n * useService(CountService) 这里并没有传递 LoggerService，那么这里是如何初始化 LoggerService 的？\n * 在不同的组件中调用 useService(CountService)，获取到的实例是不是同一个对象？\n\n这些问题的解答可以参考这里',normalizedContent:'# 基础教程\n\n\n# 简介\n\n本教程介绍最基础的两个 api，通过这两个 api 来大概认识一下怎么使用本库。\n\n * injectable\n * useservice\n\n\n# 使用步骤\n\n\n# 定义服务\n\nimport { injectable } from "@kaokei/use-vue-service";\n\n@injectable()\nexport class loggerservice {\n  public log(...msg: any[]) {\n    console.log("from logger service ==>", ...msg);\n  }\n}\n\n@injectable()\nexport class countservice {\n  public count = 0;\n  constructor(private logger: loggerservice) {}\n\n  public addone() {\n    this.count++;\n    this.logger.log("addone ==> ", this.count);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n从上面的代码可以看出来，我们采用类来描述服务。这里的服务就是 typescript 中普通的类，并没有引入新的概念。 所以是非常简单易上手的，只要记住使用@injectable标记该类是可注入的服务即可。\n\n注意到上面 loggerservice 是没有依赖的，但是 countservice 是依赖 loggerservice 的。因为 loggerservice 出现在 countservice 的构造函数中。最终 countservice 就会有一个 logger 实例属性，且 logger 的类型就是 loggerservice。\n\n\n# 使用服务\n\n<template>\n  <div>\n    <span>{{ countservice.count }}</span>\n    <button type="button" @click="countservice.addone()">+1</button>\n  </div>\n</template>\n<script lang="ts">\nimport { definecomponent } from "vue";\nimport { useservice } from "@kaokei/use-vue-service";\nimport { countservice } from "../services/count.service";\n\nexport default definecomponent({\n  setup() {\n    // 返回的就是countservice类的实例\n    // 并且是reactive的\n    const countservice = useservice(countservice);\n    return {\n      // 可以在模板中直接绑定数据和事件\n      countservice,\n    };\n  },\n});\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n注意这里是一个 vue 组件的源代码，我们使用 definecomponent 定义组件。很明显最关键的一行代码就是const countservice = useservice(countservice);。本库提供了一个方法useservice，该方法从名字可以看出来是一个 hooks 方法，只能在setup函数中使用。\n\n在这个例子中，我们传入参数countservice，返回一个对象countservice，注意 countservice 的类型就是 countservice，也就是说 countservice 是 countservice 类的一个实例。\n\n正如上面代码中的注释所说，countservice 对象本身是一个 reactive 对象，所以 vue 模版可以直接渲染 countservice.count，当 countservice.count 变化时，组件也会自动更新。\n\n到这里为止，聪明的你一定已经发现了很多问题。\n\n * 为什么我们不自己 new countservice()，而要通过 useservice 获取实例对象？\n * useservice(countservice) 这里并没有传递 loggerservice，那么这里是如何初始化 loggerservice 的？\n * 在不同的组件中调用 useservice(countservice)，获取到的实例是不是同一个对象？\n\n这些问题的解答可以参考这里',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"进阶教程",frontmatter:{author:"kaokei",title:"进阶教程",date:"2021-12-19T16:51:01.000Z",permalink:"/pages/a03917/",categories:["项目文档","use-vue-service"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/01.use-vue-service/02.%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B.html",relativePath:"30.项目文档/01.use-vue-service/02.进阶教程.md",key:"v-1293b6fa",path:"/pages/a03917/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:11},{level:2,title:"解答问题",slug:"解答问题",normalizedTitle:"解答问题",charIndex:85},{level:2,title:"给组件绑定 Injector",slug:"给组件绑定-injector",normalizedTitle:"给组件绑定 injector",charIndex:928},{level:2,title:"定义 A 组件-没有 declareProviders",slug:"定义-a-组件-没有-declareproviders",normalizedTitle:"定义 a 组件-没有 declareproviders",charIndex:2283},{level:2,title:"定义 B 组件-使用 declareProviders",slug:"定义-b-组件-使用-declareproviders",normalizedTitle:"定义 b 组件-使用 declareproviders",charIndex:2930},{level:2,title:"分析 A/B 组件的差异",slug:"分析-a-b-组件的差异",normalizedTitle:"分析 a/b 组件的差异",charIndex:3692}],headersStr:"简介 解答问题 给组件绑定 Injector 定义 A 组件-没有 declareProviders 定义 B 组件-使用 declareProviders 分析 A/B 组件的差异",content:'# 进阶教程\n\n\n# 简介\n\n本教程继续介绍下面 2 个 api，可以用来支持更加复杂场景的需求。\n\n * declareProviders\n * Inject\n\n\n# 解答问题\n\n上篇文章中，即基础教程中提到的三个问题，如下：\n\n * 为什么我们不自己 new CountService()，而要通过 useService 获取实例对象？\n * useService(CountService) 这里并没有传递 LoggerService，那么这里是如何初始化 LoggerService 的？\n * 在不同的组件中调用 useService(CountService)，获取到的实例是不是同一个对象？\n\n其实这三个问题可以用一个名词来解答，就是依赖注入。\n\n第一个问题的答案就是，因为我们要使用依赖注入，我们要通过依赖注入来获取实例对象，而不是通过手动 new 来获取实例对象。至于为什么需要依赖注入，这是因为依赖注入相对于手动 new 更具有优势。\n\n第二个问题的答案就是，useService 会自动帮我们实例化一个 LoggerService 的实例，并且传递给 CountService 构造函数。这也是依赖注入其中一个最重要的优势的体现。依赖注入框架会自动帮助我们实现依赖的注入，包括依赖的依赖的注入，这是一个递归的注入过程。\n\n第三个问题的答案就是，useService 有一个非常重要的特性，在同一个Injector中同一个服务一定是单例的。 所以默认情况下，在不同的组件中调用 useService(CountService)，获取到的实例是同一个对象，这种默认的特性正好完美的解决了跨组件通信的问题。具体体现在当任意一个组件内修改了countService.count属性，两个组件都会重新渲染。\n\n当然，针对特定的复杂场景我们可能需要实现一个服务可以有多个实例，我们可以有两种做法。\n\n * 第一种是使用不同的 Injector，不同 Injector 中的服务都是互相独立的。\n * 第二种就是在同一个 Injector 中，可以针对同一个服务取不同的名字，这样让 Injector 以为是不同的服务，从而得到多个实例。\n\n\n# 给组件绑定 Injector\n\n默认情况下，本库提供了一个全局的根 Injector，它的生命周期是和应用一致的。所以如果是用户信息这类全局性质的数据，那么默认的 Injector 就能满足需求了。\n\n但是如果是某个页面的业务数据，我们期望进入页面的时候初始化数据，离开页面的时候应该销毁数据。那么就应该把这个服务关联到这个页面对应的组件上。这样服务的生命周期就和页面的生命周期一致了。\n\n我们可以借助 declareProviders 来关联组件和 Injector。\n\nimport { declareProviders } from "@kaokei/use-vue-service";\n\n\n1\n\n\n在介绍如何使用 declareProviders 函数之前，我们必须弄清楚 useService 是如何工作的。前面已经介绍过 useService 是一个 hooks 函数，是只能在 setup 函数中使用的。\n\n我们还知道一个 vue 项目，最终的产出物就是一棵 vue 组件树，然后 vue 框架会通过 vue 组件树渲染成 dom 树。这个渲染细节我们暂时不用去关心，这里只需要关注 vue 组件树，在这棵树中，任意一个组件节点都有它的父节点，直到根结点。\n\n当我们在某个组件中调用 useService(CountService) 函数时，它会首先从当前组件关联的 Injector 中寻找是否存在 CountService 服务的 provider。如果没有找到，则进入到父组件关联的 Injector 中寻找 CountService 的 provider。如果还没有找到，则继续到更上一层父组件中寻找，直到找到相应服务的 provider，那么就通过这个 provider 获取一个对象出来。这个对象就是 useService(CountService)的返回值。当然还有一种情况就是直到根组件都没有找到 provider，针对这种情况，useService 做了一层 fallbak 机制，就是把 CountService 类当作默认 provider，然后用这个默认的 provider 来获取实例对象。\n\n通过上面简单的介绍，我们应该对 useService 解析机制有一个大概的认识，它和 js 中的原型链的解析机制以及 nodejs 中的 node_modules 解析机制都是非常相似的，应该不是很难理解。\n\n通过上面的介绍，我们知道默认情况下，在不同的组件中调用 useService(CountService)时，肯定是都找不到对应的 provider 的，最终都会冒泡到根组件上，在根组件对应的 Injector 中使用 CountService 类作为默认的 provider 获取实例对象，又因为同一个 Injector 中，同一个服务只有一个实例，所以不同的组件中获取到的是同一个 countService 实例对象。\n\n接下来介绍如何通过 declareProviders 函数来关联组件和 Injector。\n\n提示\n\n有关根组件和根 Injector 的关系上面的介绍在某些细节上存在一些瑕疵，但是不妨碍理解整体的工作机制。具体细节差别可以参考这里\n\n\n# 定义 A 组件-没有 declareProviders\n\n<template>\n  <div>\n    <span>{{ countService.count }}</span>\n    <button type="button" @click="countService.addOne()">+1</button>\n  </div>\n</template>\n<script lang="ts">\nimport { defineComponent } from "vue";\nimport { useService } from "@kaokei/use-vue-service";\nimport { CountService } from "../services/count.service";\n\nexport default defineComponent({\n  setup() {\n    // 返回的就是CountService类的实例\n    // 并且是reactive的\n    const countService = useService(CountService);\n    return {\n      // 可以在模板中直接绑定数据和事件\n      countService,\n    };\n  },\n});\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 定义 B 组件-使用 declareProviders\n\n<template>\n  <div>\n    <span>{{ countService.count }}</span>\n    <button type="button" @click="countService.addOne()">+1</button>\n  </div>\n</template>\n<script lang="ts">\nimport { defineComponent } from "vue";\nimport { useService } from "@kaokei/use-vue-service";\nimport { CountService } from "../services/count.service";\n\nexport default defineComponent({\n  setup() {\n    // 手动定义CountService服务的provider\n    // 这里就是在当前组件上关联了一个新的Injector\n    declareProviders([CountService]);\n    // 返回的就是CountService类的实例\n    // 并且是reactive的\n    const countService = useService(CountService);\n    return {\n      // 可以在模板中直接绑定数据和事件\n      countService,\n    };\n  },\n});\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 分析 A/B 组件的差异\n\n对比上面的 A 组件和 B 组件，我们发现唯一的差别就是 B 组件中调用了declareProviders([CountService]);，这行代码的功能就是在 B 组件关联了一个新的 Injector，并且配置了 CountService 这个服务的 provider。\n\n这行代码其实是一种简写，完整的代码应该是这样的：\n\ndeclareProviders([\n  {\n    provide: CountService,\n    useClass: CountService,\n  },\n]);\n\n\n1\n2\n3\n4\n5\n6\n\n\n从完整的代码里，我们应该可以明确的看出来，其中provide属性定义了服务的名字，也就是指定了是哪个服务，一般称之为服务标识符。useClass属性则是指定了如何生成服务的实例。provide 和 useClass 所在的对象被称为 provider。关于具体的 provider 解释，具体可以参考这里。\n\n我们还能发现 declareProviders 函数的参数是一个数组，其实是一个 provider 数组，这是很好理解的，因为一个组件是可以依赖多个不同的服务的，所以可以通过 declareProviders 函数一次性注册多个服务的 provider。\n\n接下来开始分析 A 组件和 B 组件中 useService 的差异了。\n\n在 A 组件中，因为没有使用 declareProviders，所以在当前组件以及父组件中都没有找到 CountService 服务的 provider，一直到根组件中都没有找到对应的 provider，所以只能把 CountService 类当作默认的 provider 获取实例对象。然后作为 useService 函数的返回值。\n\n在 B 组件中，因为 B 组件本身就已经定义了 CountService 服务的 provider，所以不用到父组件中去寻找了，更不需要到根组件中寻找了。直接在当前组件关联的 Injector 中获取服务的实例对象，然后作为 useService 函数的返回值。\n\n最后的总结就是 A 组件中的 countService 对象是在根组件关联的 Injector 中，B 组件中的 countService 对象是在 B 组件关联的 Injector 中。\n\n这样我们就达成了我扪想要的效果了，即通过 declareProviders 手动管理服务的位置，从而管理服务的生命周期，其实也是管理了该服务对哪个组件（及其子孙组件）可见，达到类似作用域的功能。同时我们也客观上实现了同一个服务可以具有多个实例对象，因为在定义 CountService 服务时是不用关心在哪里使用的，只需要定义一次，但是根 Injector 和 B 组件关联的 Injector 中都有 CountService 实例对象。\n\n这里还是要多说一句，一开始我们一直强调同一个服务在同一个 Injector 下只有一个实例，这是默认行为。然后这里我们又花费了大篇文章介绍怎么实现同一个服务获取多个实例对象。看起来有些冲突，或者说是多此一举。实际上并不是这样的，这是因为业务的复杂性决定的，大多数简单的场景下我们是不需要 declareProviders 的，但是当业务场景足够复杂的时候，我们还是需要一种机制去实现多例的功能。为了满足不同的业务场景，我们肯定是需要提供这种基础能力的。',normalizedContent:'# 进阶教程\n\n\n# 简介\n\n本教程继续介绍下面 2 个 api，可以用来支持更加复杂场景的需求。\n\n * declareproviders\n * inject\n\n\n# 解答问题\n\n上篇文章中，即基础教程中提到的三个问题，如下：\n\n * 为什么我们不自己 new countservice()，而要通过 useservice 获取实例对象？\n * useservice(countservice) 这里并没有传递 loggerservice，那么这里是如何初始化 loggerservice 的？\n * 在不同的组件中调用 useservice(countservice)，获取到的实例是不是同一个对象？\n\n其实这三个问题可以用一个名词来解答，就是依赖注入。\n\n第一个问题的答案就是，因为我们要使用依赖注入，我们要通过依赖注入来获取实例对象，而不是通过手动 new 来获取实例对象。至于为什么需要依赖注入，这是因为依赖注入相对于手动 new 更具有优势。\n\n第二个问题的答案就是，useservice 会自动帮我们实例化一个 loggerservice 的实例，并且传递给 countservice 构造函数。这也是依赖注入其中一个最重要的优势的体现。依赖注入框架会自动帮助我们实现依赖的注入，包括依赖的依赖的注入，这是一个递归的注入过程。\n\n第三个问题的答案就是，useservice 有一个非常重要的特性，在同一个injector中同一个服务一定是单例的。 所以默认情况下，在不同的组件中调用 useservice(countservice)，获取到的实例是同一个对象，这种默认的特性正好完美的解决了跨组件通信的问题。具体体现在当任意一个组件内修改了countservice.count属性，两个组件都会重新渲染。\n\n当然，针对特定的复杂场景我们可能需要实现一个服务可以有多个实例，我们可以有两种做法。\n\n * 第一种是使用不同的 injector，不同 injector 中的服务都是互相独立的。\n * 第二种就是在同一个 injector 中，可以针对同一个服务取不同的名字，这样让 injector 以为是不同的服务，从而得到多个实例。\n\n\n# 给组件绑定 injector\n\n默认情况下，本库提供了一个全局的根 injector，它的生命周期是和应用一致的。所以如果是用户信息这类全局性质的数据，那么默认的 injector 就能满足需求了。\n\n但是如果是某个页面的业务数据，我们期望进入页面的时候初始化数据，离开页面的时候应该销毁数据。那么就应该把这个服务关联到这个页面对应的组件上。这样服务的生命周期就和页面的生命周期一致了。\n\n我们可以借助 declareproviders 来关联组件和 injector。\n\nimport { declareproviders } from "@kaokei/use-vue-service";\n\n\n1\n\n\n在介绍如何使用 declareproviders 函数之前，我们必须弄清楚 useservice 是如何工作的。前面已经介绍过 useservice 是一个 hooks 函数，是只能在 setup 函数中使用的。\n\n我们还知道一个 vue 项目，最终的产出物就是一棵 vue 组件树，然后 vue 框架会通过 vue 组件树渲染成 dom 树。这个渲染细节我们暂时不用去关心，这里只需要关注 vue 组件树，在这棵树中，任意一个组件节点都有它的父节点，直到根结点。\n\n当我们在某个组件中调用 useservice(countservice) 函数时，它会首先从当前组件关联的 injector 中寻找是否存在 countservice 服务的 provider。如果没有找到，则进入到父组件关联的 injector 中寻找 countservice 的 provider。如果还没有找到，则继续到更上一层父组件中寻找，直到找到相应服务的 provider，那么就通过这个 provider 获取一个对象出来。这个对象就是 useservice(countservice)的返回值。当然还有一种情况就是直到根组件都没有找到 provider，针对这种情况，useservice 做了一层 fallbak 机制，就是把 countservice 类当作默认 provider，然后用这个默认的 provider 来获取实例对象。\n\n通过上面简单的介绍，我们应该对 useservice 解析机制有一个大概的认识，它和 js 中的原型链的解析机制以及 nodejs 中的 node_modules 解析机制都是非常相似的，应该不是很难理解。\n\n通过上面的介绍，我们知道默认情况下，在不同的组件中调用 useservice(countservice)时，肯定是都找不到对应的 provider 的，最终都会冒泡到根组件上，在根组件对应的 injector 中使用 countservice 类作为默认的 provider 获取实例对象，又因为同一个 injector 中，同一个服务只有一个实例，所以不同的组件中获取到的是同一个 countservice 实例对象。\n\n接下来介绍如何通过 declareproviders 函数来关联组件和 injector。\n\n提示\n\n有关根组件和根 injector 的关系上面的介绍在某些细节上存在一些瑕疵，但是不妨碍理解整体的工作机制。具体细节差别可以参考这里\n\n\n# 定义 a 组件-没有 declareproviders\n\n<template>\n  <div>\n    <span>{{ countservice.count }}</span>\n    <button type="button" @click="countservice.addone()">+1</button>\n  </div>\n</template>\n<script lang="ts">\nimport { definecomponent } from "vue";\nimport { useservice } from "@kaokei/use-vue-service";\nimport { countservice } from "../services/count.service";\n\nexport default definecomponent({\n  setup() {\n    // 返回的就是countservice类的实例\n    // 并且是reactive的\n    const countservice = useservice(countservice);\n    return {\n      // 可以在模板中直接绑定数据和事件\n      countservice,\n    };\n  },\n});\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 定义 b 组件-使用 declareproviders\n\n<template>\n  <div>\n    <span>{{ countservice.count }}</span>\n    <button type="button" @click="countservice.addone()">+1</button>\n  </div>\n</template>\n<script lang="ts">\nimport { definecomponent } from "vue";\nimport { useservice } from "@kaokei/use-vue-service";\nimport { countservice } from "../services/count.service";\n\nexport default definecomponent({\n  setup() {\n    // 手动定义countservice服务的provider\n    // 这里就是在当前组件上关联了一个新的injector\n    declareproviders([countservice]);\n    // 返回的就是countservice类的实例\n    // 并且是reactive的\n    const countservice = useservice(countservice);\n    return {\n      // 可以在模板中直接绑定数据和事件\n      countservice,\n    };\n  },\n});\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 分析 a/b 组件的差异\n\n对比上面的 a 组件和 b 组件，我们发现唯一的差别就是 b 组件中调用了declareproviders([countservice]);，这行代码的功能就是在 b 组件关联了一个新的 injector，并且配置了 countservice 这个服务的 provider。\n\n这行代码其实是一种简写，完整的代码应该是这样的：\n\ndeclareproviders([\n  {\n    provide: countservice,\n    useclass: countservice,\n  },\n]);\n\n\n1\n2\n3\n4\n5\n6\n\n\n从完整的代码里，我们应该可以明确的看出来，其中provide属性定义了服务的名字，也就是指定了是哪个服务，一般称之为服务标识符。useclass属性则是指定了如何生成服务的实例。provide 和 useclass 所在的对象被称为 provider。关于具体的 provider 解释，具体可以参考这里。\n\n我们还能发现 declareproviders 函数的参数是一个数组，其实是一个 provider 数组，这是很好理解的，因为一个组件是可以依赖多个不同的服务的，所以可以通过 declareproviders 函数一次性注册多个服务的 provider。\n\n接下来开始分析 a 组件和 b 组件中 useservice 的差异了。\n\n在 a 组件中，因为没有使用 declareproviders，所以在当前组件以及父组件中都没有找到 countservice 服务的 provider，一直到根组件中都没有找到对应的 provider，所以只能把 countservice 类当作默认的 provider 获取实例对象。然后作为 useservice 函数的返回值。\n\n在 b 组件中，因为 b 组件本身就已经定义了 countservice 服务的 provider，所以不用到父组件中去寻找了，更不需要到根组件中寻找了。直接在当前组件关联的 injector 中获取服务的实例对象，然后作为 useservice 函数的返回值。\n\n最后的总结就是 a 组件中的 countservice 对象是在根组件关联的 injector 中，b 组件中的 countservice 对象是在 b 组件关联的 injector 中。\n\n这样我们就达成了我扪想要的效果了，即通过 declareproviders 手动管理服务的位置，从而管理服务的生命周期，其实也是管理了该服务对哪个组件（及其子孙组件）可见，达到类似作用域的功能。同时我们也客观上实现了同一个服务可以具有多个实例对象，因为在定义 countservice 服务时是不用关心在哪里使用的，只需要定义一次，但是根 injector 和 b 组件关联的 injector 中都有 countservice 实例对象。\n\n这里还是要多说一句，一开始我们一直强调同一个服务在同一个 injector 下只有一个实例，这是默认行为。然后这里我们又花费了大篇文章介绍怎么实现同一个服务获取多个实例对象。看起来有些冲突，或者说是多此一举。实际上并不是这样的，这是因为业务的复杂性决定的，大多数简单的场景下我们是不需要 declareproviders 的，但是当业务场景足够复杂的时候，我们还是需要一种机制去实现多例的功能。为了满足不同的业务场景，我们肯定是需要提供这种基础能力的。',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"应用服务化",frontmatter:{title:"应用服务化",date:"2022-02-06T17:55:28.000Z",permalink:"/pages/3a3a6b/",categories:["项目文档","use-vue-service"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/01.use-vue-service/03.%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%8C%96.html",relativePath:"30.项目文档/01.use-vue-service/03.应用服务化.md",key:"v-ebbc0b9e",path:"/pages/3a3a6b/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:12},{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:158},{level:2,title:"解决方案",slug:"解决方案",normalizedTitle:"解决方案",charIndex:744},{level:2,title:"换一种角度思考",slug:"换一种角度思考",normalizedTitle:"换一种角度思考",charIndex:1193}],headersStr:"简介 场景分析 解决方案 换一种角度思考",content:"# 应用服务化\n\n\n# 简介\n\n在基础教程和进阶教程中主要是介绍了 declareProviders 和 useService 这两个 API，不过在API 文档中还介绍了另外两个 API(declareRootProviders、useRootService)，本文主要是介绍为什么还需要这两个 API。\n\n\n# 场景分析\n\n基础教程和进阶教程可以解决 90%的问题，但是有些场景的问题是解决不了的。因为 declareProviders 和 useService 这两个 API 都有一个限制条件就是只能在组件的 setup 函数中使用，这就导致在组件之外或者应用创建之前等场景中不能使用。\n\n我在实践过程中，发现有两个具体场景比较明显。\n\n一个是在工具函数中，如果是无状态的工具函数倒也问题不大，但是如果是有状态的工具函数，就会导致状态的割裂，即有些状态是通过服务来维护，有些状态是在工具函数中维护，而且工具函数中的状态不是响应式的数据。这种割裂最大的问题是如果是服务依赖工具函数的状态，还可以直接 import 这个状态，但是如果工具函数依赖服务的状态，是没有办法直接 import 的。因为服务的初始化过程已经交给本库了，最终服务对应的实例化对象会存储在对应的 Injector 中了。工具函数只能 import 到服务对应定义的那个类而已。并不能直接 import 到那个实例化对象。\n\n另一个是 router 的创建过程，一般我们会在单独的文件中创建 router 对象，然后导出这个对象，最终在main.js文件中创建应用。关键在于我们可能还会定义 router 的一些钩子方法。这些钩子方法可能会依赖一些服务的状态，这里也会像工具函数依赖服务状态一样无能为力。\n\n\n# 解决方案\n\n通过上面的分析，对应的解决方案也很明显了，就是最开始提到的 declareRootProviders 和 useRootService 这两个 API。\n\n我们可以把有状态的工具函数和 router 的创建过程全部转化为服务，然后通过 declareRootProviders 定义为全局的服务，以及通过 useRootService 获取对应的服务对象。这样当这些服务依赖其他服务时，就可以直接通过本库的依赖注入的方式使用其他服务，这里的其他服务必须也是全局服务，因为全局服务只能依赖全局服务而不能依赖局部服务。\n\n参考示例\n\n总结\n\n整个应用的所有状态都需要通过服务来维护，不允许在工具函数和其他地方维护自己的状态。 除非是一次性状态或者非常明确的局部状态，这里就需要具体场景具体分析了。\n\n注意\n\n这个解决方案并不是银弹，即工具函数和 router 依赖的服务都必须是全局服务，如果它们依赖的不是全局服务，那么这个方案依然是行不通的。不过一般也不存在这种复杂的依赖关系。\n\n\n# 换一种角度思考\n\n我了解到有些同学是这么开发 vue3 项目的，因为不愿意使用 vuex，所以只用到了 provide/inject 这两个 api 来实现依赖注入。 首先是维护一个全局的大对象，然后使用 reactive 使其变成响应式对象。然后使用provide('globalKey', globalObject);。这样在任意组件中我们都可以使用inject('globalKey');来获取这个globalObject对象，而且也可以直接在 vue 模版中使用这个对象的属性。因为属性也是响应式的。\n\n以上方案可以看作是最简版的依赖注入实现了。注入的是一个全局对象，获取到的还是这个全局对象。\n\n相对来说，declareRootProviders 和 useRootService 这两个 API 实现的是注入服务工厂，获取到的是通过服务工厂生产的服务对象。这其中有一个抽象到具体的生产过程。除此之外也没有什么差别。\n\n再对比一下 declareProviders 和 useService 这两个 API 解决的就是全局问题，有时候我们的数据的生命周期并不是全局的，全局意味着生命周期是和整个应用的生命周期是一致的，只要应用还在，数据就存在。但是如果我们的数据是给某个路由子页面使用的，当路由切换时，理所应当这些数据应该被销毁。只有当我们再次进入该路由子页面，会重新生成数据。",normalizedContent:"# 应用服务化\n\n\n# 简介\n\n在基础教程和进阶教程中主要是介绍了 declareproviders 和 useservice 这两个 api，不过在api 文档中还介绍了另外两个 api(declarerootproviders、userootservice)，本文主要是介绍为什么还需要这两个 api。\n\n\n# 场景分析\n\n基础教程和进阶教程可以解决 90%的问题，但是有些场景的问题是解决不了的。因为 declareproviders 和 useservice 这两个 api 都有一个限制条件就是只能在组件的 setup 函数中使用，这就导致在组件之外或者应用创建之前等场景中不能使用。\n\n我在实践过程中，发现有两个具体场景比较明显。\n\n一个是在工具函数中，如果是无状态的工具函数倒也问题不大，但是如果是有状态的工具函数，就会导致状态的割裂，即有些状态是通过服务来维护，有些状态是在工具函数中维护，而且工具函数中的状态不是响应式的数据。这种割裂最大的问题是如果是服务依赖工具函数的状态，还可以直接 import 这个状态，但是如果工具函数依赖服务的状态，是没有办法直接 import 的。因为服务的初始化过程已经交给本库了，最终服务对应的实例化对象会存储在对应的 injector 中了。工具函数只能 import 到服务对应定义的那个类而已。并不能直接 import 到那个实例化对象。\n\n另一个是 router 的创建过程，一般我们会在单独的文件中创建 router 对象，然后导出这个对象，最终在main.js文件中创建应用。关键在于我们可能还会定义 router 的一些钩子方法。这些钩子方法可能会依赖一些服务的状态，这里也会像工具函数依赖服务状态一样无能为力。\n\n\n# 解决方案\n\n通过上面的分析，对应的解决方案也很明显了，就是最开始提到的 declarerootproviders 和 userootservice 这两个 api。\n\n我们可以把有状态的工具函数和 router 的创建过程全部转化为服务，然后通过 declarerootproviders 定义为全局的服务，以及通过 userootservice 获取对应的服务对象。这样当这些服务依赖其他服务时，就可以直接通过本库的依赖注入的方式使用其他服务，这里的其他服务必须也是全局服务，因为全局服务只能依赖全局服务而不能依赖局部服务。\n\n参考示例\n\n总结\n\n整个应用的所有状态都需要通过服务来维护，不允许在工具函数和其他地方维护自己的状态。 除非是一次性状态或者非常明确的局部状态，这里就需要具体场景具体分析了。\n\n注意\n\n这个解决方案并不是银弹，即工具函数和 router 依赖的服务都必须是全局服务，如果它们依赖的不是全局服务，那么这个方案依然是行不通的。不过一般也不存在这种复杂的依赖关系。\n\n\n# 换一种角度思考\n\n我了解到有些同学是这么开发 vue3 项目的，因为不愿意使用 vuex，所以只用到了 provide/inject 这两个 api 来实现依赖注入。 首先是维护一个全局的大对象，然后使用 reactive 使其变成响应式对象。然后使用provide('globalkey', globalobject);。这样在任意组件中我们都可以使用inject('globalkey');来获取这个globalobject对象，而且也可以直接在 vue 模版中使用这个对象的属性。因为属性也是响应式的。\n\n以上方案可以看作是最简版的依赖注入实现了。注入的是一个全局对象，获取到的还是这个全局对象。\n\n相对来说，declarerootproviders 和 userootservice 这两个 api 实现的是注入服务工厂，获取到的是通过服务工厂生产的服务对象。这其中有一个抽象到具体的生产过程。除此之外也没有什么差别。\n\n再对比一下 declareproviders 和 useservice 这两个 api 解决的就是全局问题，有时候我们的数据的生命周期并不是全局的，全局意味着生命周期是和整个应用的生命周期是一致的，只要应用还在，数据就存在。但是如果我们的数据是给某个路由子页面使用的，当路由切换时，理所应当这些数据应该被销毁。只有当我们再次进入该路由子页面，会重新生成数据。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"组件与Injector",frontmatter:{title:"组件与Injector",date:"2022-02-06T21:06:34.000Z",permalink:"/pages/60ce48/",categories:["项目文档","use-vue-service"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/01.use-vue-service/04.%E7%BB%84%E4%BB%B6%E4%B8%8EInjector.html",relativePath:"30.项目文档/01.use-vue-service/04.组件与Injector.md",key:"v-43156d4a",path:"/pages/60ce48/",headers:[{level:2,title:"名词解释",slug:"名词解释",normalizedTitle:"名词解释",charIndex:19},{level:2,title:"单个应用",slug:"单个应用",normalizedTitle:"单个应用",charIndex:463},{level:3,title:"理想中的 Injector 结构",slug:"理想中的-injector-结构",normalizedTitle:"理想中的 injector 结构",charIndex:949},{level:3,title:"实际中的 Injector 结构",slug:"实际中的-injector-结构",normalizedTitle:"实际中的 injector 结构",charIndex:970},{level:2,title:"多个应用",slug:"多个应用",normalizedTitle:"多个应用",charIndex:1439},{level:3,title:"理想中的 Injector 结构",slug:"理想中的-injector-结构-2",normalizedTitle:"理想中的 injector 结构",charIndex:949},{level:3,title:"实际中的 Injector 结构",slug:"实际中的-injector-结构-2",normalizedTitle:"实际中的 injector 结构",charIndex:970},{level:2,title:"解决方案",slug:"解决方案",normalizedTitle:"解决方案",charIndex:2079},{level:3,title:"方案一",slug:"方案一",normalizedTitle:"方案一",charIndex:2088},{level:3,title:"方案二",slug:"方案二",normalizedTitle:"方案二",charIndex:2266},{level:2,title:"鸡・蛋问题",slug:"鸡・蛋问题",normalizedTitle:"鸡・蛋问题",charIndex:3289},{level:2,title:"最终实现方案",slug:"最终实现方案",normalizedTitle:"最终实现方案",charIndex:3801}],headersStr:"名词解释 单个应用 理想中的 Injector 结构 实际中的 Injector 结构 多个应用 理想中的 Injector 结构 实际中的 Injector 结构 解决方案 方案一 方案二 鸡・蛋问题 最终实现方案",content:'# 组件与 Injector\n\n\n# 名词解释\n\n组件： 就是指 vue 组件\n\nInjector： 是指@kaokei/di提供的依赖注入容器\n\n根组件： 是指传递给createApp的第一个参数，一般是App.vue\n\n根组件 Injector： 是指根组件对应的那个 Injector，也就是在根组件中调用declareProviders关联的那个 Injector\n\nApp： 也称为应用，是指createApp函数的返回值\n\nApp Injector： app 对应的 Injector，理论上应该提供但实际上本库没有提供这种 Injector，对比根组件 Injector，它应该是在应用创建之前存在的\n\nRoot Injector： 也称为根 Injector，是指@kaokei/use-vue-service自带的默认的 Injector\n\n重要\n\n在其他文档中，刻意忽略了根组件和应用的区别。也刻意忽略了根组件 Injector，App Injector 和 Root Injector 的区别。\n\n\n# 单个应用\n\n这里单个应用的意思是指只调用一次createApp创建一个应用。可以说绝大多数项目只会有一个应用。\n\n组件和 Injector 的对应关系是一个组件可以对应 1 个或者 0 个 Injector。\n\n在其他文档中，我会经常提到根组件就是对应的根 Injector，实际上是不准确的。根组件就是普通的组件，只不过是处在最顶层的位置。只要在根组件中调用declareProviders就会生成一个相关联的 Injector，这个 Injector 就是根组件的 Injector。\n\n实际上，当我们引入本库时，就已经自带了一个根 Injector 了。也就是说@kaokei/use-vue-service自带了一个默认 Injector。这个根 Injector 并没有和根组件绑定，而且是先于根组件存在的。\n\n后续当我们在组件中调用declareProviders时，如果没有找到父级 Injector，就会把自带的根 Injector 当作父级 Injector。所以最终形成的 Injector 树的根节点就是本库自带的那个根 Injector。\n\n\n# 理想中的 Injector 结构\n\n\n# 实际中的 Injector 结构\n\n图1：有根组件Injector结构\n\n----------------------------------------\n\n图2：没有根组件Injector结构\n\n----------------------------------------\n\n观察上方 3 张图可以发现目前本库并没有实现所谓的 App Injector。又因为绝大多数项目中只会有一个 createApp 创建的 vue 应用。所以把 Root Injector 当作 App Injector 也是可以接受的。\n\n同时注意到根组件的 Injector 可能有，也可能没有，但是这并不重要，因为有根 Injector 兜底。\n\n提示\n\n其他文档中提到的全局服务，默认情况下也是会存储在这个根 Injector 中，因为并没有所谓的 App Injector。\n\n提示\n\n上面的关系图展示了 Injector 结构树，所以省略了很多没有关联 Injector 的组件节点，因为并不是每一个组件都会关联一个 Injector。\n\n\n# 多个应用\n\n这里多个应用的意思是指多次调用createApp创建多个应用。虽然很少见有这种做法，但是理论上是可以这么做的。\n\n根组件对应的 Injector 应该是应用级别的 Injector，假设我们的项目非常复杂，是由多个 vue 应用组成的，即多次调用了createApp方法。每个createApp创建的 vue 应用都应该有自己的 App Injector。当然这些 App Injector 也是自带的根 Injector 的子 Injector。以上只是纯粹理论分析。\n\n\n# 理想中的 Injector 结构\n\n\n# 实际中的 Injector 结构\n\n上方 2 张图中并没有展示根组件对应的 Injector，因为根组件对应的 Injector 和普通组件的 Injector 并没有什么区别，可以存在，也可以不存在，不影响分析。\n\n可以明显的发现在多 App 项目中，由于缺少 App Injector 会导致不同的 App 的全局服务只能出现在 Root Injector，缺少数据隔离性，而且 App 的服务的生命周期和 App 不能保持一致。\n\n提示\n\n从代码完整性角度来看，我应该提供 App Injector 的实现，从而可以支持更加复杂的业务场景。 但是我并不想因为比较少见的业务场景而增加代码复杂度，因为绝大多数项目都只有一个createApp应用，此时把 Root Injector 当作 App Injector 是完全可以接受的。\n\n\n# 解决方案\n\n\n# 方案一\n\n使用根组件 Injector 代替 App Injector，也就是在各个 createApp 创建的应用对应的App.vue组件中使用 declareProviders 声明 token 和服务的关联关系。\n\n这是最容易想到的方案，可以做到数据隔离，但是这不是理想中的 App Injector，因为它要求必须在应用创建之后才能生效。\n\n\n# 方案二\n\n实现一个 vue 插件，通过插件来配置 providers，可以实现在 app 创建之前生效，准确来说是 mount 之前。\n\n// 定义插件\nimport {\n  getInjector,\n  DEFAULT_INJECTOR,\n  INJECTOR_KEY,\n} from "@kaokei/use-vue-service";\n\n// 实现插件\nexport function declareAppProviders(providers: any[]) {\n  return function (app: any) {\n    const currentInjector = getInjector(providers, DEFAULT_INJECTOR);\n    app.provide(INJECTOR_KEY, currentInjector);\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n// 使用插件\n// 定义providers数组\nconst providers = [\n  SomeService,\n  {\n    provide: SomeToken,\n    useClass: AnotherService,\n  },\n];\n// 使用插件配置providers\n// 这里会在app.context.providers中关联一个App Injector\n// 注意这里的Injector并不是关联到某一个组件而是app，我称之为App Injector\napp.use(declareAppProviders(providers));\napp.mount("#app");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n提示\n\n这个方案看起来要比方案一要好一些，但是实际上并没有差别，这里是指方案一需要等到应用创建完成之后才能生效，而方案二看似是在创建应用之前就能配置 providers，但是这里并没有提供一个函数在创建应用之前就能获取对应的服务。\n\n对比declareRootProviders/useRootService，这一对方法是完整的可以在创建应用之前使用的。所以我们还缺少useAppService这个方法。 但是useAppService的实现相对来说比较麻烦一些，而且对用户的使用也有更多的要求和限制。\n\n\n# 鸡・蛋问题\n\n可以参考这里介绍了非常有意思的鸡・蛋问题。\n\n这里也是有类似的鸡蛋问题，正常逻辑是需要先通过 declareProviders 配置 token 和服务的关联关系。然后通过 useService 获取对应的服务。\n\n但是 declareProviders 要求只能在组件内部调用，也就是要求 createApp 之后才能使用 declareProviders/useService 这一套逻辑。 但是如果我们在调用 createApp 之前有依赖服务，就要先支持 declareProviders/useService 这一套逻辑。显然这里就出现了死循环。\n\n在应用服务化中我们有介绍可以通过 declareRootProviders/useRootService 来解决这个死循环，这是最简单的方案，但并不是最理想的解决方案。\n\n后来我对比了 Angular 中的实现，关键在于从底层消除循环依赖，一定有一个最早执行的可控代码。\n\n比如我定义了一个bootstrapApp的方法，所有的服务的初始化都要在这个方法执行之后，也就是说不会存在执行 bootstrapApp 之前还依赖了其他服务的场景。\n\n\n# 最终实现方案\n\n// 定义bootstrapApp函数\nimport {\n  getInjector,\n  DEFAULT_INJECTOR,\n  INJECTOR_KEY,\n  getServiceFromInjector,\n} from "@kaokei/use-vue-service";\n\nexport function bootstrapApp(init: any) {\n  let appInjector;\n  const declareAppProviders = (providers: any[]) => {\n    const appInjector = getInjector(providers, DEFAULT_INJECTOR);\n    return function (app: any) {\n      app.provide(INJECTOR_KEY, appInjector);\n    };\n  };\n  const useAppService = (token: any, options?: any) => {\n    return getServiceFromInjector(appInjector, token, options);\n  };\n  init(declareAppProviders, useAppService);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n// 使用bootstrapApp函数\nbootstrapApp(function (declareAppProviders, useAppService) {\n  // 定义providers数组\n  const providers = [\n    SomeService,\n    {\n      provide: SomeToken,\n      useClass: AnotherService,\n    },\n  ];\n  // 使用插件配置providers\n  // 这里会在app.context.providers中关联一个App Injector\n  // 注意这里的Injector并不是关联到某一个组件而是app，我称之为App Injector\n  app.use(declareAppProviders(providers));\n  // 有需要的话可以提前获取服务\n  const someService = useAppService(SomeService);\n  // 并在创建应用之前就能调用服务的方法\n  someService.doSomething();\n  app.mount("#app");\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n提示\n\n注意declareAppProviders只能调用一次，否则 appInjector 就被覆盖了。useAppService必须在declareAppProviders后面调用。\n\n提示\n\n以上代码只是作为参考，绝大多数项目是完全不需要这种实现方案的，直接使用 Root Injector 就可以了。',normalizedContent:'# 组件与 injector\n\n\n# 名词解释\n\n组件： 就是指 vue 组件\n\ninjector： 是指@kaokei/di提供的依赖注入容器\n\n根组件： 是指传递给createapp的第一个参数，一般是app.vue\n\n根组件 injector： 是指根组件对应的那个 injector，也就是在根组件中调用declareproviders关联的那个 injector\n\napp： 也称为应用，是指createapp函数的返回值\n\napp injector： app 对应的 injector，理论上应该提供但实际上本库没有提供这种 injector，对比根组件 injector，它应该是在应用创建之前存在的\n\nroot injector： 也称为根 injector，是指@kaokei/use-vue-service自带的默认的 injector\n\n重要\n\n在其他文档中，刻意忽略了根组件和应用的区别。也刻意忽略了根组件 injector，app injector 和 root injector 的区别。\n\n\n# 单个应用\n\n这里单个应用的意思是指只调用一次createapp创建一个应用。可以说绝大多数项目只会有一个应用。\n\n组件和 injector 的对应关系是一个组件可以对应 1 个或者 0 个 injector。\n\n在其他文档中，我会经常提到根组件就是对应的根 injector，实际上是不准确的。根组件就是普通的组件，只不过是处在最顶层的位置。只要在根组件中调用declareproviders就会生成一个相关联的 injector，这个 injector 就是根组件的 injector。\n\n实际上，当我们引入本库时，就已经自带了一个根 injector 了。也就是说@kaokei/use-vue-service自带了一个默认 injector。这个根 injector 并没有和根组件绑定，而且是先于根组件存在的。\n\n后续当我们在组件中调用declareproviders时，如果没有找到父级 injector，就会把自带的根 injector 当作父级 injector。所以最终形成的 injector 树的根节点就是本库自带的那个根 injector。\n\n\n# 理想中的 injector 结构\n\n\n# 实际中的 injector 结构\n\n图1：有根组件injector结构\n\n----------------------------------------\n\n图2：没有根组件injector结构\n\n----------------------------------------\n\n观察上方 3 张图可以发现目前本库并没有实现所谓的 app injector。又因为绝大多数项目中只会有一个 createapp 创建的 vue 应用。所以把 root injector 当作 app injector 也是可以接受的。\n\n同时注意到根组件的 injector 可能有，也可能没有，但是这并不重要，因为有根 injector 兜底。\n\n提示\n\n其他文档中提到的全局服务，默认情况下也是会存储在这个根 injector 中，因为并没有所谓的 app injector。\n\n提示\n\n上面的关系图展示了 injector 结构树，所以省略了很多没有关联 injector 的组件节点，因为并不是每一个组件都会关联一个 injector。\n\n\n# 多个应用\n\n这里多个应用的意思是指多次调用createapp创建多个应用。虽然很少见有这种做法，但是理论上是可以这么做的。\n\n根组件对应的 injector 应该是应用级别的 injector，假设我们的项目非常复杂，是由多个 vue 应用组成的，即多次调用了createapp方法。每个createapp创建的 vue 应用都应该有自己的 app injector。当然这些 app injector 也是自带的根 injector 的子 injector。以上只是纯粹理论分析。\n\n\n# 理想中的 injector 结构\n\n\n# 实际中的 injector 结构\n\n上方 2 张图中并没有展示根组件对应的 injector，因为根组件对应的 injector 和普通组件的 injector 并没有什么区别，可以存在，也可以不存在，不影响分析。\n\n可以明显的发现在多 app 项目中，由于缺少 app injector 会导致不同的 app 的全局服务只能出现在 root injector，缺少数据隔离性，而且 app 的服务的生命周期和 app 不能保持一致。\n\n提示\n\n从代码完整性角度来看，我应该提供 app injector 的实现，从而可以支持更加复杂的业务场景。 但是我并不想因为比较少见的业务场景而增加代码复杂度，因为绝大多数项目都只有一个createapp应用，此时把 root injector 当作 app injector 是完全可以接受的。\n\n\n# 解决方案\n\n\n# 方案一\n\n使用根组件 injector 代替 app injector，也就是在各个 createapp 创建的应用对应的app.vue组件中使用 declareproviders 声明 token 和服务的关联关系。\n\n这是最容易想到的方案，可以做到数据隔离，但是这不是理想中的 app injector，因为它要求必须在应用创建之后才能生效。\n\n\n# 方案二\n\n实现一个 vue 插件，通过插件来配置 providers，可以实现在 app 创建之前生效，准确来说是 mount 之前。\n\n// 定义插件\nimport {\n  getinjector,\n  default_injector,\n  injector_key,\n} from "@kaokei/use-vue-service";\n\n// 实现插件\nexport function declareappproviders(providers: any[]) {\n  return function (app: any) {\n    const currentinjector = getinjector(providers, default_injector);\n    app.provide(injector_key, currentinjector);\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n// 使用插件\n// 定义providers数组\nconst providers = [\n  someservice,\n  {\n    provide: sometoken,\n    useclass: anotherservice,\n  },\n];\n// 使用插件配置providers\n// 这里会在app.context.providers中关联一个app injector\n// 注意这里的injector并不是关联到某一个组件而是app，我称之为app injector\napp.use(declareappproviders(providers));\napp.mount("#app");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n提示\n\n这个方案看起来要比方案一要好一些，但是实际上并没有差别，这里是指方案一需要等到应用创建完成之后才能生效，而方案二看似是在创建应用之前就能配置 providers，但是这里并没有提供一个函数在创建应用之前就能获取对应的服务。\n\n对比declarerootproviders/userootservice，这一对方法是完整的可以在创建应用之前使用的。所以我们还缺少useappservice这个方法。 但是useappservice的实现相对来说比较麻烦一些，而且对用户的使用也有更多的要求和限制。\n\n\n# 鸡・蛋问题\n\n可以参考这里介绍了非常有意思的鸡・蛋问题。\n\n这里也是有类似的鸡蛋问题，正常逻辑是需要先通过 declareproviders 配置 token 和服务的关联关系。然后通过 useservice 获取对应的服务。\n\n但是 declareproviders 要求只能在组件内部调用，也就是要求 createapp 之后才能使用 declareproviders/useservice 这一套逻辑。 但是如果我们在调用 createapp 之前有依赖服务，就要先支持 declareproviders/useservice 这一套逻辑。显然这里就出现了死循环。\n\n在应用服务化中我们有介绍可以通过 declarerootproviders/userootservice 来解决这个死循环，这是最简单的方案，但并不是最理想的解决方案。\n\n后来我对比了 angular 中的实现，关键在于从底层消除循环依赖，一定有一个最早执行的可控代码。\n\n比如我定义了一个bootstrapapp的方法，所有的服务的初始化都要在这个方法执行之后，也就是说不会存在执行 bootstrapapp 之前还依赖了其他服务的场景。\n\n\n# 最终实现方案\n\n// 定义bootstrapapp函数\nimport {\n  getinjector,\n  default_injector,\n  injector_key,\n  getservicefrominjector,\n} from "@kaokei/use-vue-service";\n\nexport function bootstrapapp(init: any) {\n  let appinjector;\n  const declareappproviders = (providers: any[]) => {\n    const appinjector = getinjector(providers, default_injector);\n    return function (app: any) {\n      app.provide(injector_key, appinjector);\n    };\n  };\n  const useappservice = (token: any, options?: any) => {\n    return getservicefrominjector(appinjector, token, options);\n  };\n  init(declareappproviders, useappservice);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n// 使用bootstrapapp函数\nbootstrapapp(function (declareappproviders, useappservice) {\n  // 定义providers数组\n  const providers = [\n    someservice,\n    {\n      provide: sometoken,\n      useclass: anotherservice,\n    },\n  ];\n  // 使用插件配置providers\n  // 这里会在app.context.providers中关联一个app injector\n  // 注意这里的injector并不是关联到某一个组件而是app，我称之为app injector\n  app.use(declareappproviders(providers));\n  // 有需要的话可以提前获取服务\n  const someservice = useappservice(someservice);\n  // 并在创建应用之前就能调用服务的方法\n  someservice.dosomething();\n  app.mount("#app");\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n提示\n\n注意declareappproviders只能调用一次，否则 appinjector 就被覆盖了。useappservice必须在declareappproviders后面调用。\n\n提示\n\n以上代码只是作为参考，绝大多数项目是完全不需要这种实现方案的，直接使用 root injector 就可以了。',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"API文档",frontmatter:{title:"API文档",date:"2021-12-19T16:48:30.000Z",permalink:"/pages/36ae88/",categories:["项目文档","use-vue-service"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/01.use-vue-service/90.API%E6%96%87%E6%A1%A3.html",relativePath:"30.项目文档/01.use-vue-service/90.API文档.md",key:"v-28f80f80",path:"/pages/36ae88/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:13},{level:2,title:"declareProviders",slug:"declareproviders",normalizedTitle:"declareproviders",charIndex:76},{level:2,title:"useService",slug:"useservice",normalizedTitle:"useservice",charIndex:723},{level:2,title:"declareRootProviders",slug:"declarerootproviders",normalizedTitle:"declarerootproviders",charIndex:2836},{level:2,title:"useRootService",slug:"userootservice",normalizedTitle:"userootservice",charIndex:3165}],headersStr:"简介 declareProviders useService declareRootProviders useRootService",content:"# API 文档\n\n\n# 简介\n\n本库是在@kaokei/di的基础上增加了若干新的 API，@kaokei/di提供的 API 都是可用的。\n\n\n# declareProviders\n\ndeclareProviders([\n  SomeService,\n  {\n    provide: SomeService,\n    useClass: SomeService,\n  },\n  {\n    provide: SomeService,\n    useClass: SomeOtherService,\n  },\n  {\n    provide: SomeService,\n    useValue: someServiceInstance,\n  },\n  {\n    provide: SomeService,\n    useExisting: SomeOtherService,\n  },\n  {\n    provide: SomeService,\n    useFactory: (dependService1, dependService2, dependService3) => {\n      return someServiceInstance;\n    },\n    deps: [DependService1, DependService2, DependService3],\n  },\n]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n本函数只能在 setup 函数中使用。建议在 setup 的第一行使用，至少也需要在 useService 函数之前使用，否则效果可能不符合预期。\n\n因为当前组件可能依赖了多个服务，所以可以一次性定义多个服务的 provider，所以本函数的参数是一个数组。以上列出了 provider 的所有可能形式，每种 provider 代表了不同的生成服务的方式。\n\n本函数的作用是在当前组件中关联一个 Injector，这个 Injector 中根据providers声明了token与对应的服务的关联关系。这样后续在使用useService的时候就能根据token找到对应的服务。\n\n我们知道整个应用的所有组件会组成一颗组件树，本函数的作用就是在这颗组件树中的某些组件关联 Injector。这些 Injector 也会形成一颗类似的树形结构，这棵树的根部是一个根Injector。\n\n当然正常情况下，Injector 的数量会比组件的数量少很多，因为并不是所有的组件都需要关联一个 Injector。\n\n想象一下，如果整个应用中所有的服务都是不同的，都是全局单例的。那么我们可能不需要使用declareProviders，只要把所有服务都放到根Injector中即可。\n\n但是如果我们想要实现服务实例的生命周期和某个组件保持一致，最常见的场景就是路由组件。那么显然我们应该把服务定义在对应的路由组件中，而不是在根 Injector 中。因为当路由组件销毁时，对应的 Inejctor 也会销毁，然后 Injector 中的服务的实例对象也会被销毁。反之如果所有服务都是放在全局的根 Injector 中，因为根组件是不会销毁的，所以根 Injector 也不会销毁，导致某些数据一直存在于根 Injector 中，但是这也许不是我们想要的。\n\n除了控制服务实例的生命周期，另一个功能就是可以实现同一个服务的多例效果。显而易见如果我们在不同的组件中调用declareProviders，并且配置了同一个服务。那么在获取服务实例时就能得到同一个服务的不同实例，因为在不同的组件中是对应的不同的 Injector，就算是相同的服务，也会生成不同的实例对象。\n\n提示\n\ndeclareProviders只能在 setup 中使用，且在同一个 setup 中只能调用一次，且应该在最顶部调用。\n\n\n# useService\n\n// 示例1\nconst someService = useService(SomeService);\n\n// 示例2\nconst [someService1, someService2, someService3] = useService([\n  SomeService1,\n  SomeService2,\n  SomeService3,\n]);\n\n// 示例3\nconst someService = useService(SomeService, {\n  skip: true,\n  optional: true,\n});\n\n// 示例4\nconst someService = useService(SomeService, {\n  self: true,\n  optional: true,\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n只能在 setup 函数中使用。\n\n我们可以一次获取单个服务的实例对象，也可以一次性获取多个服务的实例对象。\n\n第一个参数是 token 或者 token 数组。而且可以指定第二个参数 options 对象来控制 useService 的解析过程。\n\nuseService 的作用非常类似@Inject。尤其是第二个参数 options 对象，支持这些属性：\n\n * self 对应装饰器@Self\n * skip 对应装饰器@Skip\n * optional 对应装饰器@Optional\n\n其实 useService 的作用是等价于装饰器@Inject的，只不过装饰器只能在类中使用，不能在函数上使用，所以只好额外提供一个 useService 函数在 setup 函数中使用。\n\n比如在 angular 中，就不需要这样一个函数来获取实例。因为 angular 应用中组件和服务的形式只能是类，在组件类中可以直接使用@Inject 来注入服务或者其他组件。\n\n但是在 Vue 中，Vue 组件的形式有两种，一种是类组件，这种情况我们也可以不使用 useService，可以直接使用@Inject 来注入服务；另一种情况则是 Option 组件，因为 Option 组件不是类，所以不能使用装饰器。只能使用 useService 这种类似 hooks 的方法类获取实例对象。\n\nuseService 非常优秀的一点就是返回值都是自带类型的，从而可以非常方便的使用.来知道这个服务有哪些属性和方法。\n\n另外一点就是其返回值已经是 reactive 的，可以直接在 vue 模版中使用。\n\n提示\n\nuseService只能在 setup 中使用，可以多次使用。\n\n\n# declareRootProviders\n\n语法和declareProviders一致，只不过作用有所区别。\n\ndeclareProviders 的作用是在调用的组件中关联一个 Injector，并声明一些 providres。但是declareRootProviders的作用是直接在根 Injector 中声明 providers。\n\ndeclareProviders 只能在 setup 函数中调用，且只能调用一次，但是 declareRootProviders 没有这些限制。\n\n为什么需要这个函数\n\n提示\n\n注意到 declareRootProviders 声明的服务是全局的，那么后续通过useService\b也是可以使用到这些服务的。\n\n\n# useRootService\n\n语法和useService一致，只不过作用有所区别。\n\nuseService 会从当前组件关联的 Injector 开始寻找对应的 Provider，如果没有找到，那么会从父组件关联的 Injector 中寻找，直到根 Injector 为止。\n\nuseRootService 则是直接从根 Injector 中寻找对应的 Provider。\n\nuseService 只能在 setup 函数中调用，但是 useRootService 没有这个限制。\n\n为什么需要这个函数",normalizedContent:"# api 文档\n\n\n# 简介\n\n本库是在@kaokei/di的基础上增加了若干新的 api，@kaokei/di提供的 api 都是可用的。\n\n\n# declareproviders\n\ndeclareproviders([\n  someservice,\n  {\n    provide: someservice,\n    useclass: someservice,\n  },\n  {\n    provide: someservice,\n    useclass: someotherservice,\n  },\n  {\n    provide: someservice,\n    usevalue: someserviceinstance,\n  },\n  {\n    provide: someservice,\n    useexisting: someotherservice,\n  },\n  {\n    provide: someservice,\n    usefactory: (dependservice1, dependservice2, dependservice3) => {\n      return someserviceinstance;\n    },\n    deps: [dependservice1, dependservice2, dependservice3],\n  },\n]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n本函数只能在 setup 函数中使用。建议在 setup 的第一行使用，至少也需要在 useservice 函数之前使用，否则效果可能不符合预期。\n\n因为当前组件可能依赖了多个服务，所以可以一次性定义多个服务的 provider，所以本函数的参数是一个数组。以上列出了 provider 的所有可能形式，每种 provider 代表了不同的生成服务的方式。\n\n本函数的作用是在当前组件中关联一个 injector，这个 injector 中根据providers声明了token与对应的服务的关联关系。这样后续在使用useservice的时候就能根据token找到对应的服务。\n\n我们知道整个应用的所有组件会组成一颗组件树，本函数的作用就是在这颗组件树中的某些组件关联 injector。这些 injector 也会形成一颗类似的树形结构，这棵树的根部是一个根injector。\n\n当然正常情况下，injector 的数量会比组件的数量少很多，因为并不是所有的组件都需要关联一个 injector。\n\n想象一下，如果整个应用中所有的服务都是不同的，都是全局单例的。那么我们可能不需要使用declareproviders，只要把所有服务都放到根injector中即可。\n\n但是如果我们想要实现服务实例的生命周期和某个组件保持一致，最常见的场景就是路由组件。那么显然我们应该把服务定义在对应的路由组件中，而不是在根 injector 中。因为当路由组件销毁时，对应的 inejctor 也会销毁，然后 injector 中的服务的实例对象也会被销毁。反之如果所有服务都是放在全局的根 injector 中，因为根组件是不会销毁的，所以根 injector 也不会销毁，导致某些数据一直存在于根 injector 中，但是这也许不是我们想要的。\n\n除了控制服务实例的生命周期，另一个功能就是可以实现同一个服务的多例效果。显而易见如果我们在不同的组件中调用declareproviders，并且配置了同一个服务。那么在获取服务实例时就能得到同一个服务的不同实例，因为在不同的组件中是对应的不同的 injector，就算是相同的服务，也会生成不同的实例对象。\n\n提示\n\ndeclareproviders只能在 setup 中使用，且在同一个 setup 中只能调用一次，且应该在最顶部调用。\n\n\n# useservice\n\n// 示例1\nconst someservice = useservice(someservice);\n\n// 示例2\nconst [someservice1, someservice2, someservice3] = useservice([\n  someservice1,\n  someservice2,\n  someservice3,\n]);\n\n// 示例3\nconst someservice = useservice(someservice, {\n  skip: true,\n  optional: true,\n});\n\n// 示例4\nconst someservice = useservice(someservice, {\n  self: true,\n  optional: true,\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n只能在 setup 函数中使用。\n\n我们可以一次获取单个服务的实例对象，也可以一次性获取多个服务的实例对象。\n\n第一个参数是 token 或者 token 数组。而且可以指定第二个参数 options 对象来控制 useservice 的解析过程。\n\nuseservice 的作用非常类似@inject。尤其是第二个参数 options 对象，支持这些属性：\n\n * self 对应装饰器@self\n * skip 对应装饰器@skip\n * optional 对应装饰器@optional\n\n其实 useservice 的作用是等价于装饰器@inject的，只不过装饰器只能在类中使用，不能在函数上使用，所以只好额外提供一个 useservice 函数在 setup 函数中使用。\n\n比如在 angular 中，就不需要这样一个函数来获取实例。因为 angular 应用中组件和服务的形式只能是类，在组件类中可以直接使用@inject 来注入服务或者其他组件。\n\n但是在 vue 中，vue 组件的形式有两种，一种是类组件，这种情况我们也可以不使用 useservice，可以直接使用@inject 来注入服务；另一种情况则是 option 组件，因为 option 组件不是类，所以不能使用装饰器。只能使用 useservice 这种类似 hooks 的方法类获取实例对象。\n\nuseservice 非常优秀的一点就是返回值都是自带类型的，从而可以非常方便的使用.来知道这个服务有哪些属性和方法。\n\n另外一点就是其返回值已经是 reactive 的，可以直接在 vue 模版中使用。\n\n提示\n\nuseservice只能在 setup 中使用，可以多次使用。\n\n\n# declarerootproviders\n\n语法和declareproviders一致，只不过作用有所区别。\n\ndeclareproviders 的作用是在调用的组件中关联一个 injector，并声明一些 providres。但是declarerootproviders的作用是直接在根 injector 中声明 providers。\n\ndeclareproviders 只能在 setup 函数中调用，且只能调用一次，但是 declarerootproviders 没有这些限制。\n\n为什么需要这个函数\n\n提示\n\n注意到 declarerootproviders 声明的服务是全局的，那么后续通过useservice\b也是可以使用到这些服务的。\n\n\n# userootservice\n\n语法和useservice一致，只不过作用有所区别。\n\nuseservice 会从当前组件关联的 injector 开始寻找对应的 provider，如果没有找到，那么会从父组件关联的 injector 中寻找，直到根 injector 为止。\n\nuserootservice 则是直接从根 injector 中寻找对应的 provider。\n\nuseservice 只能在 setup 函数中调用，但是 userootservice 没有这个限制。\n\n为什么需要这个函数",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"FAQ",frontmatter:{title:"FAQ",date:"2022-02-17T19:39:59.000Z",permalink:"/pages/e83ee6/",categories:["项目文档","use-vue-service"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/01.use-vue-service/91.faq.html",relativePath:"30.项目文档/01.use-vue-service/91.faq.md",key:"v-dd8aeb38",path:"/pages/e83ee6/",headers:[{level:2,title:"useReactiveRef 与 useRef 不兼容",slug:"usereactiveref-与-useref-不兼容",normalizedTitle:"usereactiveref 与 useref 不兼容",charIndex:558},{level:2,title:"支持 watch 功能",slug:"支持-watch-功能",normalizedTitle:"支持 watch 功能",charIndex:663},{level:2,title:"支持 class component",slug:"支持-class-component",normalizedTitle:"支持 class component",charIndex:711},{level:2,title:"生命周期",slug:"生命周期",normalizedTitle:"生命周期",charIndex:871},{level:2,title:"hooks",slug:"hooks",normalizedTitle:"hooks",charIndex:898},{level:2,title:"支持 vue 插件",slug:"支持-vue-插件",normalizedTitle:"支持 vue 插件",charIndex:953}],headersStr:"useReactiveRef 与 useRef 不兼容 支持 watch 功能 支持 class component 生命周期 hooks 支持 vue 插件",content:" 1. 本来是想实现@Skip 可以指定跳过的次数，后来废弃了这个特性，只是实现了@Skip。\n\n理由是不建议通过@Skip 来实现复杂命名空间的作用，我们可以利用 useClass 指向同一个 Service，但是提供不同的 provide 来实现多个服务。\n\n 2. 服务可能是有初始状态的\n\n如果服务的初始状态需要从服务器端获取，那么就会存在异步的问题，比如父子组件共享一个服务，在服务的状态还没有初始化完毕时，子组件就已经触发了某个动作去修改服务的状态，显然就会导致状态错乱。解决方案有两种。\n\n第一种：使用 rxjs 的 observable 把状态变成流，不确定是否和 reactive 有冲突\n\n第二种：就在在父组件中判断服务的状态是否已经 ready，如果 ready 了才显示子组件，否则展示 loading\n\n 3. 本库的 inject 和 vue 提供的 inject 不一样，本库的 inject 是从当前组件开始寻找数据的\n\n因为 vue3 自带的 inject 依赖了原型链，并且子组件的 provides 属性默认就是父组件的 provides，从而导致虽然是从当前组件的 provides 开始寻找的服务。但是实际上这个服务有可能是从父组件的 Injector 中获取的。\n\n\n# useReactiveRef 与 useRef 不兼容\n\n解决不了\n\n主要体现在 react 自带的 useRef 使用的是 current 属性，但是 vue 中 ref 使用的是 value 属性\n\n\n# 支持 watch 功能\n\nwatch 功能其实和 useEffect 已经非常相似了。\n\n\n# 支持 class component\n\n不支持\n\n经过考虑，本库默认不支持类组件，并且计划把 use-vue-service 库中也去掉对类组件的支持。\n\n如果以后有时间可以考虑新增加一个专门库来支持类组件。\n\n这一点是参考了 mobx 的实现。并且我也认为实在是没有必要使用到类组件，而外增加了实现的复杂度。\n\n\n# 生命周期\n\n主要是 destroy，卸载资源\n\n\n# hooks\n\npost hook\n\nmerge hook\n\n需要这两个 hook 才能配置响应式能力\n\n\n# 支持 vue 插件\n\n在 app 实例上声明 providers",normalizedContent:" 1. 本来是想实现@skip 可以指定跳过的次数，后来废弃了这个特性，只是实现了@skip。\n\n理由是不建议通过@skip 来实现复杂命名空间的作用，我们可以利用 useclass 指向同一个 service，但是提供不同的 provide 来实现多个服务。\n\n 2. 服务可能是有初始状态的\n\n如果服务的初始状态需要从服务器端获取，那么就会存在异步的问题，比如父子组件共享一个服务，在服务的状态还没有初始化完毕时，子组件就已经触发了某个动作去修改服务的状态，显然就会导致状态错乱。解决方案有两种。\n\n第一种：使用 rxjs 的 observable 把状态变成流，不确定是否和 reactive 有冲突\n\n第二种：就在在父组件中判断服务的状态是否已经 ready，如果 ready 了才显示子组件，否则展示 loading\n\n 3. 本库的 inject 和 vue 提供的 inject 不一样，本库的 inject 是从当前组件开始寻找数据的\n\n因为 vue3 自带的 inject 依赖了原型链，并且子组件的 provides 属性默认就是父组件的 provides，从而导致虽然是从当前组件的 provides 开始寻找的服务。但是实际上这个服务有可能是从父组件的 injector 中获取的。\n\n\n# usereactiveref 与 useref 不兼容\n\n解决不了\n\n主要体现在 react 自带的 useref 使用的是 current 属性，但是 vue 中 ref 使用的是 value 属性\n\n\n# 支持 watch 功能\n\nwatch 功能其实和 useeffect 已经非常相似了。\n\n\n# 支持 class component\n\n不支持\n\n经过考虑，本库默认不支持类组件，并且计划把 use-vue-service 库中也去掉对类组件的支持。\n\n如果以后有时间可以考虑新增加一个专门库来支持类组件。\n\n这一点是参考了 mobx 的实现。并且我也认为实在是没有必要使用到类组件，而外增加了实现的复杂度。\n\n\n# 生命周期\n\n主要是 destroy，卸载资源\n\n\n# hooks\n\npost hook\n\nmerge hook\n\n需要这两个 hook 才能配置响应式能力\n\n\n# 支持 vue 插件\n\n在 app 实例上声明 providers",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"案例",frontmatter:{title:"案例",date:"2022-02-18T10:18:23.000Z",permalink:"/pages/c72e25/",categories:["项目文档","use-vue-service"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/01.use-vue-service/92.%E6%A1%88%E4%BE%8B.html",relativePath:"30.项目文档/01.use-vue-service/92.案例.md",key:"v-13e9637e",path:"/pages/c72e25/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"资源",frontmatter:{title:"资源",date:"2022-02-18T10:18:32.000Z",permalink:"/pages/c70da9/",categories:["项目文档","use-vue-service"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/01.use-vue-service/93.%E8%B5%84%E6%BA%90.html",relativePath:"30.项目文档/01.use-vue-service/93.资源.md",key:"v-3352929f",path:"/pages/c70da9/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"快速开始",frontmatter:{title:"快速开始",date:"2021-12-17T10:30:51.000Z",permalink:"/pages/ac9306/",categories:["项目文档","use-react-service"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/02.use-react-service/00.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B.html",relativePath:"30.项目文档/02.use-react-service/00.快速开始.md",key:"v-dfc1e590",path:"/pages/ac9306/",headersStr:null,content:"# 干了第一碗鸡汤\n\n干了这碗鸡汤，我们都是中国人。\n\n快速入门use-react-service\n\nTBD...",normalizedContent:"# 干了第一碗鸡汤\n\n干了这碗鸡汤，我们都是中国人。\n\n快速入门use-react-service\n\ntbd...",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"快速开始",frontmatter:{title:"快速开始",date:"2021-12-17T10:30:54.000Z",permalink:"/pages/550423/",categories:["项目文档","use-solid-service"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/03.use-solid-service/00.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B.html",relativePath:"30.项目文档/03.use-solid-service/00.快速开始.md",key:"v-3c50469e",path:"/pages/550423/",headersStr:null,content:"# 干了第一碗鸡汤\n\n干了这碗鸡汤，我们都是中国人。\n\n快速入门use-solid-service\n\nTBD...",normalizedContent:"# 干了第一碗鸡汤\n\n干了这碗鸡汤，我们都是中国人。\n\n快速入门use-solid-service\n\ntbd...",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"快速开始",frontmatter:{title:"快速开始",date:"2021-12-17T10:30:54.000Z",permalink:"/pages/0129d5/",categories:["项目文档","use-solid-service"],tags:[null]},regularPath:"/30.%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/04.use-svelte-service/00.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B.html",relativePath:"30.项目文档/04.use-svelte-service/00.快速开始.md",key:"v-4ba573aa",path:"/pages/0129d5/",headersStr:null,content:"# 干了第一碗鸡汤\n\n干了这碗鸡汤，我们都是中国人。\n\n快速入门use-svelte-service\n\nTBD...",normalizedContent:"# 干了第一碗鸡汤\n\n干了这碗鸡汤，我们都是中国人。\n\n快速入门use-svelte-service\n\ntbd...",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-50bc8525",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-537ab085",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-2f058aa5",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"Nestjs笔记",frontmatter:{author:"kaokei",title:"Nestjs笔记",categories:["笔记"],tags:[null],sidebar:"auto",date:"2022-07-22T15:38:21.000Z",permalink:"/pages/1684b4/",showSidebar:!1},regularPath:"/_posts/2022/01.Nestjs%E7%AC%94%E8%AE%B0.html",relativePath:"_posts/2022/01.Nestjs笔记.md",key:"v-09f2a40f",path:"/pages/1684b4/",excerpt:"<p>node.http 模块提供了最基础的 web 服务，但是不利于业务开发。</p>\n<p>Express 则是提供了标准的 request/response，以及中间件和路由，基本满足业务开发的需求。</p>\n<p>Nestjs 则是在 Express 的基础上提供了依赖注入的能力，并且要求代码组织结构满足一定的规范。</p>\n<p>注意到 Nestjs 的核心是数据库无关的，也就是说可以和 Express 一样引入数据库驱动/数据库 orm 框架即可操作数据库。当然也可以引入 GraphQL 框架来开发 GraphQL 应用。注意到 Express 也是可以开发 GraphQL 应用的，所以没有本质上的区别。只不过 Nestjs 本身提供了很多官方的 npm 包。</p>\n",headersStr:null,content:"node.http 模块提供了最基础的 web 服务，但是不利于业务开发。\n\nExpress 则是提供了标准的 request/response，以及中间件和路由，基本满足业务开发的需求。\n\nNestjs 则是在 Express 的基础上提供了依赖注入的能力，并且要求代码组织结构满足一定的规范。\n\n注意到 Nestjs 的核心是数据库无关的，也就是说可以和 Express 一样引入数据库驱动/数据库 orm 框架即可操作数据库。当然也可以引入 GraphQL 框架来开发 GraphQL 应用。注意到 Express 也是可以开发 GraphQL 应用的，所以没有本质上的区别。只不过 Nestjs 本身提供了很多官方的 npm 包。",normalizedContent:"node.http 模块提供了最基础的 web 服务，但是不利于业务开发。\n\nexpress 则是提供了标准的 request/response，以及中间件和路由，基本满足业务开发的需求。\n\nnestjs 则是在 express 的基础上提供了依赖注入的能力，并且要求代码组织结构满足一定的规范。\n\n注意到 nestjs 的核心是数据库无关的，也就是说可以和 express 一样引入数据库驱动/数据库 orm 框架即可操作数据库。当然也可以引入 graphql 框架来开发 graphql 应用。注意到 express 也是可以开发 graphql 应用的，所以没有本质上的区别。只不过 nestjs 本身提供了很多官方的 npm 包。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"如何使用类组件",frontmatter:{author:"kaokei",title:"如何使用类组件",date:"2021-12-19T16:51:01.000Z",categories:["项目文档","use-vue-service"],tags:[null],sidebar:"auto",permalink:"/pages/b17e7e/",showSidebar:!1},regularPath:"/_posts/93.component.html",relativePath:"_posts/93.component.md",key:"v-653cdd76",path:"/pages/b17e7e/",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:2},{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:84},{level:2,title:"类组件与 Option 组件的区别",slug:"类组件与-option-组件的区别",normalizedTitle:"类组件与 option 组件的区别",charIndex:431},{level:3,title:"setup 的不同",slug:"setup-的不同",normalizedTitle:"setup 的不同",charIndex:453},{level:3,title:"computed 的不同",slug:"computed-的不同",normalizedTitle:"computed 的不同",charIndex:708},{level:3,title:"watch 的不同",slug:"watch-的不同",normalizedTitle:"watch 的不同",charIndex:869},{level:3,title:"类组件转化为 Option 组件",slug:"类组件转化为-option-组件",normalizedTitle:"类组件转化为 option 组件",charIndex:982},{level:2,title:"使用类组件",slug:"使用类组件",normalizedTitle:"使用类组件",charIndex:110},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:3610}],headersStr:"安装 简介 类组件与 Option 组件的区别 setup 的不同 computed 的不同 watch 的不同 类组件转化为 Option 组件 使用类组件 参考文章",content:'# 安装\n\n如果还没有安装 vue-class-component\n\nnpm install -S vue-class-component@next\n\n\n1\n\n\n\n# 简介\n\n本教程继续介绍下面这个 api，进而掌握如何使用类组件，以及在类组件中使用依赖注入能力。\n\n * Component\n\n整体上来说不太推荐使用类组件，但是有些人比较偏爱类组件，所以本库也支持类组件的依赖注入。\n\n不推荐的原因主要是因为 vue 并不是本身就支持类组件，而是需要借助vue-class-component这个库才能实现支持类组件。虽然这个库也是官方维护的。但毕竟不是原生支持的。\n\n其实我本身还是比较喜欢类组件的，因为如果整个项目包括服务和组件都是类，整体是比较一致的。只是类组件毕竟不是原生支持的，感觉还是不够顺手。\n\n不管怎么说，整个项目要不全都用类组件，要不全都用 Option 组件，不要部分组件用类，另一部分组件又用 Option。至少要保持风格统一。\n\n\n# 类组件与 Option 组件的区别\n\n\n# setup 的不同\n\n在 Option 组件中，只有一个 setup 函数，意味着只有一个闭包，我可以在这个闭包内基于已有的数据派生出其他数据。\n\n但是在类组件中，虽然也可以使用 setup 函数，但是含义已经不一样了，它是对实例属性的延迟初始化的一种方式。\n\n而且本质也不一样，类组件需要借助vue-class-component库才能使用。而且这里的 setup 也是从 vue-class-component 导入的函数。但是在 Option 组件中，setup 只是组件的一个预定义属性而已。\n\n\n# computed 的不同\n\n在 Option 组件中，我们可以在 setup 闭包中使用const computedValue = computed(() => {})，然后导出这个 computedValue 即可。\n\n但是在类组件中，我们则是通过定义 getter 函数来实现 computed 属性的功能。\n\n\n# watch 的不同\n\n在 Option 组件中，我们可以在 setup 闭包中使用watchEffect()来定义 watch 功能。\n\n但是在类组件中，这个已经不在类中定义了，只能在装饰器中定义 watch 属性。\n\n\n# 类组件转化为 Option 组件\n\n通过观察 vue-class-component 的源码，我们可以发现类组件虽然看上去像是一个类，但是最终还是被转换为 Option 组件了。\n\n而且为了获取类的的实例属性，必须得实例化一次。这意味着类组件的构造函数会被执行两次。所以在 vue 的类组件的构造函数中不能定义有副作用的逻辑，实际上是不建议定义类组件的构造函数的。\n\n\n# 使用类组件\n\n如何在 vue 中使用类组件的具体官方文档可以参考这里，当然目前这个文档是 vue2.x 的，vue3.x 的文档还没有出来，可以参考这里。\n\n本库在vue-class-component@next的基础上新增了一个 api，从而可以实现依赖注入的能力。\n\n<template>\n  <div class="container" :style="{ background: bgTheme }">\n    <span class="title">{{ name || "defaultName" }}:</span>\n    <button class="decrementBtn" type="button" @click="counter.decrement">\n      -\n    </button>\n    <span class="countNum">{{ counter?.count }}</span>\n    <button class="incrementBtn" type="button" @click="counter.increment">\n      +\n    </button>\n  </div>\n</template>\n\n<script lang="ts">\nimport { Vue } from "vue-class-component";\n\nimport { Component, Inject } from "@kaokei/use-vue-service";\n\nimport { COUNTER_THEME } from "@services/service.context.ts";\nimport { SwitchService } from "@services/switch.service.ts";\nimport { CounterService } from "@services/counter.service.ts";\n\nclass Props {\n  name?: string;\n  bgColor?: string;\n}\n\n@Component({\n  providers: [\n    {\n      provide: COUNTER_THEME,\n      useValue: "red",\n    },\n    CounterService,\n  ],\n})\nexport default class Person extends Vue.with(Props) {\n  @Inject(COUNTER_THEME)\n  public theme!: string;\n\n  @Inject(CounterService)\n  public counter!: CounterService;\n\n  @Inject(SwitchService)\n  public switchService!: SwitchService;\n\n  public get bgTheme() {\n    if (this.switchService.counterStatus === 1) {\n      return this.bgColor || this.theme;\n    } else {\n      return "transparent";\n    }\n  }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n这份示例代码中有很多可以说一说的地方。\n\n第一点：export default class Person extends Vue.with(Props)这行代码是vue-class-component规定的模板代码，并不是本库的要求。\n\n第二点：虽然 Person 是一个组件，但是整体上来看也可以理解为一个服务，可以利用@Inject注入其他的服务。需要特别注意的地方时，在普通服务中，我们可以在类的构造函数中声明依赖，但是在类组件中则不能通过构造函数声明依赖。只能通过实例属性来声明依赖。这是因为 vue 类组件的构造函数已经定义好了参数constructor(props: Record<string, any>, ctx: SetupContext)。而且由于类组件在转化为 Option 组件的时候，实际上会调用两次构造函数，所以是不建议在类组件的构造函数中增加其他逻辑的。\n\n第三点：定义了 bgTheme 这个 getter 函数，其功能相当于 vue 中的 computed 属性。\n\n第四点：也是最重要的一点，使用@Component()这个装饰器来定义类组件。这里有一个取巧的地方，就是在 vue-class-component@7.x 及之前的版本中，都是采用的@Component()这个装饰器定义类组件的，但是在 vue-class-component@8.x 中，已经改为@Options()来定义类组件了。所以本库正好可以占用@Component这个 API。本库提供的@Component与 vue-class-component@8.x 提供的@Options的区别主要有两点：\n\n * @Options 支持的参数，@Component 都是支持的。而且额外支持了 providers 这个参数，这个参数可以代替 declareProviders 函数。\n\n * @Component 是对@Options 的封装，同时支持了依赖注入的能力。\n\n\n# 参考文章\n\n * Vue Class Component 官网',normalizedContent:'# 安装\n\n如果还没有安装 vue-class-component\n\nnpm install -s vue-class-component@next\n\n\n1\n\n\n\n# 简介\n\n本教程继续介绍下面这个 api，进而掌握如何使用类组件，以及在类组件中使用依赖注入能力。\n\n * component\n\n整体上来说不太推荐使用类组件，但是有些人比较偏爱类组件，所以本库也支持类组件的依赖注入。\n\n不推荐的原因主要是因为 vue 并不是本身就支持类组件，而是需要借助vue-class-component这个库才能实现支持类组件。虽然这个库也是官方维护的。但毕竟不是原生支持的。\n\n其实我本身还是比较喜欢类组件的，因为如果整个项目包括服务和组件都是类，整体是比较一致的。只是类组件毕竟不是原生支持的，感觉还是不够顺手。\n\n不管怎么说，整个项目要不全都用类组件，要不全都用 option 组件，不要部分组件用类，另一部分组件又用 option。至少要保持风格统一。\n\n\n# 类组件与 option 组件的区别\n\n\n# setup 的不同\n\n在 option 组件中，只有一个 setup 函数，意味着只有一个闭包，我可以在这个闭包内基于已有的数据派生出其他数据。\n\n但是在类组件中，虽然也可以使用 setup 函数，但是含义已经不一样了，它是对实例属性的延迟初始化的一种方式。\n\n而且本质也不一样，类组件需要借助vue-class-component库才能使用。而且这里的 setup 也是从 vue-class-component 导入的函数。但是在 option 组件中，setup 只是组件的一个预定义属性而已。\n\n\n# computed 的不同\n\n在 option 组件中，我们可以在 setup 闭包中使用const computedvalue = computed(() => {})，然后导出这个 computedvalue 即可。\n\n但是在类组件中，我们则是通过定义 getter 函数来实现 computed 属性的功能。\n\n\n# watch 的不同\n\n在 option 组件中，我们可以在 setup 闭包中使用watcheffect()来定义 watch 功能。\n\n但是在类组件中，这个已经不在类中定义了，只能在装饰器中定义 watch 属性。\n\n\n# 类组件转化为 option 组件\n\n通过观察 vue-class-component 的源码，我们可以发现类组件虽然看上去像是一个类，但是最终还是被转换为 option 组件了。\n\n而且为了获取类的的实例属性，必须得实例化一次。这意味着类组件的构造函数会被执行两次。所以在 vue 的类组件的构造函数中不能定义有副作用的逻辑，实际上是不建议定义类组件的构造函数的。\n\n\n# 使用类组件\n\n如何在 vue 中使用类组件的具体官方文档可以参考这里，当然目前这个文档是 vue2.x 的，vue3.x 的文档还没有出来，可以参考这里。\n\n本库在vue-class-component@next的基础上新增了一个 api，从而可以实现依赖注入的能力。\n\n<template>\n  <div class="container" :style="{ background: bgtheme }">\n    <span class="title">{{ name || "defaultname" }}:</span>\n    <button class="decrementbtn" type="button" @click="counter.decrement">\n      -\n    </button>\n    <span class="countnum">{{ counter?.count }}</span>\n    <button class="incrementbtn" type="button" @click="counter.increment">\n      +\n    </button>\n  </div>\n</template>\n\n<script lang="ts">\nimport { vue } from "vue-class-component";\n\nimport { component, inject } from "@kaokei/use-vue-service";\n\nimport { counter_theme } from "@services/service.context.ts";\nimport { switchservice } from "@services/switch.service.ts";\nimport { counterservice } from "@services/counter.service.ts";\n\nclass props {\n  name?: string;\n  bgcolor?: string;\n}\n\n@component({\n  providers: [\n    {\n      provide: counter_theme,\n      usevalue: "red",\n    },\n    counterservice,\n  ],\n})\nexport default class person extends vue.with(props) {\n  @inject(counter_theme)\n  public theme!: string;\n\n  @inject(counterservice)\n  public counter!: counterservice;\n\n  @inject(switchservice)\n  public switchservice!: switchservice;\n\n  public get bgtheme() {\n    if (this.switchservice.counterstatus === 1) {\n      return this.bgcolor || this.theme;\n    } else {\n      return "transparent";\n    }\n  }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n这份示例代码中有很多可以说一说的地方。\n\n第一点：export default class person extends vue.with(props)这行代码是vue-class-component规定的模板代码，并不是本库的要求。\n\n第二点：虽然 person 是一个组件，但是整体上来看也可以理解为一个服务，可以利用@inject注入其他的服务。需要特别注意的地方时，在普通服务中，我们可以在类的构造函数中声明依赖，但是在类组件中则不能通过构造函数声明依赖。只能通过实例属性来声明依赖。这是因为 vue 类组件的构造函数已经定义好了参数constructor(props: record<string, any>, ctx: setupcontext)。而且由于类组件在转化为 option 组件的时候，实际上会调用两次构造函数，所以是不建议在类组件的构造函数中增加其他逻辑的。\n\n第三点：定义了 bgtheme 这个 getter 函数，其功能相当于 vue 中的 computed 属性。\n\n第四点：也是最重要的一点，使用@component()这个装饰器来定义类组件。这里有一个取巧的地方，就是在 vue-class-component@7.x 及之前的版本中，都是采用的@component()这个装饰器定义类组件的，但是在 vue-class-component@8.x 中，已经改为@options()来定义类组件了。所以本库正好可以占用@component这个 api。本库提供的@component与 vue-class-component@8.x 提供的@options的区别主要有两点：\n\n * @options 支持的参数，@component 都是支持的。而且额外支持了 providers 这个参数，这个参数可以代替 declareproviders 函数。\n\n * @component 是对@options 的封装，同时支持了依赖注入的能力。\n\n\n# 参考文章\n\n * vue class component 官网',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"API文档",frontmatter:{title:"API文档",date:"2021-12-19T16:48:30.000Z",categories:["项目文档","use-vue-service"],tags:[null],sidebar:"auto",permalink:"/pages/44aecd/",showSidebar:!1},regularPath:"/_posts/99.API%E6%96%87%E6%A1%A3.html",relativePath:"_posts/99.API文档.md",key:"v-390e40a1",path:"/pages/44aecd/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:12},{level:2,title:"Inject 装饰器函数",slug:"inject-装饰器函数",normalizedTitle:"inject 装饰器函数",charIndex:391},{level:2,title:"Skip 装饰器函数",slug:"skip-装饰器函数",normalizedTitle:"skip 装饰器函数",charIndex:1305},{level:2,title:"Self 装饰器函数",slug:"self-装饰器函数",normalizedTitle:"self 装饰器函数",charIndex:2357},{level:2,title:"Optional 装饰器函数",slug:"optional-装饰器函数",normalizedTitle:"optional 装饰器函数",charIndex:3148},{level:2,title:"Injectable 装饰器函数",slug:"injectable-装饰器函数",normalizedTitle:"injectable 装饰器函数",charIndex:4490},{level:2,title:"Component 装饰器函数",slug:"component-装饰器函数",normalizedTitle:"component 装饰器函数",charIndex:5006},{level:2,title:"declareProviders 函数",slug:"declareproviders-函数",normalizedTitle:"declareproviders 函数",charIndex:5378},{level:2,title:"useService 函数",slug:"useservice-函数",normalizedTitle:"useservice 函数",charIndex:7135}],headersStr:"简介 Inject 装饰器函数 Skip 装饰器函数 Self 装饰器函数 Optional 装饰器函数 Injectable 装饰器函数 Component 装饰器函数 declareProviders 函数 useService 函数",content:'# API文档\n\n\n# 简介\n\n当前一共有 8 个 API，具体如下：\n\n# 提供依赖注入能力\n\n这些 api 是从@kaokei/di中导出的，是用来定义服务的。而且还可以在类组件中使用（除了 Injectable）。\n\n * Inject\n * Self\n * Skip\n * Optional\n * Injectable\n\n# 类组件专用\n\n * Component\n\n# Option 组件专用\n\n因为在 Option 组件中不能使用@Inject 的方式来注入服务。只能手动调用 useService 来获取服务实例。 同样在类组件中可以使用 Component 来定义 providers，但是在 Option 组件中不能使用装饰器。所以也提供了一个方法 declareProviders。\n\n * declareProviders\n * useService\n\n\n# Inject 装饰器函数\n\nimport { Injectable } from "@kaokei/use-vue-service";\nimport { LoggerService } from "./logger.service.ts";\n\n@Injectable()\nexport class CountService {\n  @Inject(LoggerService)\n  private logger1: LoggerService,\n\n  constructor(\n    @Inject(LoggerService) private logger2: LoggerService,\n  ) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n装饰器目前只能用在类上面，所以可以在类组件和类服务上使用。\n\n参考示例代码，可以看出来@Inject装饰器可以在实例属性以及类的构造函数的参数上使用。\n\n@Inject 的作用是在当前类实例化的时候，Injector 会自动帮助我们注入相应的实例属性和构造函数参数。\n\n@Inject 有一个必填的参数，作为需要注入的服务标识符。\n\n在实例属性上，@Inject 是必须的。如果没有这个装饰器，那么就是一个普通的属性。\n\n在构造函数的参数上，如果参数类型是类，比如这里的 logger2 的类型是 LoggerService 是一个类。那么这里其实是可以不使用@Inject 的。代码如下：\n\nconstructor(\n  private logger2: LoggerService,\n) {}\n\n\n1\n2\n3\n\n\n注意：最初的设计在实例属性上，如果属性的类型是一个类，@Inject 的参数是可以省略的，因为装饰器是可以获取到正确的类型的。最终为了代码一致性，把这个特性去掉了，强制要求@Inject 必须指定参数。总结起来就是只有构造函数中可以不使用@Inject，但是如果使用@Inejct 都必须指定参数。还有一点需要注意，实例属性和构造函数的参数的类型可以是interface，但是@Inject 的参数不能是interface。\n\n\n# Skip 装饰器函数\n\nimport { Injectable, Skip } from "@kaokei/use-vue-service";\nimport { LoggerService } from "./logger.service.ts";\n\n@Injectable()\nexport class CountService {\n  @Skip()\n  @Inject(LoggerService)\n  private logger1: LoggerService,\n\n  constructor(\n    @Skip()\n    @Inject(LoggerService)\n    private logger2: LoggerService,\n  ) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n同样是属于装饰器函数，配合@Inject 一起使用。\n\n@Skip 主要是控制@Inject 的行为，在没有@Skip 时，@Inject 会从当前的 Injector 中获取对应的服务，如果找不到则会自动从其父级 Injector 中寻找对应的服务，最终一直到根 Injector 中寻找服务。那么@Skip 的作用就是默认从当前的 Injector 的父级 Injector 开始寻找服务，即跳过当前 Injector。\n\n这样的场景不是很多见，比如当前组件中有一个 Student 服务，代表某个学生，显然我们可以直接@Inject 获取一个 Student 服务。假设其父组件中维护也维护着一个 Student 服务，并且父组件中已经有一个服务实例代表该班级最优秀的学生。那么如果在当前的子组件中想要获取这个最优秀的学生就需要用到@Skip 功能了。\n\n我知道有些同学的脑洞比较大，假设有一个更加复杂的场景，在班级最优秀的学生上面还有年级最优秀、学校最优秀、全市最优秀、全国最优秀、全球最优秀。。。那么如何在最底层的组件中获取以上服务实例呢？答案就是做不到。应该说只是借助@Skip 是做不到这个功能的。具体方法可以参考这里。\n\n其实一开始我是有实现@Skip(number)这个功能的，比如@Skip(5)就是向上跳过 5 层。最终考虑到这样的场景毕竟不是很常见的场景，反而因为实现这个功能降低了整个代码的效率。所以最终是去掉了这个功能。\n\n@Skip 有一个缺点，它可能不是从像你理解的那样跳过当前的 Injector。参考这里\n\n\n# Self 装饰器函数\n\nimport { Injectable, Self } from "@kaokei/use-vue-service";\nimport { LoggerService } from "./logger.service.ts";\n\n@Injectable()\nexport class CountService {\n  @Self()\n  @Inject(LoggerService)\n  private logger1: LoggerService,\n\n  constructor(\n    @Self()\n    @Inject(LoggerService)\n    private logger2: LoggerService,\n  ) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n同样是属于装饰器函数，配合@Inject 一起使用。\n\n根据函数名应该已经猜到其作用了。它控制了@Inject 只会从当前所属的 Injector 中获取服务实例。 咋一看似乎没什么实际用处。仔细一分析还真是没什么实际作用。\n\n因为是借鉴的 Angular 的 API，所以就给实现了。\n\n我的理解它最大的作用应该是起到警告的作用。比如我只想从当前 Injector 中获取 LoggerService，那么我必须要保证当前 Injector 中已经配置了 LoggerService 的 provider。如果我们手动已经保证了这一点，那么有没有@Self 是没有什么影响的。但是如果无意间我们删除了这个 provider，那么@Self 就会报错找不到服务。如果没有@Self 就有可能自动从更父级的 Injector 中寻找到 LoggerService，使得程序没有抛出异常，但是这可能不是我们想要的业务逻辑。\n\n\n# Optional 装饰器函数\n\nimport { Injectable, Optional, Self, Skip } from "@kaokei/use-vue-service";\nimport { LoggerService } from "./logger.service.ts";\n\n@Injectable()\nexport class CountService {\n  @Optional()\n  @Inject(LoggerService)\n  private logger1: LoggerService,\n\n  @Optional()\n  @Self()\n  @Inject(LoggerService)\n  private logger2: LoggerService,\n\n  @Optional()\n  @Skip()\n  @Inject(LoggerService)\n  private logger3: LoggerService,\n\n  constructor(\n    @Optional()\n    @Inject(LoggerService)\n    private logger4: LoggerService,\n\n    @Optional()\n    @Self()\n    @Inject(LoggerService)\n    private logger5: LoggerService,\n\n    @Optional()\n    @Skip()\n    @Inject(LoggerService)\n    private logger6: LoggerService,\n  ) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n同样是属于装饰器函数，配合@Inject 一起使用。\n\n之前我们有提到当 Injector 找不到对应的服务的 provider 时，会抛出异常。如果认为某个属性可以是非必须的，就可以使用@Optional，这时如果找不到 provider，就会返回undefined。\n\n注意：因为实例属性可能是 undefined，那么在调用实例属性的方法时就应该判空，像这样this.logger1?.log(\'hello world\');\n\n注意：默认情况下，如果服务的标识符是一个类，那么在找不到这个服务的 provider 时，就会直接实例化这个类当作服务实例。当然如果有@Self 控制@Inject 的话，就不会自动实例化类了。\n\n注意：上面提到的@Self 控制@Inject，所以就不会自动实例化类了。这在本库中是没有问题的。因为本库提供了一个默认的 Injector 作为根 Injector。实际上在@kaokei/di这个库中的实现要稍微复杂一些，当你手动实例时一个 Injector，并且没有指定父级 Injector 时，它自己就会作为根 Injector，而根 Injector 则又会自动实例化类了。具体代码可以参考这里。\n\n\n# Injectable 装饰器函数\n\nimport { Injectable } from "@kaokei/use-vue-service";\n\n@Injectable()\nexport class LoggerService {\n  public log(...msg: any[]) {\n    console.log("from logger service ==>", ...msg);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nInjectable 这个 api 是最简单的 api，只需要在定义服务类的时候，作为类的装饰器使用即可。\n\nInjectable 内部的实现是非常简单的，只是利用了 reflect-metadata 库简单的记录了服务类的构造函数的参数的类型信息。以便在后续实例化服务类的时候需要使用这些类型信息。\n\n可以理解为在构造函数的参数如果是类的时候，就可以不使用@Inject 的原因就在于@Injectable 已经收集到这些类的信息了。\n\n注意：虽然对于没有构造函数的类可以不使用@Injectable，但是为了保持一致性，还是尽量所有的服务类都使用@Injectable。\n\n\n# Component 装饰器函数\n\n@Component({\n  providers: [\n    {\n      provide: COUNTER_THEME,\n      useValue: "red",\n    },\n    CounterService,\n  ],\n})\nexport default class Person extends Vue.with(Props) {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n从示例代码中可以看出，@Component 作为类的装饰器，其参数是和vue-class-component@8.x中的@Options 函数基本是一致的。\n\n只不过在@Options 的基础上，@Component 还增加了一个参数，就是 providers，其效果就是 declareProviders 函数的作用，用于声明当前组件关联的 Injector 所需要的 providers。\n\n如果当前组件不需要 providers 参数，就可以这样写：\n\n@Component()\nexport default class Person extends Vue.with(Props) {\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\n关于 Component 这个 api 则是特意给类组件用的。它有三个作用：\n\n * 第一个作用是对 vue-class-component@8.x 中的@Options的封装；\n * 第二个作用是通过参数 providers 实现了 declareProviders 函数的功能；\n * 第三个作用是实现了类组件具有依赖注入的能力。\n   * 当然这里的注入是有限制的，只能注入实例属性，而不能注入构造函数参数。\n   * 类组件只能注入别的服务，而不能把类组件当作服务注入。这点在 Angular 中是被支持的，但是我觉得这个功能过于强大了，不符合数据驱动视图的原则。\n\n注意：vue-class-component在之前版本中都是使用的@Component这个装饰器，只是在版本 8 中修改为@Options了，正好本库可以捡个漏。\n\n\n# declareProviders 函数\n\n只能在 setup 函数中使用。\n\ndeclareProviders([\n  SomeService,\n  {\n    provide: SomeService,\n    useClass: SomeService,\n  },\n  {\n    provide: SomeService,\n    useClass: SomeOtherService,\n  },\n  {\n    provide: SomeService,\n    useValue: someServiceInstance,\n  },\n  {\n    provide: SomeService,\n    useExisting: SomeOtherService,\n  },\n  {\n    provide: SomeService,\n    useFactory: (dependService1, dependService2, dependService3) => {\n      return someServiceInstance;\n    },\n    deps: [DependService1, DependService2, DependService3],\n  },\n]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n可以一次性定义多个服务的 provider。以上列出了所有 provide 的形式。\n\n在解释其作用之前，我们必须了解 Injector 是类似 dom 树一样的树状结构，每个 Injector 都有一个父级 Injector，直到根 Injector 的父级为 null。\n\n当我们在组件的 setup 函数中调用了 declareProviders，就意味着这个组件关联了一个新的 Injector，这个 Injector 会根据我们刚才配置的 providers 来生成服务实例。\n\n想象一下，如果整个应用中所有的服务都是不同的，都是全局单例的。那么我们可能不需要使用declareProviders，把所有服务都放到根 Injector 中即可。\n\n但是如果我们想要实现服务实例的生命周期和某个组件保持一致，最常见的场景就是路由组件。那么显然我们应该把服务定义在对应的路由组件中，而不是在根 Injector 中。\n\n除了控制服务实例的生命周期，另一个功能就是可以实现同一个服务的多例效果。显而易见如果我们在不同的组件中调用declareProviders，并且配置了同一个服务。那么在获取服务实例时就能得到同一个服务的不同实例。\n\n注意：declareProviders在同一个 setup 中只能调用一次，而且应该在最顶部调用。\n\n\n# useService 函数\n\n只能在 setup 函数中使用。\n\nconst someService = useService(SomeService);\n\nconst [someService1, someService2, someService3] = useService([\n  SomeService1,\n  SomeService2,\n  SomeService3,\n]);\n\nconst someService = useService(SomeService, {\n  skip: true,\n  optional: true,\n  defaultValue: "somwService",\n});\n\nconst someService = useService(SomeService, {\n  self: true,\n  optional: true,\n  defaultValue: "somwService",\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n我们可以一次获取单个服务的实例对象，也可以一次性获取多个服务的实例对象。而且可以指定第二个参数来控制 useService 的解析过程。\n\nuseService 的作用非常类似@Inject。尤其是第二个参数，支持这些属性：\n\n * self 对应@Self\n * skip 对应@Skip\n * optional 对应@Optional\n * defaultValue 没有对应的装饰器函数，因为可以直接使用=来赋值默认值\n\n注意到 useService 非常优秀的一点就是返回值都是自带类型的，所以可以非常方便的使用.来知道这个类有哪些属性和方法。\n\n另外一点就是其返回值已经是 reactive 的，可以直接在 vue 模版中绑定。',normalizedContent:'# api文档\n\n\n# 简介\n\n当前一共有 8 个 api，具体如下：\n\n# 提供依赖注入能力\n\n这些 api 是从@kaokei/di中导出的，是用来定义服务的。而且还可以在类组件中使用（除了 injectable）。\n\n * inject\n * self\n * skip\n * optional\n * injectable\n\n# 类组件专用\n\n * component\n\n# option 组件专用\n\n因为在 option 组件中不能使用@inject 的方式来注入服务。只能手动调用 useservice 来获取服务实例。 同样在类组件中可以使用 component 来定义 providers，但是在 option 组件中不能使用装饰器。所以也提供了一个方法 declareproviders。\n\n * declareproviders\n * useservice\n\n\n# inject 装饰器函数\n\nimport { injectable } from "@kaokei/use-vue-service";\nimport { loggerservice } from "./logger.service.ts";\n\n@injectable()\nexport class countservice {\n  @inject(loggerservice)\n  private logger1: loggerservice,\n\n  constructor(\n    @inject(loggerservice) private logger2: loggerservice,\n  ) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n装饰器目前只能用在类上面，所以可以在类组件和类服务上使用。\n\n参考示例代码，可以看出来@inject装饰器可以在实例属性以及类的构造函数的参数上使用。\n\n@inject 的作用是在当前类实例化的时候，injector 会自动帮助我们注入相应的实例属性和构造函数参数。\n\n@inject 有一个必填的参数，作为需要注入的服务标识符。\n\n在实例属性上，@inject 是必须的。如果没有这个装饰器，那么就是一个普通的属性。\n\n在构造函数的参数上，如果参数类型是类，比如这里的 logger2 的类型是 loggerservice 是一个类。那么这里其实是可以不使用@inject 的。代码如下：\n\nconstructor(\n  private logger2: loggerservice,\n) {}\n\n\n1\n2\n3\n\n\n注意：最初的设计在实例属性上，如果属性的类型是一个类，@inject 的参数是可以省略的，因为装饰器是可以获取到正确的类型的。最终为了代码一致性，把这个特性去掉了，强制要求@inject 必须指定参数。总结起来就是只有构造函数中可以不使用@inject，但是如果使用@inejct 都必须指定参数。还有一点需要注意，实例属性和构造函数的参数的类型可以是interface，但是@inject 的参数不能是interface。\n\n\n# skip 装饰器函数\n\nimport { injectable, skip } from "@kaokei/use-vue-service";\nimport { loggerservice } from "./logger.service.ts";\n\n@injectable()\nexport class countservice {\n  @skip()\n  @inject(loggerservice)\n  private logger1: loggerservice,\n\n  constructor(\n    @skip()\n    @inject(loggerservice)\n    private logger2: loggerservice,\n  ) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n同样是属于装饰器函数，配合@inject 一起使用。\n\n@skip 主要是控制@inject 的行为，在没有@skip 时，@inject 会从当前的 injector 中获取对应的服务，如果找不到则会自动从其父级 injector 中寻找对应的服务，最终一直到根 injector 中寻找服务。那么@skip 的作用就是默认从当前的 injector 的父级 injector 开始寻找服务，即跳过当前 injector。\n\n这样的场景不是很多见，比如当前组件中有一个 student 服务，代表某个学生，显然我们可以直接@inject 获取一个 student 服务。假设其父组件中维护也维护着一个 student 服务，并且父组件中已经有一个服务实例代表该班级最优秀的学生。那么如果在当前的子组件中想要获取这个最优秀的学生就需要用到@skip 功能了。\n\n我知道有些同学的脑洞比较大，假设有一个更加复杂的场景，在班级最优秀的学生上面还有年级最优秀、学校最优秀、全市最优秀、全国最优秀、全球最优秀。。。那么如何在最底层的组件中获取以上服务实例呢？答案就是做不到。应该说只是借助@skip 是做不到这个功能的。具体方法可以参考这里。\n\n其实一开始我是有实现@skip(number)这个功能的，比如@skip(5)就是向上跳过 5 层。最终考虑到这样的场景毕竟不是很常见的场景，反而因为实现这个功能降低了整个代码的效率。所以最终是去掉了这个功能。\n\n@skip 有一个缺点，它可能不是从像你理解的那样跳过当前的 injector。参考这里\n\n\n# self 装饰器函数\n\nimport { injectable, self } from "@kaokei/use-vue-service";\nimport { loggerservice } from "./logger.service.ts";\n\n@injectable()\nexport class countservice {\n  @self()\n  @inject(loggerservice)\n  private logger1: loggerservice,\n\n  constructor(\n    @self()\n    @inject(loggerservice)\n    private logger2: loggerservice,\n  ) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n同样是属于装饰器函数，配合@inject 一起使用。\n\n根据函数名应该已经猜到其作用了。它控制了@inject 只会从当前所属的 injector 中获取服务实例。 咋一看似乎没什么实际用处。仔细一分析还真是没什么实际作用。\n\n因为是借鉴的 angular 的 api，所以就给实现了。\n\n我的理解它最大的作用应该是起到警告的作用。比如我只想从当前 injector 中获取 loggerservice，那么我必须要保证当前 injector 中已经配置了 loggerservice 的 provider。如果我们手动已经保证了这一点，那么有没有@self 是没有什么影响的。但是如果无意间我们删除了这个 provider，那么@self 就会报错找不到服务。如果没有@self 就有可能自动从更父级的 injector 中寻找到 loggerservice，使得程序没有抛出异常，但是这可能不是我们想要的业务逻辑。\n\n\n# optional 装饰器函数\n\nimport { injectable, optional, self, skip } from "@kaokei/use-vue-service";\nimport { loggerservice } from "./logger.service.ts";\n\n@injectable()\nexport class countservice {\n  @optional()\n  @inject(loggerservice)\n  private logger1: loggerservice,\n\n  @optional()\n  @self()\n  @inject(loggerservice)\n  private logger2: loggerservice,\n\n  @optional()\n  @skip()\n  @inject(loggerservice)\n  private logger3: loggerservice,\n\n  constructor(\n    @optional()\n    @inject(loggerservice)\n    private logger4: loggerservice,\n\n    @optional()\n    @self()\n    @inject(loggerservice)\n    private logger5: loggerservice,\n\n    @optional()\n    @skip()\n    @inject(loggerservice)\n    private logger6: loggerservice,\n  ) {}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n同样是属于装饰器函数，配合@inject 一起使用。\n\n之前我们有提到当 injector 找不到对应的服务的 provider 时，会抛出异常。如果认为某个属性可以是非必须的，就可以使用@optional，这时如果找不到 provider，就会返回undefined。\n\n注意：因为实例属性可能是 undefined，那么在调用实例属性的方法时就应该判空，像这样this.logger1?.log(\'hello world\');\n\n注意：默认情况下，如果服务的标识符是一个类，那么在找不到这个服务的 provider 时，就会直接实例化这个类当作服务实例。当然如果有@self 控制@inject 的话，就不会自动实例化类了。\n\n注意：上面提到的@self 控制@inject，所以就不会自动实例化类了。这在本库中是没有问题的。因为本库提供了一个默认的 injector 作为根 injector。实际上在@kaokei/di这个库中的实现要稍微复杂一些，当你手动实例时一个 injector，并且没有指定父级 injector 时，它自己就会作为根 injector，而根 injector 则又会自动实例化类了。具体代码可以参考这里。\n\n\n# injectable 装饰器函数\n\nimport { injectable } from "@kaokei/use-vue-service";\n\n@injectable()\nexport class loggerservice {\n  public log(...msg: any[]) {\n    console.log("from logger service ==>", ...msg);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ninjectable 这个 api 是最简单的 api，只需要在定义服务类的时候，作为类的装饰器使用即可。\n\ninjectable 内部的实现是非常简单的，只是利用了 reflect-metadata 库简单的记录了服务类的构造函数的参数的类型信息。以便在后续实例化服务类的时候需要使用这些类型信息。\n\n可以理解为在构造函数的参数如果是类的时候，就可以不使用@inject 的原因就在于@injectable 已经收集到这些类的信息了。\n\n注意：虽然对于没有构造函数的类可以不使用@injectable，但是为了保持一致性，还是尽量所有的服务类都使用@injectable。\n\n\n# component 装饰器函数\n\n@component({\n  providers: [\n    {\n      provide: counter_theme,\n      usevalue: "red",\n    },\n    counterservice,\n  ],\n})\nexport default class person extends vue.with(props) {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n从示例代码中可以看出，@component 作为类的装饰器，其参数是和vue-class-component@8.x中的@options 函数基本是一致的。\n\n只不过在@options 的基础上，@component 还增加了一个参数，就是 providers，其效果就是 declareproviders 函数的作用，用于声明当前组件关联的 injector 所需要的 providers。\n\n如果当前组件不需要 providers 参数，就可以这样写：\n\n@component()\nexport default class person extends vue.with(props) {\n  // ...\n}\n\n\n1\n2\n3\n4\n\n\n关于 component 这个 api 则是特意给类组件用的。它有三个作用：\n\n * 第一个作用是对 vue-class-component@8.x 中的@options的封装；\n * 第二个作用是通过参数 providers 实现了 declareproviders 函数的功能；\n * 第三个作用是实现了类组件具有依赖注入的能力。\n   * 当然这里的注入是有限制的，只能注入实例属性，而不能注入构造函数参数。\n   * 类组件只能注入别的服务，而不能把类组件当作服务注入。这点在 angular 中是被支持的，但是我觉得这个功能过于强大了，不符合数据驱动视图的原则。\n\n注意：vue-class-component在之前版本中都是使用的@component这个装饰器，只是在版本 8 中修改为@options了，正好本库可以捡个漏。\n\n\n# declareproviders 函数\n\n只能在 setup 函数中使用。\n\ndeclareproviders([\n  someservice,\n  {\n    provide: someservice,\n    useclass: someservice,\n  },\n  {\n    provide: someservice,\n    useclass: someotherservice,\n  },\n  {\n    provide: someservice,\n    usevalue: someserviceinstance,\n  },\n  {\n    provide: someservice,\n    useexisting: someotherservice,\n  },\n  {\n    provide: someservice,\n    usefactory: (dependservice1, dependservice2, dependservice3) => {\n      return someserviceinstance;\n    },\n    deps: [dependservice1, dependservice2, dependservice3],\n  },\n]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n可以一次性定义多个服务的 provider。以上列出了所有 provide 的形式。\n\n在解释其作用之前，我们必须了解 injector 是类似 dom 树一样的树状结构，每个 injector 都有一个父级 injector，直到根 injector 的父级为 null。\n\n当我们在组件的 setup 函数中调用了 declareproviders，就意味着这个组件关联了一个新的 injector，这个 injector 会根据我们刚才配置的 providers 来生成服务实例。\n\n想象一下，如果整个应用中所有的服务都是不同的，都是全局单例的。那么我们可能不需要使用declareproviders，把所有服务都放到根 injector 中即可。\n\n但是如果我们想要实现服务实例的生命周期和某个组件保持一致，最常见的场景就是路由组件。那么显然我们应该把服务定义在对应的路由组件中，而不是在根 injector 中。\n\n除了控制服务实例的生命周期，另一个功能就是可以实现同一个服务的多例效果。显而易见如果我们在不同的组件中调用declareproviders，并且配置了同一个服务。那么在获取服务实例时就能得到同一个服务的不同实例。\n\n注意：declareproviders在同一个 setup 中只能调用一次，而且应该在最顶部调用。\n\n\n# useservice 函数\n\n只能在 setup 函数中使用。\n\nconst someservice = useservice(someservice);\n\nconst [someservice1, someservice2, someservice3] = useservice([\n  someservice1,\n  someservice2,\n  someservice3,\n]);\n\nconst someservice = useservice(someservice, {\n  skip: true,\n  optional: true,\n  defaultvalue: "somwservice",\n});\n\nconst someservice = useservice(someservice, {\n  self: true,\n  optional: true,\n  defaultvalue: "somwservice",\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n我们可以一次获取单个服务的实例对象，也可以一次性获取多个服务的实例对象。而且可以指定第二个参数来控制 useservice 的解析过程。\n\nuseservice 的作用非常类似@inject。尤其是第二个参数，支持这些属性：\n\n * self 对应@self\n * skip 对应@skip\n * optional 对应@optional\n * defaultvalue 没有对应的装饰器函数，因为可以直接使用=来赋值默认值\n\n注意到 useservice 非常优秀的一点就是返回值都是自带类型的，所以可以非常方便的使用.来知道这个类有哪些属性和方法。\n\n另外一点就是其返回值已经是 reactive 的，可以直接在 vue 模版中绑定。',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"A记录与CNAME记录",frontmatter:{title:"A记录与CNAME记录",date:"2022-01-10T17:10:12.000Z",permalink:"/pages/51372a/",sidebar:"auto",categories:["随笔"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/A%E8%AE%B0%E5%BD%95%E4%B8%8ECNAME%E8%AE%B0%E5%BD%95.html",relativePath:"_posts/A记录与CNAME记录.md",key:"v-02ad9e44",path:"/pages/51372a/",headers:[{level:2,title:"为什么我不能 CNAME 到百度",slug:"为什么我不能-cname-到百度",normalizedTitle:"为什么我不能 cname 到百度",charIndex:182}],headersStr:"为什么我不能 CNAME 到百度",content:"# A 记录与 CNAME 记录\n\n不管是 A 记录，还是 CNAME 记录，都只是 DNS 解析域名到实际 IP 的一种方式。\n\n对于 A 记录就是简单的关联域名和 ip 地址。\n\n对于 CNAME 记录，则是关联域名 1 和域名 2。当访问域名 1 时，会通过域名 2 来解析实际 ip 地址。 注意这里的域名 2 也有可能是一个 CNAME 记录。\n\n\n# 为什么我不能 CNAME 到百度\n\n我已经有一个域名，然后期望把baidu.mydomain.comCNAME 到www.baidu.com这个域名。结果并不能正常访问。\n\n这是因为 CNAME 只是负责域名到 ip 的解析过程。我们确实可以通过以上配置把baidu.mydomain.com解析到百度服务器的某个 ip 上了。但是这个服务器肯定不会允许人任意域名访问的。\n\n有过 nginx 配置经验的，都知道 nginx 中有一个配置项是server_name，就是指定域名才能访问特定资源。\n\n因为我们的域名肯定不在 baidu 的 nginx 配置文件中，所以就会返回 403/404 了。\n\n对应的关于 vercel 和 github-page 也是同样的道理。 都需要做两件事，一件事是配置 dns 层的 CNAME 记录，另一件事就是配置域名白名单，其实就是把我们的域名加到对应的 nginx 配置文件中。",normalizedContent:"# a 记录与 cname 记录\n\n不管是 a 记录，还是 cname 记录，都只是 dns 解析域名到实际 ip 的一种方式。\n\n对于 a 记录就是简单的关联域名和 ip 地址。\n\n对于 cname 记录，则是关联域名 1 和域名 2。当访问域名 1 时，会通过域名 2 来解析实际 ip 地址。 注意这里的域名 2 也有可能是一个 cname 记录。\n\n\n# 为什么我不能 cname 到百度\n\n我已经有一个域名，然后期望把baidu.mydomain.comcname 到www.baidu.com这个域名。结果并不能正常访问。\n\n这是因为 cname 只是负责域名到 ip 的解析过程。我们确实可以通过以上配置把baidu.mydomain.com解析到百度服务器的某个 ip 上了。但是这个服务器肯定不会允许人任意域名访问的。\n\n有过 nginx 配置经验的，都知道 nginx 中有一个配置项是server_name，就是指定域名才能访问特定资源。\n\n因为我们的域名肯定不在 baidu 的 nginx 配置文件中，所以就会返回 403/404 了。\n\n对应的关于 vercel 和 github-page 也是同样的道理。 都需要做两件事，一件事是配置 dns 层的 cname 记录，另一件事就是配置域名白名单，其实就是把我们的域名加到对应的 nginx 配置文件中。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"Pure ESM",frontmatter:{title:"Pure ESM",date:"2022-01-10T18:09:19.000Z",permalink:"/pages/29b8e0/",sidebar:"auto",categories:["随笔"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/Pure%20ESM.html",relativePath:"_posts/Pure ESM.md",key:"v-1133a448",path:"/pages/29b8e0/",headers:[{level:2,title:"解决办法",slug:"解决办法",normalizedTitle:"解决办法",charIndex:70},{level:2,title:"有哪些纯 esm 包",slug:"有哪些纯-esm-包",normalizedTitle:"有哪些纯 esm 包",charIndex:302}],headersStr:"解决办法 有哪些纯 esm 包",content:"# Pure ESM\n\n纯 esm 的包越来越多了，但是很多框架还没有跟上脚步。就会导致这些包没有办法使用，是彻底的没有办法使用。\n\n\n# 解决办法\n\n参考这里\n\n总结就是要不就是把我们自己的项目改造成 esm 项目，要不就不要升级这个 npm 包，一直待在低版本，直到我们的项目支持 esm 包为止。\n\n如果我们的项目只是一个简单的项目，比如就是一个简单的 npm 工具。那么我们可以改造我们的项目。但是如果我们的项目是依赖框架的，但是这个框架目前还不支持纯 esm 包，那就没有办法了。\n\n比如 midwayjs 和 oclif 是我遇到的有问题的两个框架。当前时间 2022-01-10。\n\n\n# 有哪些纯 esm 包\n\nchalk\n\nexeca\n\np-limit\n\nyocto-queue\n\n我才发现原来这些包都来自于 sindresorhus，果然是大佬，就是任性。不想支持 cjs 就不支持 cjs。",normalizedContent:"# pure esm\n\n纯 esm 的包越来越多了，但是很多框架还没有跟上脚步。就会导致这些包没有办法使用，是彻底的没有办法使用。\n\n\n# 解决办法\n\n参考这里\n\n总结就是要不就是把我们自己的项目改造成 esm 项目，要不就不要升级这个 npm 包，一直待在低版本，直到我们的项目支持 esm 包为止。\n\n如果我们的项目只是一个简单的项目，比如就是一个简单的 npm 工具。那么我们可以改造我们的项目。但是如果我们的项目是依赖框架的，但是这个框架目前还不支持纯 esm 包，那就没有办法了。\n\n比如 midwayjs 和 oclif 是我遇到的有问题的两个框架。当前时间 2022-01-10。\n\n\n# 有哪些纯 esm 包\n\nchalk\n\nexeca\n\np-limit\n\nyocto-queue\n\n我才发现原来这些包都来自于 sindresorhus，果然是大佬，就是任性。不想支持 cjs 就不支持 cjs。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"关于",frontmatter:{title:"关于",date:"2022-02-17T20:35:16.000Z",permalink:"/about/",sidebar:!1,article:!1,showSidebar:!1},regularPath:"/_posts/about.html",relativePath:"_posts/about.md",key:"v-7bd86066",path:"/about/",headers:[{level:2,title:"📚Blog",slug:"📚blog",normalizedTitle:"📚blog",charIndex:2},{level:2,title:"✉️ 联系我",slug:"联系我",normalizedTitle:"✉️ 联系我",charIndex:376},{level:2,title:"☕️ 请我喝咖啡",slug:"请我喝咖啡",normalizedTitle:"☕️ 请我喝咖啡",charIndex:462}],headersStr:"📚Blog ✉️ 联系我 ☕️ 请我喝咖啡",content:"# 📚Blog\n\n曾经会在博客园和 csdn 这些网站上写博客，但总觉得写完的博客和我没有紧密的关系，觉得这些博客不属于我，而是属于平台，随时可能被删除，或者丢失图片。所以渐渐的不在这些地方写博客了。转而购买了为知笔记在本地写博客，但是一个人人偷偷的写博客，又缺乏读者的鼓励。\n\n所以最终采用了这种方式来写作博客，使用 vscode 编辑器和 markdown 语法来写作文档。使用 vuepress 和 vdoing 主题来构建博客网站。使用 github page 和 gitee page 来部署网站。\n\n这是一个兼具知识笔记、项目文档的个人网站，主要内容是 Web 前端技术。如果你喜欢这些内容欢迎到GitHub点个 Star，或者交换友链 ( •̀ ω •́ )✧\n\n提示\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n\n# ✉️ 联系我\n\n * Email: kao.kei.rst+blog@gmail.com\n * GitHub: https://github.com/kaokei\n\n\n# ☕️ 请我喝咖啡\n\n虽然不知道你为什么要请我喝咖啡，但是我仍然非常开心，感谢您的捐赠！❤️\n\n微信赞赏   微信   支付宝\n            \n\nIf you have not wechat pay and ali pay, you can also buy me a coffee on this site",normalizedContent:"# 📚blog\n\n曾经会在博客园和 csdn 这些网站上写博客，但总觉得写完的博客和我没有紧密的关系，觉得这些博客不属于我，而是属于平台，随时可能被删除，或者丢失图片。所以渐渐的不在这些地方写博客了。转而购买了为知笔记在本地写博客，但是一个人人偷偷的写博客，又缺乏读者的鼓励。\n\n所以最终采用了这种方式来写作博客，使用 vscode 编辑器和 markdown 语法来写作文档。使用 vuepress 和 vdoing 主题来构建博客网站。使用 github page 和 gitee page 来部署网站。\n\n这是一个兼具知识笔记、项目文档的个人网站，主要内容是 web 前端技术。如果你喜欢这些内容欢迎到github点个 star，或者交换友链 ( • ω • )✧\n\n提示\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n\n# ✉️ 联系我\n\n * email: kao.kei.rst+blog@gmail.com\n * github: https://github.com/kaokei\n\n\n# ☕️ 请我喝咖啡\n\n虽然不知道你为什么要请我喝咖啡，但是我仍然非常开心，感谢您的捐赠！❤️\n\n微信赞赏   微信   支付宝\n            \n\nif you have not wechat pay and ali pay, you can also buy me a coffee on this site",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"最佳实践指导",frontmatter:{author:"kaokei",title:"最佳实践指导",date:"2021-12-19T16:52:54.000Z",permalink:"/pages/c8faae/",sidebar:"auto",categories:["随笔","技术"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/best-practices.html",relativePath:"_posts/best-practices.md",key:"v-b67a6bf6",path:"/pages/c8faae/",headers:[{level:2,title:"最佳实践",slug:"最佳实践",normalizedTitle:"最佳实践",charIndex:2},{level:2,title:"@skip 只能跳过一层 Injector",slug:"skip-只能跳过一层-injector",normalizedTitle:"@skip 只能跳过一层 injector",charIndex:760},{level:2,title:"@Skip 和@Self 本身的缺陷",slug:"skip-和-self-本身的缺陷",normalizedTitle:"@skip 和@self 本身的缺陷",charIndex:1361},{level:2,title:"@kaokei/di 支持默认值",slug:"kaokei-di-支持默认值",normalizedTitle:"@kaokei/di 支持默认值",charIndex:2053},{level:2,title:"useExisting vs useClass",slug:"useexisting-vs-useclass",normalizedTitle:"useexisting vs useclass",charIndex:2191},{level:2,title:"使用 InjectionKey 保留类型信息",slug:"使用-injectionkey-保留类型信息",normalizedTitle:"使用 injectionkey 保留类型信息",charIndex:2450},{level:2,title:"根组件和根 Injector 的关系",slug:"根组件和根-injector-的关系",normalizedTitle:"根组件和根 injector 的关系",charIndex:2864},{level:2,title:"禁止使用 watch",slug:"禁止使用-watch",normalizedTitle:"禁止使用 watch",charIndex:3230}],headersStr:"最佳实践 @skip 只能跳过一层 Injector @Skip 和@Self 本身的缺陷 @kaokei/di 支持默认值 useExisting vs useClass 使用 InjectionKey 保留类型信息 根组件和根 Injector 的关系 禁止使用 watch",content:"# 最佳实践\n\ndeclareProviders 一定要在 setup 的顶部使用。如果先调用了 useService，然后再调用 declareProviders，就会导致获取的服务可能不是我们期望的。\n\n虽然基于服务的依赖注入用起来很方便，但是也不应该滥用，还是需要考虑使用场景。我建议在容器组件中使用服务是比较适合的。但是在受控组件中还是推荐使用 props/emit 的方式进行交互。\n\n建议自己基于 axios/superagent 封装自己的 HttpClientService 然后基于 HttpClientService 封装自己的 DaoService 我个人建议是一个项目只需要一个 DaoService，并不需要按照模块划分成多个。当然你也可以按照领域划分成不同的 DaoService，只是我认为过于繁琐了。 我理解一个项目大多数情况下很难超过 200 条接口。维护在一个服务中是可以接受的。 再然后 StudentService，TeacherService，ClassService 这些业务 Service 直接注入 DaoService 即可。\n\n数据的生命周期应该和组件的生命周期一致，当组件销毁时，数据也应该跟着销毁。 子组件的生命周期应该受到父组件的生命周期的约束。当父组件销毁时，子组件也要跟着销毁。 如果子组件的销毁完全只受父组件控制，那么可以把所有数据都放在父组件中即可。因为这样也可以保证父子组件和数据的生命周期是一致的。 如果子组件也会绑定到子路由，则相应的数据也可以绑定到该子组件。还是在保证子组件的数据和子组件的生命周期一致。 目前来看，数据默认会绑定到全局。其他情况数据应该绑定到路由组件，以及子路由组件上。\n\n不建议通过 props 传递 service\n\n\n# @skip 只能跳过一层 Injector\n\n目前我们只实现了@Skip 向上跳过一层 Injector。\n\n其实一开始我是打算实现@Skip(number)来指定向上跳过若干层。后来发现实现这个功能增加很多的复杂度，又考虑到这个功能的使用场景不是很多，所以给废弃了。\n\n那么如果确实需要跳过多层来获取服务呢？应该怎么实现呢？\n\n其实可以借助 useClass 来实现，比如现在有一个服务是 UserService。那么我们可以在各个组件中这样定义 provider。\n\n//爷爷组件中\n{\n  provide: 'aUserService',\n  useClass: UserService\n}\n// 父亲组件中\n{\n  provide: 'bUserService',\n  useClass: UserService\n}\n// 儿子组件中\n{\n  provide: 'cUserService',\n  useClass: UserService\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n那么我们在最底层组件中随时可以获取任意的服务，因为他们的 provide 都不一样。比如这样：\n\n// 孙子组件中可以直接获取到爷爷组件中的服务。\nconst aUserService = useService('aUserService');\n\n\n1\n2\n\n\n\n# @Skip 和@Self 本身的缺陷\n\n这个问题解释起来还比较复杂，主要是涉及到 provide/inject 的实现机制。也就是 vue 中 context 是如何工作的。最好是自己看源码，这里稍微解释一下。\n\n每个组件实例上都有一个属性是provides，这个对象默认是指向父组件的provides属性，根组件的provides属性是 null。\n\n当在某个组件中调用 provide 方法时，则会把其父组件的provides属性当作原型创建一个空对象Object.create(parent.provides);，然后给这个空对象设置刚才调用 provide 方法的数据。\n\n按照这个逻辑，其实整个 provides 对象是构成一条完整的原型链的。但是问题就在于，如果一个子组件中没有调用 provide 方法，那么其provides属性是直接等于父组件的provides属性的。\n\n翻译一下上面的话的含义就是，如果在父组件中调用了declareProviders()，但是子组件中没有调用这个方法，那么在子组件中通过useService获取服务时，是直接从父组件所关联的 Injector 开始查找服务的。这样就导致@Skip和@Self和我们正常理解的意思稍微有一些偏差。\n\n这里确实需要人为的注意一下，当你使用@Skip 和@Self 时，当前组件一定是调用了declareProviders()的，否则除非你明确的知道你在做什么。\n\n注意：declareProviders 是依赖 provide 实现的，useService 是依赖 inject 来实现的。\n\n\n# @kaokei/di 支持默认值\n\n依赖注入框架并没有单独实现一个@DefaultValue 这样的装饰器，因为可以直接使用赋值语句来设置默认值。\n\n但是需要注意默认值只有在设置@Optional 装饰器，并且确实没有找到该服务时才会生效，其余情况下是不会起作用的。\n\n\n# useExisting vs useClass\n\n参考 Angular 的文档，可以更好的了解他两的区别。\n\n解释 useExisting 和 useClass 的区别。\n\n使用 useClass，只要 provide 的名字不一样，就算 useClass 指向的服务相同。那么也算是不同的服务，最终相当于得到了同一个服务的多个实例。\n\nuseExisting 则是刚好相反，即使 provide 不相同，但是只要 useExisting 指向的服务是存在的，则立即返回这个服务实例。并不会创建一个新的实例。\n\n\n# 使用 InjectionKey 保留类型信息\n\n参考 Angular 的文档\n\n只不过语法稍微有些区别。\n\nimport { InjectionKey } from \"@kaokei/use-vue-service\";\ntype SomeServiceKey = InjectionKey<SomeService>;\nconst someServiceKey: SomeServiceKey = symbol();\n\n// someService的类型就是SomeService\n// 这就是InjectionKey所起到的作用\n// 如果SomeService是一个类的话，其实是没有必要这样做的\n// 但是如果SomeService是一个接口的话，则只能这样做才能保留类型信息\nconst someService = useService(someServiceKey);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 根组件和根 Injector 的关系\n\n前面的文章中一直有说到根组件和根 Injector 是绑定的，实际上这么描述是不够准确的。\n\n本库自带了一个全局唯一的根 Injector，如果整个应用只有一个根组件，可以理解为根组件和根 Injector 是绑定的。\n\n但是整个应用是可能有多个根组件的，在 vue 中，我们可以多次调用 createApp 来创建多个根组件。每个根组件都是独立的。这样就导致根 Injector 还是处在最顶层。我们可以手动调用\n\napp1.use(本库);\napp2.use(本库);\n\n\n1\n2\n\n\n上面的代码的作用是手动给每个根组件绑定一个 Injector。这样就能做到某些服务只给某个 app 使用。\n\n实际上我到现在都没有遇到过一个应用中有多个根组件的场景。所以也不用太关心这个问题。\n\n\n# 禁止使用 watch\n\nwatch 有两个优势。\n\n第一，watch 某个属性，属性变化时更新 10 个属性。如果通过 computed 来实现的话，就需要重复 10 遍代码。\n\n第二，watch 某个属性，属性变化时执行某些副作用，比如请求某个 api、输出日志等。这种功能显然是不能通过 computed 来实现的。\n\n既然如此，为什么还是不建议使用 watch 呢？\n\n因为第一点出现的场景不会特别夸张，就算有 2，3 个属性共同依赖某个属性，那也是建议都写成 computed，而不是把更新逻辑放在 watch 中。\n\n第二点我建议是在触发事件的地方去手动调用更新逻辑，而不是依赖数据驱动副作用。\n\n总结以上两点的本质原因在于，我们可以利用数据驱动模版更新，但是我们不应该利用数据驱动其他副作用。\n\n这涉及到心智模型的问题，我期望的心智模型是数据驱动模版，模版响应事件，在事件中修改数据，数据反过来又驱动模版更新。\n\n这中间最多可以接受 computed 对数据层做一层聚合，但是仍然可以看作是数据层的一部分。\n\n但是如果引入了 watch 就不一样了。因为它破坏了这个简单的心智模型。\n\n第一点、数据变化了不仅仅会驱动模版更新，还会触发 watch 中定义的副作用，谁也不知道这个副作用最终又是怎么影响数据和模版的。\n\n第二点、原本的逻辑是模版响应事件，我们直接在事件中更新数据，数据再反应到模版上。但是引入 watch 之后，我们可能会写出这样的代码：我们在事件中只会更新某个数据，然后在 watch 中观察这个数据，然后执行相应的副作用，最终修改了我们想要的数据，数据驱动模版更新。\n\n很明显我们发现心智模型不一样了，变得更加复杂了。",normalizedContent:"# 最佳实践\n\ndeclareproviders 一定要在 setup 的顶部使用。如果先调用了 useservice，然后再调用 declareproviders，就会导致获取的服务可能不是我们期望的。\n\n虽然基于服务的依赖注入用起来很方便，但是也不应该滥用，还是需要考虑使用场景。我建议在容器组件中使用服务是比较适合的。但是在受控组件中还是推荐使用 props/emit 的方式进行交互。\n\n建议自己基于 axios/superagent 封装自己的 httpclientservice 然后基于 httpclientservice 封装自己的 daoservice 我个人建议是一个项目只需要一个 daoservice，并不需要按照模块划分成多个。当然你也可以按照领域划分成不同的 daoservice，只是我认为过于繁琐了。 我理解一个项目大多数情况下很难超过 200 条接口。维护在一个服务中是可以接受的。 再然后 studentservice，teacherservice，classservice 这些业务 service 直接注入 daoservice 即可。\n\n数据的生命周期应该和组件的生命周期一致，当组件销毁时，数据也应该跟着销毁。 子组件的生命周期应该受到父组件的生命周期的约束。当父组件销毁时，子组件也要跟着销毁。 如果子组件的销毁完全只受父组件控制，那么可以把所有数据都放在父组件中即可。因为这样也可以保证父子组件和数据的生命周期是一致的。 如果子组件也会绑定到子路由，则相应的数据也可以绑定到该子组件。还是在保证子组件的数据和子组件的生命周期一致。 目前来看，数据默认会绑定到全局。其他情况数据应该绑定到路由组件，以及子路由组件上。\n\n不建议通过 props 传递 service\n\n\n# @skip 只能跳过一层 injector\n\n目前我们只实现了@skip 向上跳过一层 injector。\n\n其实一开始我是打算实现@skip(number)来指定向上跳过若干层。后来发现实现这个功能增加很多的复杂度，又考虑到这个功能的使用场景不是很多，所以给废弃了。\n\n那么如果确实需要跳过多层来获取服务呢？应该怎么实现呢？\n\n其实可以借助 useclass 来实现，比如现在有一个服务是 userservice。那么我们可以在各个组件中这样定义 provider。\n\n//爷爷组件中\n{\n  provide: 'auserservice',\n  useclass: userservice\n}\n// 父亲组件中\n{\n  provide: 'buserservice',\n  useclass: userservice\n}\n// 儿子组件中\n{\n  provide: 'cuserservice',\n  useclass: userservice\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n那么我们在最底层组件中随时可以获取任意的服务，因为他们的 provide 都不一样。比如这样：\n\n// 孙子组件中可以直接获取到爷爷组件中的服务。\nconst auserservice = useservice('auserservice');\n\n\n1\n2\n\n\n\n# @skip 和@self 本身的缺陷\n\n这个问题解释起来还比较复杂，主要是涉及到 provide/inject 的实现机制。也就是 vue 中 context 是如何工作的。最好是自己看源码，这里稍微解释一下。\n\n每个组件实例上都有一个属性是provides，这个对象默认是指向父组件的provides属性，根组件的provides属性是 null。\n\n当在某个组件中调用 provide 方法时，则会把其父组件的provides属性当作原型创建一个空对象object.create(parent.provides);，然后给这个空对象设置刚才调用 provide 方法的数据。\n\n按照这个逻辑，其实整个 provides 对象是构成一条完整的原型链的。但是问题就在于，如果一个子组件中没有调用 provide 方法，那么其provides属性是直接等于父组件的provides属性的。\n\n翻译一下上面的话的含义就是，如果在父组件中调用了declareproviders()，但是子组件中没有调用这个方法，那么在子组件中通过useservice获取服务时，是直接从父组件所关联的 injector 开始查找服务的。这样就导致@skip和@self和我们正常理解的意思稍微有一些偏差。\n\n这里确实需要人为的注意一下，当你使用@skip 和@self 时，当前组件一定是调用了declareproviders()的，否则除非你明确的知道你在做什么。\n\n注意：declareproviders 是依赖 provide 实现的，useservice 是依赖 inject 来实现的。\n\n\n# @kaokei/di 支持默认值\n\n依赖注入框架并没有单独实现一个@defaultvalue 这样的装饰器，因为可以直接使用赋值语句来设置默认值。\n\n但是需要注意默认值只有在设置@optional 装饰器，并且确实没有找到该服务时才会生效，其余情况下是不会起作用的。\n\n\n# useexisting vs useclass\n\n参考 angular 的文档，可以更好的了解他两的区别。\n\n解释 useexisting 和 useclass 的区别。\n\n使用 useclass，只要 provide 的名字不一样，就算 useclass 指向的服务相同。那么也算是不同的服务，最终相当于得到了同一个服务的多个实例。\n\nuseexisting 则是刚好相反，即使 provide 不相同，但是只要 useexisting 指向的服务是存在的，则立即返回这个服务实例。并不会创建一个新的实例。\n\n\n# 使用 injectionkey 保留类型信息\n\n参考 angular 的文档\n\n只不过语法稍微有些区别。\n\nimport { injectionkey } from \"@kaokei/use-vue-service\";\ntype someservicekey = injectionkey<someservice>;\nconst someservicekey: someservicekey = symbol();\n\n// someservice的类型就是someservice\n// 这就是injectionkey所起到的作用\n// 如果someservice是一个类的话，其实是没有必要这样做的\n// 但是如果someservice是一个接口的话，则只能这样做才能保留类型信息\nconst someservice = useservice(someservicekey);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 根组件和根 injector 的关系\n\n前面的文章中一直有说到根组件和根 injector 是绑定的，实际上这么描述是不够准确的。\n\n本库自带了一个全局唯一的根 injector，如果整个应用只有一个根组件，可以理解为根组件和根 injector 是绑定的。\n\n但是整个应用是可能有多个根组件的，在 vue 中，我们可以多次调用 createapp 来创建多个根组件。每个根组件都是独立的。这样就导致根 injector 还是处在最顶层。我们可以手动调用\n\napp1.use(本库);\napp2.use(本库);\n\n\n1\n2\n\n\n上面的代码的作用是手动给每个根组件绑定一个 injector。这样就能做到某些服务只给某个 app 使用。\n\n实际上我到现在都没有遇到过一个应用中有多个根组件的场景。所以也不用太关心这个问题。\n\n\n# 禁止使用 watch\n\nwatch 有两个优势。\n\n第一，watch 某个属性，属性变化时更新 10 个属性。如果通过 computed 来实现的话，就需要重复 10 遍代码。\n\n第二，watch 某个属性，属性变化时执行某些副作用，比如请求某个 api、输出日志等。这种功能显然是不能通过 computed 来实现的。\n\n既然如此，为什么还是不建议使用 watch 呢？\n\n因为第一点出现的场景不会特别夸张，就算有 2，3 个属性共同依赖某个属性，那也是建议都写成 computed，而不是把更新逻辑放在 watch 中。\n\n第二点我建议是在触发事件的地方去手动调用更新逻辑，而不是依赖数据驱动副作用。\n\n总结以上两点的本质原因在于，我们可以利用数据驱动模版更新，但是我们不应该利用数据驱动其他副作用。\n\n这涉及到心智模型的问题，我期望的心智模型是数据驱动模版，模版响应事件，在事件中修改数据，数据反过来又驱动模版更新。\n\n这中间最多可以接受 computed 对数据层做一层聚合，但是仍然可以看作是数据层的一部分。\n\n但是如果引入了 watch 就不一样了。因为它破坏了这个简单的心智模型。\n\n第一点、数据变化了不仅仅会驱动模版更新，还会触发 watch 中定义的副作用，谁也不知道这个副作用最终又是怎么影响数据和模版的。\n\n第二点、原本的逻辑是模版响应事件，我们直接在事件中更新数据，数据再反应到模版上。但是引入 watch 之后，我们可能会写出这样的代码：我们在事件中只会更新某个数据，然后在 watch 中观察这个数据，然后执行相应的副作用，最终修改了我们想要的数据，数据驱动模版更新。\n\n很明显我们发现心智模型不一样了，变得更加复杂了。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"circular_dependency",frontmatter:{title:"circular_dependency",date:"2021-12-19T18:08:57.000Z",permalink:"/pages/46748c/",sidebar:"auto",categories:["随笔","技术"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/circular_dependency.html",relativePath:"_posts/circular_dependency.md",key:"v-21153691",path:"/pages/46748c/",headers:[{level:3,title:"循环依赖",slug:"循环依赖",normalizedTitle:"循环依赖",charIndex:2},{level:3,title:"对循环依赖的态度",slug:"对循环依赖的态度",normalizedTitle:"对循环依赖的态度",charIndex:591},{level:3,title:"关于循环依赖的讨论",slug:"关于循环依赖的讨论",normalizedTitle:"关于循环依赖的讨论",charIndex:740},{level:3,title:"大佬怎么解决循环依赖的",slug:"大佬怎么解决循环依赖的",normalizedTitle:"大佬怎么解决循环依赖的",charIndex:977}],headersStr:"循环依赖 对循环依赖的态度 关于循环依赖的讨论 大佬怎么解决循环依赖的",content:"# 循环依赖\n\n一般来讲循环依赖在不同的场景下有不同的含义。\n\n举个例子：\n\n小明眼睛看不见，小王腿走不了路。所以小明要看书时就需要小王来帮忙。小王要走路的时候就需要小明来帮忙。\n\n这个例子中，可以很明显的看出来小明和小王之间是存在互相依赖的。但是这种互相依赖具体是不是循环依赖取决于具体的场景。\n\n考虑这样的场景，就是循环依赖了。小明要看书，请求小王帮忙读书，小王说读书可以是可以，但是我一直坐在椅子上，没有力气读书，你背我走一走吧，小明说你先帮我读书，我再被你走路，小王说你先背我走路，我再帮你读书。\n\n像这种同一时刻，两种资源同时互相依赖即可称为循环依赖。\n\n再回归到 es6 中，在 es6 的模块定义的时候，一般“较少”有循环依赖的场景。但是互相依赖的场景则是非常常见的。\n\n比如调用 A 模块中的 a 方法时，会调用 B 模块中的 b 方法。就算 b 方法再次调用 a 方法，只要这种循环调用会中止即可，这也只是互相依赖，而不是循环依赖。\n\n上面说到的“较少”有循环依赖的场景。常见场景有这两个：\n\n场景一：A extends B 同时 B extends A，即 extends 关键字会导致循环依赖。 场景二：@decorator(A) class B {} 同时 @decorator(B) class A {}。装饰器也是立即执行的，也会导致循环依赖。\n\n\n# 对循环依赖的态度\n\n业务中应该尽量避免循环依赖，如果实在避免不了，那么就需要仔细分析各个模块之间的依赖关系。需要手动解耦各个模块。使之变为互相依赖。\n\n目前的 es6/babel/typescript 都不能直接帮我们解决这种循环依赖，但是应该有相应的提示信息辅助我们发现潜在的循环依赖。\n\n\n# 关于循环依赖的讨论\n\n看了半天，总结起来就是问题是客观存在的，只能具体问题具体分析。并不存在一劳永逸的方案。\n\nHow to solve this basic ES6-module circular dependency problem?\n\nTypeScript needs to support circular references between classes in separate files.\n\nAngular 2 Forward Reference\n\n\n# 大佬怎么解决循环依赖的\n\n我没能复现这种解决方案，感觉并不能解决问题\n\nHow to fix nasty circular dependency issues once and for all in JavaScript & TypeScript\n\nHow to fix this ES6 module circular dependency?\n\nKnown Limitation: Classes as identifiers and circular dependencies\n\nInversifyJS Circular dependencies",normalizedContent:"# 循环依赖\n\n一般来讲循环依赖在不同的场景下有不同的含义。\n\n举个例子：\n\n小明眼睛看不见，小王腿走不了路。所以小明要看书时就需要小王来帮忙。小王要走路的时候就需要小明来帮忙。\n\n这个例子中，可以很明显的看出来小明和小王之间是存在互相依赖的。但是这种互相依赖具体是不是循环依赖取决于具体的场景。\n\n考虑这样的场景，就是循环依赖了。小明要看书，请求小王帮忙读书，小王说读书可以是可以，但是我一直坐在椅子上，没有力气读书，你背我走一走吧，小明说你先帮我读书，我再被你走路，小王说你先背我走路，我再帮你读书。\n\n像这种同一时刻，两种资源同时互相依赖即可称为循环依赖。\n\n再回归到 es6 中，在 es6 的模块定义的时候，一般“较少”有循环依赖的场景。但是互相依赖的场景则是非常常见的。\n\n比如调用 a 模块中的 a 方法时，会调用 b 模块中的 b 方法。就算 b 方法再次调用 a 方法，只要这种循环调用会中止即可，这也只是互相依赖，而不是循环依赖。\n\n上面说到的“较少”有循环依赖的场景。常见场景有这两个：\n\n场景一：a extends b 同时 b extends a，即 extends 关键字会导致循环依赖。 场景二：@decorator(a) class b {} 同时 @decorator(b) class a {}。装饰器也是立即执行的，也会导致循环依赖。\n\n\n# 对循环依赖的态度\n\n业务中应该尽量避免循环依赖，如果实在避免不了，那么就需要仔细分析各个模块之间的依赖关系。需要手动解耦各个模块。使之变为互相依赖。\n\n目前的 es6/babel/typescript 都不能直接帮我们解决这种循环依赖，但是应该有相应的提示信息辅助我们发现潜在的循环依赖。\n\n\n# 关于循环依赖的讨论\n\n看了半天，总结起来就是问题是客观存在的，只能具体问题具体分析。并不存在一劳永逸的方案。\n\nhow to solve this basic es6-module circular dependency problem?\n\ntypescript needs to support circular references between classes in separate files.\n\nangular 2 forward reference\n\n\n# 大佬怎么解决循环依赖的\n\n我没能复现这种解决方案，感觉并不能解决问题\n\nhow to fix nasty circular dependency issues once and for all in javascript & typescript\n\nhow to fix this es6 module circular dependency?\n\nknown limitation: classes as identifiers and circular dependencies\n\ninversifyjs circular dependencies",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"组件间通信方式",frontmatter:{author:"kaokei",title:"组件间通信方式",date:"2021-12-19T16:52:54.000Z",permalink:"/pages/45cf91/",sidebar:"auto",categories:["随笔","技术"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/communication-between-components.html",relativePath:"_posts/communication-between-components.md",key:"v-f4fd4036",path:"/pages/45cf91/",headers:[{level:2,title:"父子组件",slug:"父子组件",normalizedTitle:"父子组件",charIndex:14},{level:2,title:"爷孙组件",slug:"爷孙组件",normalizedTitle:"爷孙组件",charIndex:238},{level:2,title:"兄弟组件",slug:"兄弟组件",normalizedTitle:"兄弟组件",charIndex:380},{level:2,title:"事件总线",slug:"事件总线",normalizedTitle:"事件总线",charIndex:597},{level:2,title:"redux or vuex",slug:"redux-or-vuex",normalizedTitle:"redux or vuex",charIndex:816},{level:2,title:"本库的实现方式",slug:"本库的实现方式",normalizedTitle:"本库的实现方式",charIndex:1066}],headersStr:"父子组件 爷孙组件 兄弟组件 事件总线 redux or vuex 本库的实现方式",content:"# 组件间通信方式\n\n\n# 父子组件\n\n父组件通过 props 传递数据给子组件 父组件监听子组件 emit 出来的事件，接受子组件的数据\n\n注意点一 父组件不仅仅可以传递数据给子组件，也可以传递函数给子组件，然后在子组件中调用该函数，从而修改父组件中的数据。这种方式也是可以的，而且这也是 react 中的常规操作。\n\n注意点二 子组件 emit 事件，如果是自定义事件，那么只会传递给父组件。父组件的父组件是接受不到该事件的。但是如果是原生事件，那么就能接收到。\n\n\n# 爷孙组件\n\n注意这里的爷孙并不是特指爷爷和孙子，而是指那些组件层级大于等于 2 层的组件。\n\n对于这种组件关系，我们仍然可以通过 props 一层层地去传递数据到最底层组件，也可以通过一层层的 emit 事件传递到最顶层组件。\n\n但是这显然加大了工作量，而且不利于代码维护。\n\n\n# 兄弟组件\n\n通常需要考虑把兄弟组件都需要的数据提升到最近的公共父组件中，这样每个兄弟组件都只需要和父组件进行沟通即可，即通过 props 和 emit 来转化为爷孙组件/父子组件的通信方式。这样只要父组件中的数据变化了，那么两个兄弟组件都会得到更新。\n\n还有一种场景，就是 A 组件 emit 事件到父组件中，父组件监听该事件，然后通过 ref 直接调用 B 组件中的方法。反过来也可以实现 B 组件触发 A 组件中的方法。\n\n\n# 事件总线\n\n还有一种方式则是通过公共事件总线来传递消息。const bus = new Vue(); 在任意组件中可以\n\nbus.$on('eventName', eventHandler);\nbus.$emit('eventName');\n\n\n1\n2\n\n\n这是一种功能非常强大的手段，可以做到整个页面中任意组件之间的通信，但是同时也是非常糟糕的一种设计。因为我们只能通过全局搜索才能找到哪些组件会触发事件，哪些组件会接受事件。\n\n\n# redux or vuex\n\nredux 和 vuex 都是全局唯一数据源。然后通过 dispatch 一个字符串来更新数据。\n\n和事件总线一样，通过字符串来触发更新逻辑对于开发来说是非常效率低下的。\n\n但是相对于事件总线来说要友好一些，主要是因为 dispatch 之后的逻辑非常明确，就是修改 store 中的数据。至于有哪些组件依赖了 store 中的数据则不是我们需要关心的。但是事件总线方案中，我们是需要时刻关心有哪些组件中订阅了某个事件的，至少需要保证事件不重名，否则就乱套了。\n\n\n# 本库的实现方式\n\n考虑 props 和 emit 的本质其实是把数据和方法分割开了。那么本库的实现方式正好与此相反。\n\n我们把数据和方法集合到一起变成一个对象，我们称之为服务。然后通过 provide/inject 的技术，可以方便的在任意组件中获取这个服务。只要我们获取到这个对象，我们可以在模版中渲染这个对象的数据，我们可以直接调用这个对象的方法。\n\n因为这个对象本身就是 reactive 的，所以只要数据变化了，所有依赖这个服务的组件都会自动更新。\n\n由于是通过 provide/inject 来获取的服务，所以是可以跨越多个组件层级直接获取服务对象的。\n\n因为服务对象是一个类的实例，所以数据类型是非常明确的，避免了上述字符串丢失类型的问题。\n\n我们还可以控制 provide 的位置，去控制服务对象的范围。因为服务是和组件关联的，当组件销毁的时候，服务也会跟着销毁，间接控制了服务的生命周期。\n\n虽然本库功能很强大，但是不意味着在整个项目中全部使用它，实际上本库还是比较适合那些容器组件。而对于那些受控组件则还是建议使用 props/emit 技术。",normalizedContent:"# 组件间通信方式\n\n\n# 父子组件\n\n父组件通过 props 传递数据给子组件 父组件监听子组件 emit 出来的事件，接受子组件的数据\n\n注意点一 父组件不仅仅可以传递数据给子组件，也可以传递函数给子组件，然后在子组件中调用该函数，从而修改父组件中的数据。这种方式也是可以的，而且这也是 react 中的常规操作。\n\n注意点二 子组件 emit 事件，如果是自定义事件，那么只会传递给父组件。父组件的父组件是接受不到该事件的。但是如果是原生事件，那么就能接收到。\n\n\n# 爷孙组件\n\n注意这里的爷孙并不是特指爷爷和孙子，而是指那些组件层级大于等于 2 层的组件。\n\n对于这种组件关系，我们仍然可以通过 props 一层层地去传递数据到最底层组件，也可以通过一层层的 emit 事件传递到最顶层组件。\n\n但是这显然加大了工作量，而且不利于代码维护。\n\n\n# 兄弟组件\n\n通常需要考虑把兄弟组件都需要的数据提升到最近的公共父组件中，这样每个兄弟组件都只需要和父组件进行沟通即可，即通过 props 和 emit 来转化为爷孙组件/父子组件的通信方式。这样只要父组件中的数据变化了，那么两个兄弟组件都会得到更新。\n\n还有一种场景，就是 a 组件 emit 事件到父组件中，父组件监听该事件，然后通过 ref 直接调用 b 组件中的方法。反过来也可以实现 b 组件触发 a 组件中的方法。\n\n\n# 事件总线\n\n还有一种方式则是通过公共事件总线来传递消息。const bus = new vue(); 在任意组件中可以\n\nbus.$on('eventname', eventhandler);\nbus.$emit('eventname');\n\n\n1\n2\n\n\n这是一种功能非常强大的手段，可以做到整个页面中任意组件之间的通信，但是同时也是非常糟糕的一种设计。因为我们只能通过全局搜索才能找到哪些组件会触发事件，哪些组件会接受事件。\n\n\n# redux or vuex\n\nredux 和 vuex 都是全局唯一数据源。然后通过 dispatch 一个字符串来更新数据。\n\n和事件总线一样，通过字符串来触发更新逻辑对于开发来说是非常效率低下的。\n\n但是相对于事件总线来说要友好一些，主要是因为 dispatch 之后的逻辑非常明确，就是修改 store 中的数据。至于有哪些组件依赖了 store 中的数据则不是我们需要关心的。但是事件总线方案中，我们是需要时刻关心有哪些组件中订阅了某个事件的，至少需要保证事件不重名，否则就乱套了。\n\n\n# 本库的实现方式\n\n考虑 props 和 emit 的本质其实是把数据和方法分割开了。那么本库的实现方式正好与此相反。\n\n我们把数据和方法集合到一起变成一个对象，我们称之为服务。然后通过 provide/inject 的技术，可以方便的在任意组件中获取这个服务。只要我们获取到这个对象，我们可以在模版中渲染这个对象的数据，我们可以直接调用这个对象的方法。\n\n因为这个对象本身就是 reactive 的，所以只要数据变化了，所有依赖这个服务的组件都会自动更新。\n\n由于是通过 provide/inject 来获取的服务，所以是可以跨越多个组件层级直接获取服务对象的。\n\n因为服务对象是一个类的实例，所以数据类型是非常明确的，避免了上述字符串丢失类型的问题。\n\n我们还可以控制 provide 的位置，去控制服务对象的范围。因为服务是和组件关联的，当组件销毁的时候，服务也会跟着销毁，间接控制了服务的生命周期。\n\n虽然本库功能很强大，但是不意味着在整个项目中全部使用它，实际上本库还是比较适合那些容器组件。而对于那些受控组件则还是建议使用 props/emit 技术。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"组件与服务",frontmatter:{author:"kaokei",title:"组件与服务",date:"2021-12-19T16:52:54.000Z",permalink:"/pages/747704/",sidebar:"auto",categories:["随笔","技术"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/component-and-service.html",relativePath:"_posts/component-and-service.md",key:"v-d814e4ee",path:"/pages/747704/",headers:[{level:2,title:"option 组件，类组件和服务的关系",slug:"option-组件-类组件和服务的关系",normalizedTitle:"option 组件，类组件和服务的关系",charIndex:2},{level:2,title:"为什么使用类来作为服务",slug:"为什么使用类来作为服务",normalizedTitle:"为什么使用类来作为服务",charIndex:426},{level:2,title:"类组件是如何收集数据的",slug:"类组件是如何收集数据的",normalizedTitle:"类组件是如何收集数据的",charIndex:575},{level:2,title:"如何在类组件中使用 setup",slug:"如何在类组件中使用-setup",normalizedTitle:"如何在类组件中使用 setup",charIndex:1551},{level:2,title:"如何使用 declareProviders",slug:"如何使用-declareproviders",normalizedTitle:"如何使用 declareproviders",charIndex:2604}],headersStr:"option 组件，类组件和服务的关系 为什么使用类来作为服务 类组件是如何收集数据的 如何在类组件中使用 setup 如何使用 declareProviders",content:"# option 组件，类组件和服务的关系\n\noption 组件本身就是一个对象，这个对象预定义了一套属性，比如 data、methods、components 等。\n\n类组件看起来像是一个类，只不过是把一部分 option 组件中的属性定义为类的成员属性。另一部分不支持的属性还是需要借助vue-class-component这个库来支持。比如 watch 属性，只能定义在@Options这个装饰器中。总之看上去会有点不伦不类。 通过深入分析vue-class-component这个库，可以发现最终这个类还是被转化成 option 组件了，所以从性能上来看也并不推荐使用类组件。 当然类组件也是有优势的，比如在 angular 中，组件只能是类，大多数服务也是类，而且都可以使用依赖注入，整体上来看是比较一致的。\n\n服务可以是任意数据或者任意方法或者数据和方法的集合。在依赖注入框架中，大多数服务被定义成类，因为类对依赖注入是最友好的。\n\n\n# 为什么使用类来作为服务\n\n类是一种抽象，而类的实例化过程就是从抽象到具体的转变。正是因为存在这一实例化的过程，所以就存在干预这个过程的机会。\n\n类本身是一个语法糖，每个实例独享数据，但是共享方法。在存在多个实例时也是一种性能优化。\n\n而且类是支持装饰器的，装饰器则是提供了一种声明式语法。\n\n\n# 类组件是如何收集数据的\n\n查看vue-class-component的源码可以知道，类组件会被转化为 Option 组件，而且会自动生成一个 setup 函数作为该组件的属性。setup 函数的返回值其实就是类组件的所有实例属性。 而且注意到类会在 setup 中被实例化，才能收集到实例属性。 还可以观察到__s属性，这个属性其实就是我们使用的import { setup } from 'vue-class-component'，这个setup函数的返回值的属性。其定义在这里。\n\n以上的介绍是指vue-class-component的正常工作逻辑。也就是@Options的工作逻辑。如果是使用了本库的@Component这个装饰器。则又有一些不同。\n\n在@Component中，会对上面生成的 setup 属性再次进行一次包装，再生成一个新的 setup 属性。在这个新的 setup 函数中实现我们自己的依赖注入逻辑。粗略的概括起来就是首先根据类来获取需要注入的数据 A，然后在计算出原属 setup 函数的返回值 B，最后合并数据 A 和数据 B 得到最终返回值 C。这个 C 就是新的 setup 函数的返回值。\n\n所以可以发现当前类组件的依赖注入是在 setup 执行完之后才注入的。\n\n这个目前还算不上是缺陷，因为类组件的 setup 函数是 vue-class-component 固定实现的，并不含有业务逻辑。\n\n意味着该原始 setup 函数中并不会访问类的实例属性。本质是 vue-class-component 提供的 setup 函数本身不能访问this.$data。\n\n它只能访问this.$props $emit $attrs $slots。\n\n需要注意 setup 不是类组件的合法方法，意味着我们不能在类组件中定义 setup 方法。\n\n注意虽然 option 组件中的 setup 函数虽然也是只能访问 props 和 ctx，但是一个组件只有一个 setup 函数，在该 setup 函数内部定义的数据，是可以衍生出新数据的。\n\n但是现在类组件中每个实例属性都对应一个 setup 函数，这些 setup 函数是互相独立的，没有办法做到数据之间的衍生。倒是可以通过定义 getter 方法来定义新数据。\n\n\n# 如何在类组件中使用 setup\n\n首先在 vue 中存在两种组件形式，一种是 Option 组件，即直接声明一个对象，然后配置固定的某些属性即代表一个组件。还有一种形式是类组件。\n\n类组件本身是不被 vue 支持的，需要借助 vue-class-component 才能工作。还好 vue-class-component 也是 vue 官方支持的。\n\n在 Option 组件中，我们可以直接配置 setup 属性。但是在类组件中，我们不能在类中直接写一个 setup 属性/或者 setup 函数。\n\n实际上在类组件的类中只能写特定的属性和方法。比如生命周期函数，其他函数都相当于 Option 组件中的 methods 中定义的方法。\n\n类组件中的属性则相当于 Option 组件中的 data 定义的数据。\n\n我们可以发现，在 Option 组件还有其他的属性或者方法似乎不知道在什么地方定义了。\n\n比如 watch 属性，computed 属性，setup 函数，props 属性，directives 属性，components 属性。\n\n对于 computed 属性应该定义为类的 getter 方法。\n\n对于 setup，则需要import { setup } from 'vue-class-component'，然后使用 setup 函数初始化类的属性。\n\n对于 props 属性，则需要class MyComponent extends Vue.with(SomeProps) {}，可以参考这里\n\n其他的属性和函数都需要在@Options装饰器中定义。可以参考这里\n\n顺便提一句，我本以为在类组件中使用 setup，就像在 Option 组件中一样简单，直接在类中定义 setup 方法就可以了。但是实际上这样是行不通的。\n\n如果我们在类组件中定义 setup 方法，那么最终会被 vue-class-component 覆盖掉。实际上 vue-class-component 内部会自动生成一个 setup 函数来收集数据。\n\n所以需要使用 vue-class-component 提供的 setup 函数来延迟初始化类的属性。\n\n根据官方 issue 来看，不能在类中定义 setup 方法的原因是，我们不能根据 setup 方法的返回值类型来修改类的类型。这里的意思是指 setup 的返回值应该设置为类的成员属性，我们可以在运行时做到这一点，但是在类型提示方面做不到。\n\n\n# 如何使用 declareProviders\n\n可以说在 99%的场景中我们都不需要使用 declareProviders，除非业务足够复杂。\n\n当我们不使用 declareProviders 时，意味着所有的服务都是全局的，那么所有的服务的生命周期都是全局的。\n\n如果我们的业务稍微复杂一点，我们可以在页面路由层面使用 declareProviders，这样这些服务的生命周期就是路由级别的，当切换路由的时候，这些服务也会被卸载。\n\n如果我们的业务更加复杂，可以在 2 级路由，3 级路由都这样操作。\n\n上面提到的都是针对路由的操作，之所以首先提到路由，是因为路由的切换，我们可以非常明显的感受到页面的更新，也就是某些组件的卸载和某些组件的创建。这同时也是生命周期的体现。\n\n那么在有生命周期的地方，我们都是可以使用 declareProviders 的。比如复杂的弹窗，tabs 切换。但是实际上我觉得没有必要把服务的生命周期卡的这么死，稍微把服务的生命周期提升一点也是无伤大雅的。\n\n还有一种场景就是某个组件本身需要使用 declareProviders，即我们希望每个组件实例都有自己的服务实例，而不是所有的组件共享服务。比如 Table 组件我们可以提供一个选择了 table 的哪些行的、以及全选/取消全选这种服务。显然我们希望这个服务是每个 table 组件独享的。",normalizedContent:"# option 组件，类组件和服务的关系\n\noption 组件本身就是一个对象，这个对象预定义了一套属性，比如 data、methods、components 等。\n\n类组件看起来像是一个类，只不过是把一部分 option 组件中的属性定义为类的成员属性。另一部分不支持的属性还是需要借助vue-class-component这个库来支持。比如 watch 属性，只能定义在@options这个装饰器中。总之看上去会有点不伦不类。 通过深入分析vue-class-component这个库，可以发现最终这个类还是被转化成 option 组件了，所以从性能上来看也并不推荐使用类组件。 当然类组件也是有优势的，比如在 angular 中，组件只能是类，大多数服务也是类，而且都可以使用依赖注入，整体上来看是比较一致的。\n\n服务可以是任意数据或者任意方法或者数据和方法的集合。在依赖注入框架中，大多数服务被定义成类，因为类对依赖注入是最友好的。\n\n\n# 为什么使用类来作为服务\n\n类是一种抽象，而类的实例化过程就是从抽象到具体的转变。正是因为存在这一实例化的过程，所以就存在干预这个过程的机会。\n\n类本身是一个语法糖，每个实例独享数据，但是共享方法。在存在多个实例时也是一种性能优化。\n\n而且类是支持装饰器的，装饰器则是提供了一种声明式语法。\n\n\n# 类组件是如何收集数据的\n\n查看vue-class-component的源码可以知道，类组件会被转化为 option 组件，而且会自动生成一个 setup 函数作为该组件的属性。setup 函数的返回值其实就是类组件的所有实例属性。 而且注意到类会在 setup 中被实例化，才能收集到实例属性。 还可以观察到__s属性，这个属性其实就是我们使用的import { setup } from 'vue-class-component'，这个setup函数的返回值的属性。其定义在这里。\n\n以上的介绍是指vue-class-component的正常工作逻辑。也就是@options的工作逻辑。如果是使用了本库的@component这个装饰器。则又有一些不同。\n\n在@component中，会对上面生成的 setup 属性再次进行一次包装，再生成一个新的 setup 属性。在这个新的 setup 函数中实现我们自己的依赖注入逻辑。粗略的概括起来就是首先根据类来获取需要注入的数据 a，然后在计算出原属 setup 函数的返回值 b，最后合并数据 a 和数据 b 得到最终返回值 c。这个 c 就是新的 setup 函数的返回值。\n\n所以可以发现当前类组件的依赖注入是在 setup 执行完之后才注入的。\n\n这个目前还算不上是缺陷，因为类组件的 setup 函数是 vue-class-component 固定实现的，并不含有业务逻辑。\n\n意味着该原始 setup 函数中并不会访问类的实例属性。本质是 vue-class-component 提供的 setup 函数本身不能访问this.$data。\n\n它只能访问this.$props $emit $attrs $slots。\n\n需要注意 setup 不是类组件的合法方法，意味着我们不能在类组件中定义 setup 方法。\n\n注意虽然 option 组件中的 setup 函数虽然也是只能访问 props 和 ctx，但是一个组件只有一个 setup 函数，在该 setup 函数内部定义的数据，是可以衍生出新数据的。\n\n但是现在类组件中每个实例属性都对应一个 setup 函数，这些 setup 函数是互相独立的，没有办法做到数据之间的衍生。倒是可以通过定义 getter 方法来定义新数据。\n\n\n# 如何在类组件中使用 setup\n\n首先在 vue 中存在两种组件形式，一种是 option 组件，即直接声明一个对象，然后配置固定的某些属性即代表一个组件。还有一种形式是类组件。\n\n类组件本身是不被 vue 支持的，需要借助 vue-class-component 才能工作。还好 vue-class-component 也是 vue 官方支持的。\n\n在 option 组件中，我们可以直接配置 setup 属性。但是在类组件中，我们不能在类中直接写一个 setup 属性/或者 setup 函数。\n\n实际上在类组件的类中只能写特定的属性和方法。比如生命周期函数，其他函数都相当于 option 组件中的 methods 中定义的方法。\n\n类组件中的属性则相当于 option 组件中的 data 定义的数据。\n\n我们可以发现，在 option 组件还有其他的属性或者方法似乎不知道在什么地方定义了。\n\n比如 watch 属性，computed 属性，setup 函数，props 属性，directives 属性，components 属性。\n\n对于 computed 属性应该定义为类的 getter 方法。\n\n对于 setup，则需要import { setup } from 'vue-class-component'，然后使用 setup 函数初始化类的属性。\n\n对于 props 属性，则需要class mycomponent extends vue.with(someprops) {}，可以参考这里\n\n其他的属性和函数都需要在@options装饰器中定义。可以参考这里\n\n顺便提一句，我本以为在类组件中使用 setup，就像在 option 组件中一样简单，直接在类中定义 setup 方法就可以了。但是实际上这样是行不通的。\n\n如果我们在类组件中定义 setup 方法，那么最终会被 vue-class-component 覆盖掉。实际上 vue-class-component 内部会自动生成一个 setup 函数来收集数据。\n\n所以需要使用 vue-class-component 提供的 setup 函数来延迟初始化类的属性。\n\n根据官方 issue 来看，不能在类中定义 setup 方法的原因是，我们不能根据 setup 方法的返回值类型来修改类的类型。这里的意思是指 setup 的返回值应该设置为类的成员属性，我们可以在运行时做到这一点，但是在类型提示方面做不到。\n\n\n# 如何使用 declareproviders\n\n可以说在 99%的场景中我们都不需要使用 declareproviders，除非业务足够复杂。\n\n当我们不使用 declareproviders 时，意味着所有的服务都是全局的，那么所有的服务的生命周期都是全局的。\n\n如果我们的业务稍微复杂一点，我们可以在页面路由层面使用 declareproviders，这样这些服务的生命周期就是路由级别的，当切换路由的时候，这些服务也会被卸载。\n\n如果我们的业务更加复杂，可以在 2 级路由，3 级路由都这样操作。\n\n上面提到的都是针对路由的操作，之所以首先提到路由，是因为路由的切换，我们可以非常明显的感受到页面的更新，也就是某些组件的卸载和某些组件的创建。这同时也是生命周期的体现。\n\n那么在有生命周期的地方，我们都是可以使用 declareproviders 的。比如复杂的弹窗，tabs 切换。但是实际上我觉得没有必要把服务的生命周期卡的这么死，稍微把服务的生命周期提升一点也是无伤大雅的。\n\n还有一种场景就是某个组件本身需要使用 declareproviders，即我们希望每个组件实例都有自己的服务实例，而不是所有的组件共享服务。比如 table 组件我们可以提供一个选择了 table 的哪些行的、以及全选/取消全选这种服务。显然我们希望这个服务是每个 table 组件独享的。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"依赖注入",frontmatter:{author:"kaokei",title:"依赖注入",date:"2021-12-19T16:52:54.000Z",permalink:"/pages/6bada4/",sidebar:"auto",categories:["随笔","技术"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/dependency-injection.html",relativePath:"_posts/dependency-injection.md",key:"v-13d384c5",path:"/pages/6bada4/",headers:[{level:2,title:"什么是依赖注入",slug:"什么是依赖注入",normalizedTitle:"什么是依赖注入",charIndex:2},{level:2,title:"依赖注入 vs import/export",slug:"依赖注入-vs-import-export",normalizedTitle:"依赖注入 vs import/export",charIndex:4298},{level:2,title:"图解",slug:"图解",normalizedTitle:"图解",charIndex:4567},{level:2,title:"什么是 provider",slug:"什么是-provider",normalizedTitle:"什么是 provider",charIndex:4639}],headersStr:"什么是依赖注入 依赖注入 vs import/export 图解 什么是 provider",content:'# 什么是依赖注入\n\n关于依赖注入的概念可以参考 Angular 的文档，Angular 中的依赖注入。\n\n首先不得不提到的一点是什么是依赖注入，我在网上搜索了很多文章，专业术语也有很多，看的我迷迷糊糊的。我尝试记录一下我自己的理解。\n\n首先从名字入手，依赖注入可以分成依赖和注入。\n\n# 什么是依赖？\n\n在讨论依赖之前，必须先了解什么是服务，不考虑边界情况下，可以把服务理解为数据和方法的集合，即一个对象既包含数据又包含方法就可以称为为服务。\n\n一般我们会通过实例化一个类来得到这个对象。我们可以想象的到这个类的某个实例属性有可能又是另一个类的实例对象。这个过程可以一直进行下去。比如这样的依赖关系图：\n\nA --\x3e B、C、D\nB --\x3e C、D\nC --\x3e D、E\nD --\x3e E、F\nE --\x3e F\nF 没有依赖\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面的依赖图代表 A 这个类有三个实例属性b、c、d分别是B、C、D这三个类的实例对象。意味着A类是依赖B、C、D这 3 个类的。 而B类又是依赖C、D这两个类的。依次类推我们可以知道C、D、E这三个类的依赖，注意到F类是没有依赖的。\n\n具体从类的角度来讲，可以在 2 个地方来描述这种依赖关系。 第 1 个地方是在实例属性上声明该属性是另一个类的实例。 第 2 个地方就是在类的构造函数中声明参数是某个类的实例属性。 示例代码如下：\n\nimport { Injectable } from "@kaokei/use-vue-service";\n\n@Injectable()\nexport class LoggerService {\n  public log(...msg: any[]) {\n    console.log("from logger service ==>", ...msg);\n  }\n}\n\n@Injectable()\nexport class CountService {\n  public count = 0; // 该属性是普通属性，不是依赖\n\n  @Inject(LoggerService)\n  public logger!: LoggerService; // 该属性是依赖\n\n  constructor(\n    private logger2: LoggerService // 该参数是依赖\n  ) {}\n\n  public addOne() {\n    this.count++;\n    this.logger.log("from logger addOne ==> ", this.count);\n    this.logger2.log("from logger2 addOne ==> ", this.count);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 什么是注入呢？\n\n在谈论注入之前，我们先来看看，如果没有依赖注入框架，我们怎么实例化 CountService 呢？\n\n显然在我们调用构造函数之前，我们需要提前准备好参数。即const logger = new LoggerService();。\n\n然后就可以调用构造函数了，const countService = new CountService(logger);。此时我们就完成了 CountService 的实例化。\n\n但是似乎还有一个缺陷，就是现在这个实例仍然缺少一个实例属性logger。最简单的解决办法就是countService.logger = logger;。\n\n这样我们终于完成了全部的实例化过程。注意到这里我们复用了logger对象。即 logger 属性和 logger2 属性指向了同一个对象。\n\n这个例子只是演示实例化过程。实际业务中应该很少会有两个属性指向同一个对象。\n\n其实无意中我们已经介绍了两种注入服务的方式的手动实现版本，即构造函数参数注入和属性注入。\n\n这里再顺嘴提一句还存在另一种注入方式，就是setter注入，简单介绍就是在类中定义一个方法，在方法内设置属性值。然后再调用该方法。类似这样：countService.setLogger(logger);。在有些依赖注入框架中优先建议使用setter注入，而不建议使用属性注入。不过本库只是实现了属性注入，而不支持setter注入。\n\n书归正传，上面详细介绍了依赖注入的手动实现过程。那么依赖注入框架的作用就是把上面的过程自动化。\n\n通过依赖注入框架，我们可以这样来获取 countService 实例对象。\n\nconst countService = useService(CountService);\n\n\n1\n\n\n和上面的手动的实例化过程对比，是不是发现这样写的代码就简单多了，这就是依赖注入框架的魅力，实际上依赖关系越复杂，依赖注入框架的优势就越明显。\n\n这里再多嘴说一句，从上面的分析来看，useService 这个函数是用来获取实例的，但却不一定是必须的。\n\n比如在 angular 中，就不需要这样一个函数来获取实例。因为 angular 应用中组件的形式只能是类，在这个组件类中就可以直接使用@Inject 来注入服务了。\n\n但是在 Vue 中，Vue 组件的形式有两种，一种是类组件，这种情况我们也可以不使用 useService，可以直接使用@Inject 来注入服务；另一种情况则是 Option 组件，因为 Option 组件不是类，所以不能使用装饰器。只能使用 useService 这种类似 hooks 的方法类获取实例对象。\n\n我的总结是依赖注入实在没有什么技术含量，也没有什么高大上的地方。不要被陌生的技术名词给吓到了。 本质上就是 Key-Value 的魔法。比如：\n\ndefineKeyValue("tokenA", "valueA"); // 内部使用map来记录对应关系\nconst value = getValueByKey("tokenA"); // 再通过map.get(key)获取数据即可\n\n\n1\n2\n\n\n可以说这就是最简单的依赖注入的简单实现。但是它实在是太简单了，处理的场景有限，所以价值不大。至少要再加上类的实例化能力。\n\ndefineKeyValue("tokenA", ClassA); // 内部使用map来记录对应关系\nconst value = getValueByKey("tokenA"); // 再通过map.get(key)获取到ClassA，然后实例化一个实例返回\n\n\n1\n2\n\n\n当然如果要处理 ClassA 依赖 ClassB 这种场景，就需要其他方面的支持。比如 typescript 以及 decorator。因为这属于技术问题，不属于概念问题，这里不再细述。\n\n现在我们这个简易的依赖注入库实现了两种能力，如果判断是类，则去实例化；否值直接返回。我们可以沿着这个思路继续添加新能力。比如如果是普通函数，那么就当作普通函数来执行，然后把这个函数的返回值当作服务返回，这样我们就有三种能力了。\n\n主要是介绍这种扩展的思路，只要有这种扩展的思路，我们就可以继续扩展更多的能力，无非就是添加一个if-else分支的事情。\n\n排除掉这种扩展思路本身，我们的依赖注入框架还有什么局限性吗？\n\n其实还有命名空间单一的问题。显然上面所有的数据都处于同一个全局命名空间下。因为defineKeyValue和getValueByKey是一个全局函数。那么所有的配置信息就只有一份。这种状况在大多数场景应该也没有什么问题。但是确实还可以继续提升一下。\n\n我们需要继续引入一个新的概念，就是Injector。通过下面的伪代码我们可以快速了解什么是 Injector。\n\nconst parentInjector = new Injector();\nconst childInjector = new Injector();\nchildInjector.parent = parentInjector;\n\nparentInjector.defineKeyValue("tokenA", ClassA);\nchildInjector.defineKeyValue("tokenB", ClassB);\n\n// 注意到childInjector中并没有定义tokenA，但是仍然可以获取到服务实例\nconst serviceA = childInjector.getValueByKey("tokenA");\nconst serviceB = childInjector.getValueByKey("tokenB");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n从以上伪代码中可以看出，之所以引入 Injector 这个概念主要是为了避免只有全局一份配置信息。我们可以做到每次实例化一个 Injector 对象，这个 Injector 对象就具有依赖注入的能力；除此之外我们还可以给 Injector 对象增加一个 parent 属性，从而可以把 Injector 对象关联起来，如果当前 Injector 对象中找不到某个服务，就会从其 parent Injector 对象中寻找服务，直到根 Injector 为空。\n\n以上是从依赖注入框架的角度来思考的，和具体业务是无关的。考虑到在前端的场景下，应该怎样去结合呢？\n\n本库参考 angular 把 Injector 绑定在组件上，默认根 Injector 是绑定在根组件上，可以理解为公共的全局的命名空间。\n\n如果在业务上认为某个数据和某个组件是绑定的，就需要用到 declareProviders([CountService])。这行代码意味着当前组件会关联一个 Injector，并且配置了一个 CountService 服务。同时也意味着，在当前组件及其子孙组件中调用 useService 时，一定会从这个 Injector 中获取到 CountService 服务实例（前提是子孙组件不再定义同样的服务declareProviders([CountService])）。\n\n这种寻找机制和原型链寻找属性的机制非常相似，也就是底层的命名空间中的同名属性会覆盖上层命名空间的同名属性。\n\n\n# 依赖注入 vs import/export\n\n 1. import/export 适合单例\n 2. import/export 强制依赖某个实例/具体的数据，不存在干预服务创建过程的可能性。\n 3. 依赖注入解藕了依赖声明和依赖的实例化。比如声明依赖 LoggerService，但是可以通过配置修改为 OtherLoggerService 的实例\n 4. Vue3 跨组件共享数据，为何要用 provide/inject？直接 export/import 数据行吗？\n 5. 前端什么时候用 import 什么时候用依赖注入?\n\n\n# 图解\n\n通过图片中不同的颜色可以区分出 declareProviders 划分出来不同的命名空间，这也是本库的 logo 的来源。\n\n\n\n\n# 什么是 provider\n\n因为本库的依赖注入的思想是来自于 angular，所以大家可以直接查看angular 的官方文档。这里我再说说我的理解。\n\nprovider 字面意思就是提供者，这里具体一点就是服务的提供者。提到服务，我们必须了解两个概念：服务名字和服务来源。最常见的 provider 如下：\n\n{\n  provide: AppleService, // 这是服务名字\n  useClass: AppleService, // 这是服务来源\n}\n\n\n1\n2\n3\n4\n\n\n服务提供者是用来解决一个问题：服务是怎么来的？\n\n最简单的场景就是配置的是什么，就把这个当作服务。还可以实例化一个类来当作服务，还可以执行某个函数，把返回值当作服务。这些在上面已经介绍过了。\n\n总结起来就是 provider 是一种规范，从 provider 中我们可以获取服务标识符、服务创建机制、创建服务所需要的东西。\n\n服务标识符意味着当我们获取服务时需要提供的标识符。\n\n服务创建机制也是必须的，因为我们可能是没有办法只从服务标识符中推导出如何创建一个服务的，比如我们没有办法准确区分一个类和一个普通函数，也就没有办法知道怎么去创建这个服务，是应该 new 这个函数，还是直接调用这个函数。\n\n当我们指定useClass时，显然是想要通过类的实例化来创建一个服务，虽然我们可以直接把服务标识符来当作类来使用，但是我们仍然支持useClass:AnotherService，从而达到实际提供服务的类和服务标识符的类的解耦。',normalizedContent:'# 什么是依赖注入\n\n关于依赖注入的概念可以参考 angular 的文档，angular 中的依赖注入。\n\n首先不得不提到的一点是什么是依赖注入，我在网上搜索了很多文章，专业术语也有很多，看的我迷迷糊糊的。我尝试记录一下我自己的理解。\n\n首先从名字入手，依赖注入可以分成依赖和注入。\n\n# 什么是依赖？\n\n在讨论依赖之前，必须先了解什么是服务，不考虑边界情况下，可以把服务理解为数据和方法的集合，即一个对象既包含数据又包含方法就可以称为为服务。\n\n一般我们会通过实例化一个类来得到这个对象。我们可以想象的到这个类的某个实例属性有可能又是另一个类的实例对象。这个过程可以一直进行下去。比如这样的依赖关系图：\n\na --\x3e b、c、d\nb --\x3e c、d\nc --\x3e d、e\nd --\x3e e、f\ne --\x3e f\nf 没有依赖\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面的依赖图代表 a 这个类有三个实例属性b、c、d分别是b、c、d这三个类的实例对象。意味着a类是依赖b、c、d这 3 个类的。 而b类又是依赖c、d这两个类的。依次类推我们可以知道c、d、e这三个类的依赖，注意到f类是没有依赖的。\n\n具体从类的角度来讲，可以在 2 个地方来描述这种依赖关系。 第 1 个地方是在实例属性上声明该属性是另一个类的实例。 第 2 个地方就是在类的构造函数中声明参数是某个类的实例属性。 示例代码如下：\n\nimport { injectable } from "@kaokei/use-vue-service";\n\n@injectable()\nexport class loggerservice {\n  public log(...msg: any[]) {\n    console.log("from logger service ==>", ...msg);\n  }\n}\n\n@injectable()\nexport class countservice {\n  public count = 0; // 该属性是普通属性，不是依赖\n\n  @inject(loggerservice)\n  public logger!: loggerservice; // 该属性是依赖\n\n  constructor(\n    private logger2: loggerservice // 该参数是依赖\n  ) {}\n\n  public addone() {\n    this.count++;\n    this.logger.log("from logger addone ==> ", this.count);\n    this.logger2.log("from logger2 addone ==> ", this.count);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 什么是注入呢？\n\n在谈论注入之前，我们先来看看，如果没有依赖注入框架，我们怎么实例化 countservice 呢？\n\n显然在我们调用构造函数之前，我们需要提前准备好参数。即const logger = new loggerservice();。\n\n然后就可以调用构造函数了，const countservice = new countservice(logger);。此时我们就完成了 countservice 的实例化。\n\n但是似乎还有一个缺陷，就是现在这个实例仍然缺少一个实例属性logger。最简单的解决办法就是countservice.logger = logger;。\n\n这样我们终于完成了全部的实例化过程。注意到这里我们复用了logger对象。即 logger 属性和 logger2 属性指向了同一个对象。\n\n这个例子只是演示实例化过程。实际业务中应该很少会有两个属性指向同一个对象。\n\n其实无意中我们已经介绍了两种注入服务的方式的手动实现版本，即构造函数参数注入和属性注入。\n\n这里再顺嘴提一句还存在另一种注入方式，就是setter注入，简单介绍就是在类中定义一个方法，在方法内设置属性值。然后再调用该方法。类似这样：countservice.setlogger(logger);。在有些依赖注入框架中优先建议使用setter注入，而不建议使用属性注入。不过本库只是实现了属性注入，而不支持setter注入。\n\n书归正传，上面详细介绍了依赖注入的手动实现过程。那么依赖注入框架的作用就是把上面的过程自动化。\n\n通过依赖注入框架，我们可以这样来获取 countservice 实例对象。\n\nconst countservice = useservice(countservice);\n\n\n1\n\n\n和上面的手动的实例化过程对比，是不是发现这样写的代码就简单多了，这就是依赖注入框架的魅力，实际上依赖关系越复杂，依赖注入框架的优势就越明显。\n\n这里再多嘴说一句，从上面的分析来看，useservice 这个函数是用来获取实例的，但却不一定是必须的。\n\n比如在 angular 中，就不需要这样一个函数来获取实例。因为 angular 应用中组件的形式只能是类，在这个组件类中就可以直接使用@inject 来注入服务了。\n\n但是在 vue 中，vue 组件的形式有两种，一种是类组件，这种情况我们也可以不使用 useservice，可以直接使用@inject 来注入服务；另一种情况则是 option 组件，因为 option 组件不是类，所以不能使用装饰器。只能使用 useservice 这种类似 hooks 的方法类获取实例对象。\n\n我的总结是依赖注入实在没有什么技术含量，也没有什么高大上的地方。不要被陌生的技术名词给吓到了。 本质上就是 key-value 的魔法。比如：\n\ndefinekeyvalue("tokena", "valuea"); // 内部使用map来记录对应关系\nconst value = getvaluebykey("tokena"); // 再通过map.get(key)获取数据即可\n\n\n1\n2\n\n\n可以说这就是最简单的依赖注入的简单实现。但是它实在是太简单了，处理的场景有限，所以价值不大。至少要再加上类的实例化能力。\n\ndefinekeyvalue("tokena", classa); // 内部使用map来记录对应关系\nconst value = getvaluebykey("tokena"); // 再通过map.get(key)获取到classa，然后实例化一个实例返回\n\n\n1\n2\n\n\n当然如果要处理 classa 依赖 classb 这种场景，就需要其他方面的支持。比如 typescript 以及 decorator。因为这属于技术问题，不属于概念问题，这里不再细述。\n\n现在我们这个简易的依赖注入库实现了两种能力，如果判断是类，则去实例化；否值直接返回。我们可以沿着这个思路继续添加新能力。比如如果是普通函数，那么就当作普通函数来执行，然后把这个函数的返回值当作服务返回，这样我们就有三种能力了。\n\n主要是介绍这种扩展的思路，只要有这种扩展的思路，我们就可以继续扩展更多的能力，无非就是添加一个if-else分支的事情。\n\n排除掉这种扩展思路本身，我们的依赖注入框架还有什么局限性吗？\n\n其实还有命名空间单一的问题。显然上面所有的数据都处于同一个全局命名空间下。因为definekeyvalue和getvaluebykey是一个全局函数。那么所有的配置信息就只有一份。这种状况在大多数场景应该也没有什么问题。但是确实还可以继续提升一下。\n\n我们需要继续引入一个新的概念，就是injector。通过下面的伪代码我们可以快速了解什么是 injector。\n\nconst parentinjector = new injector();\nconst childinjector = new injector();\nchildinjector.parent = parentinjector;\n\nparentinjector.definekeyvalue("tokena", classa);\nchildinjector.definekeyvalue("tokenb", classb);\n\n// 注意到childinjector中并没有定义tokena，但是仍然可以获取到服务实例\nconst servicea = childinjector.getvaluebykey("tokena");\nconst serviceb = childinjector.getvaluebykey("tokenb");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n从以上伪代码中可以看出，之所以引入 injector 这个概念主要是为了避免只有全局一份配置信息。我们可以做到每次实例化一个 injector 对象，这个 injector 对象就具有依赖注入的能力；除此之外我们还可以给 injector 对象增加一个 parent 属性，从而可以把 injector 对象关联起来，如果当前 injector 对象中找不到某个服务，就会从其 parent injector 对象中寻找服务，直到根 injector 为空。\n\n以上是从依赖注入框架的角度来思考的，和具体业务是无关的。考虑到在前端的场景下，应该怎样去结合呢？\n\n本库参考 angular 把 injector 绑定在组件上，默认根 injector 是绑定在根组件上，可以理解为公共的全局的命名空间。\n\n如果在业务上认为某个数据和某个组件是绑定的，就需要用到 declareproviders([countservice])。这行代码意味着当前组件会关联一个 injector，并且配置了一个 countservice 服务。同时也意味着，在当前组件及其子孙组件中调用 useservice 时，一定会从这个 injector 中获取到 countservice 服务实例（前提是子孙组件不再定义同样的服务declareproviders([countservice])）。\n\n这种寻找机制和原型链寻找属性的机制非常相似，也就是底层的命名空间中的同名属性会覆盖上层命名空间的同名属性。\n\n\n# 依赖注入 vs import/export\n\n 1. import/export 适合单例\n 2. import/export 强制依赖某个实例/具体的数据，不存在干预服务创建过程的可能性。\n 3. 依赖注入解藕了依赖声明和依赖的实例化。比如声明依赖 loggerservice，但是可以通过配置修改为 otherloggerservice 的实例\n 4. vue3 跨组件共享数据，为何要用 provide/inject？直接 export/import 数据行吗？\n 5. 前端什么时候用 import 什么时候用依赖注入?\n\n\n# 图解\n\n通过图片中不同的颜色可以区分出 declareproviders 划分出来不同的命名空间，这也是本库的 logo 的来源。\n\n\n\n\n# 什么是 provider\n\n因为本库的依赖注入的思想是来自于 angular，所以大家可以直接查看angular 的官方文档。这里我再说说我的理解。\n\nprovider 字面意思就是提供者，这里具体一点就是服务的提供者。提到服务，我们必须了解两个概念：服务名字和服务来源。最常见的 provider 如下：\n\n{\n  provide: appleservice, // 这是服务名字\n  useclass: appleservice, // 这是服务来源\n}\n\n\n1\n2\n3\n4\n\n\n服务提供者是用来解决一个问题：服务是怎么来的？\n\n最简单的场景就是配置的是什么，就把这个当作服务。还可以实例化一个类来当作服务，还可以执行某个函数，把返回值当作服务。这些在上面已经介绍过了。\n\n总结起来就是 provider 是一种规范，从 provider 中我们可以获取服务标识符、服务创建机制、创建服务所需要的东西。\n\n服务标识符意味着当我们获取服务时需要提供的标识符。\n\n服务创建机制也是必须的，因为我们可能是没有办法只从服务标识符中推导出如何创建一个服务的，比如我们没有办法准确区分一个类和一个普通函数，也就没有办法知道怎么去创建这个服务，是应该 new 这个函数，还是直接调用这个函数。\n\n当我们指定useclass时，显然是想要通过类的实例化来创建一个服务，虽然我们可以直接把服务标识符来当作类来使用，但是我们仍然支持useclass:anotherservice，从而达到实际提供服务的类和服务标识符的类的解耦。',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"前端常见库的理解",frontmatter:{author:"kaokei",title:"前端常见库的理解",date:"2021-12-19T16:52:54.000Z",permalink:"/pages/bfd17a/",sidebar:"auto",categories:["随笔","技术"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/frame-analysis.html",relativePath:"_posts/frame-analysis.md",key:"v-3c4ee536",path:"/pages/bfd17a/",headers:[{level:2,title:"常见库的理解",slug:"常见库的理解",normalizedTitle:"常见库的理解",charIndex:2},{level:2,title:"定义服务的方式",slug:"定义服务的方式",normalizedTitle:"定义服务的方式",charIndex:193},{level:2,title:"redux 以及 react-redux",slug:"redux-以及-react-redux",normalizedTitle:"redux 以及 react-redux",charIndex:717},{level:2,title:"对比 vuex 和 redux 的区别 todo",slug:"对比-vuex-和-redux-的区别-todo",normalizedTitle:"对比 vuex 和 redux 的区别 todo",charIndex:2796},{level:2,title:"mobx 和 mobx-react",slug:"mobx-和-mobx-react",normalizedTitle:"mobx 和 mobx-react",charIndex:2856},{level:2,title:"mobx-state-tree",slug:"mobx-state-tree",normalizedTitle:"mobx-state-tree",charIndex:3863},{level:2,title:"redux-thunk",slug:"redux-thunk",normalizedTitle:"redux-thunk",charIndex:5146},{level:2,title:"redux-saga",slug:"redux-saga",normalizedTitle:"redux-saga",charIndex:6003},{level:2,title:"redux-observable",slug:"redux-observable",normalizedTitle:"redux-observable",charIndex:8136},{level:2,title:"dva",slug:"dva",normalizedTitle:"dva",charIndex:6174},{level:2,title:"rematch",slug:"rematch",normalizedTitle:"rematch",charIndex:10317},{level:2,title:"composition-api",slug:"composition-api",normalizedTitle:"composition-api",charIndex:10367},{level:2,title:"rxjs",slug:"rxjs",normalizedTitle:"rxjs",charIndex:8204},{level:2,title:"vue-rx",slug:"vue-rx",normalizedTitle:"vue-rx",charIndex:10764},{level:2,title:"Recoil todo",slug:"recoil-todo",normalizedTitle:"recoil todo",charIndex:11542},{level:2,title:"immer",slug:"immer",normalizedTitle:"immer",charIndex:11628},{level:2,title:"concent",slug:"concent",normalizedTitle:"concent",charIndex:13066},{level:2,title:"dob",slug:"dob",normalizedTitle:"dob",charIndex:14023},{level:2,title:"xreact",slug:"xreact",normalizedTitle:"xreact",charIndex:14178},{level:2,title:"stamen",slug:"stamen",normalizedTitle:"stamen",charIndex:15512},{level:2,title:"redux-arena",slug:"redux-arena",normalizedTitle:"redux-arena",charIndex:15939},{level:2,title:"各个库的特性总结",slug:"各个库的特性总结",normalizedTitle:"各个库的特性总结",charIndex:16184},{level:2,title:"vue 和 react 的数据驱动的区别",slug:"vue-和-react-的数据驱动的区别",normalizedTitle:"vue 和 react 的数据驱动的区别",charIndex:16390},{level:2,title:"其他参考文章",slug:"其他参考文章",normalizedTitle:"其他参考文章",charIndex:16531}],headersStr:"常见库的理解 定义服务的方式 redux 以及 react-redux 对比 vuex 和 redux 的区别 todo mobx 和 mobx-react mobx-state-tree redux-thunk redux-saga redux-observable dva rematch composition-api rxjs vue-rx Recoil todo immer concent dob xreact stamen redux-arena 各个库的特性总结 vue 和 react 的数据驱动的区别 其他参考文章",content:"# 常见库的理解\n\n简单记录一下常见库的个人理解，把这些库放在一起对比后可以比较方便的知道各个库的不同，以及凸显 @kaokei/use-vue-service 的差异点和必要性。\n\n可以从这几个方面来分析库的不同点。\n\n * 如何定义服务\n * 如何组织/组合/管理/注册服务\n * 如何获取服务\n * 数据如何驱动模板\n\n这里的服务的定义是：特定领域相关数据和方法的集合。\n\n\n# 定义服务的方式\n\n 1. class\n\n// 定义服务\nclass Counter {\n  count: 0;\n}\n\nconst counter1 = new Counter(); // 获取服务实例\nconst counter2 = new Counter(); // 获取服务实例\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. function\n\n// 定义服务\nfunction getCounter() {\n  return {\n    count: 0\n  }\n}\n\nconst counter1 = getCounter(); // 获取服务实例\nconst counter2 = getCounter(); // 获取服务实例\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 3. 对象字面量\n\nconst Counter = {\n  count: 0\n}\n\n\n1\n2\n3\n\n\n注意这里第 3 种方式是单例模式，如果想要多个实例，只能使用 deepClone 来复制数据了。实际上没有哪个库是采用这种方式。\n\n这里只是想明确一下服务声明和服务本身是两个不同的概念。服务定义可以有多种不同的形式，但是服务本身就是一个普通 js 对象。\n\n\n# redux 以及 react-redux\n\n\n\n * reduxjs/redux\n * reduxjs/react-redux\n * redux 中文文档\n * 官网 github demo\n * 官网文档 examples\n * 官网文档 中间件选择\n\nredux 本身的概念比较简单，而且是和具体 UI 框架无关的。所以必须要配合 react-redux 一起使用才能更好的在 react 中使用。\n\n// 观察redux的主要API调用\nconst rootReducer = combineReducers({subReducer1, subReducer2});\nconst store = createStore(rootReducer);\nstore.subscribe(() => console.log(store.getState()));\nstore.dispatch({type: 'someType'});\n\n\n1\n2\n3\n4\n5\n\n\n第一点需要弄明白的就是 reducer 的定义。reducer 本身是一个纯函数，是和 redux 无关的。\n\n但是函数签名必须满足：(previousState = initialState, action) => newState，其实这也是和类所表达的服务是一个东西，是数据和方法的封装。\n\n其中 state 部分就是数据，但是要注意这里的 state 部分，虽然说 reducer 是一个纯函数，但其实并不够纯，因为 initalState 必然属于闭包中的一个变量值。\n\n而 action 部分就是方法。只不过这里的 action 部分使用的是 type 字段，类型是字符串而已。\n\n再看 combineReducers 只是组合服务的一种方式而已。\n\n然后再通过 createStore 创建一个全局 store，通过 store 来管理这些服务，最重要的一种管理方式就是只能通过 store.dispatch 来修改数据。\n\n又因为 store 是全局的，我们可以通过单例模式，import 到需要的模块中，就达到获取服务的目的了。\n\n而 store.subscribe 则是实现数据驱动模板更新的最底层的机制。\n\n如果不使用 react-redux，可以参考这个简单的例子。\n\n这个例子中可以明显看出来如何通过 store.subscribe 来实现数据变化进而驱动模板更新。但是这样操作的性能太低了。\n\n再来看看 react-redux，它是基于 redux 的连接 react 和 redux 的库，基本特性和 redux 一致，主要是解决了 store 中数据变化时，模版也会自动更新。\n\n主要 api 是 connect 和 Provider。\n\nProvider 通过 context 提供了全局的 store，是为了 conenct 服务的。在 connect 中可以随时通过 context 获取到 store。从而读取数据。\n\nconnect 本身是是一个函数，该函数返回值是一个高阶组件。注意高阶组件是一个函数，而不是组件。这个高阶组件函数可以包裹我们自己的组件，返回一个新组件。\n\n该高阶组件可以通过闭包拿到 connect 提供的 mapStateToProps 和 mapDispatchToProps，通过这两个函数再加上 context 中的 store，就可以获取到相应数据和方法了。\n\n其中数据部分是：store+mapStateToProps=>newState，其中方法部分是：store.dispatch+mapDispatchToProps=>newActions。\n\n目前为止还只能解决组件第一次渲染的时候获取数据的问题，关键还是要解决数据变化的时候，组件如何响应更新。\n\n实际上还是需要依赖 store.subscribe 这个 api，会在组件 mounted 时注册一个监听器，卸载组件时取消监听器。\n\n该监听器每次会重新从 store 获取数据，并和缓存中的数据做对比，如果数据有变化，那么执行 setState 操作，从而更新组件。\n\nredux 的缺点是模版代码很多，而且在 reducer 中已经定义了数据和方法了，在 connect 中还是需要再次定义数据和方法。再加上 action、actionCreator 等等。\n\n> 使用 reduce 表达服务，使用闭包中的 initialState 作为服务的初始值 使用 combineReducers 来组合服务 使用 createStore 来管理服务 使用 Provider 提供全局的 store，组件使用 connect 来订阅 store 中的数据和方法 组件通过 store.dispatch 来修改数据，当 store 中数据变化时，因为 connect 订阅了 store，所以会接收到 store.subscribe 的通知，从而可以更新组件\n\n\n# 对比 vuex 和 redux 的区别 todo\n\nmutable 和 immutable 自顶向下 直接触达\n\n\n# mobx 和 mobx-react\n\n\n\n * mobxjs/mobx\n * mobxjs/mobx-react\n * mobx 官方例子\n * 参考官方文档\n\nmobx 和 vue 非常像，可以说大部分能力 vue 已经天生支持了，剩下的就是如何组织代码的区别而已。\n\nmobx 使用步骤\n\n 1. 定义可观察数据，可以是对象或者类。这里依赖 mobx 的 observable 这个 API。\n 2. 定义组件。这里依赖 mobx-react 的 observer 这个 API。\n 3. 通过依赖注入 store 到组件，依赖 mobx-react 的 Provider 和 inject 两个 API\n 4. 然后我们只要改变了数据，组件就会自动更新。\n\n再对比 vue3 中的实现，第 1 步其实就是 reactive 这个 api，第 2 步中 vue 组件默认就是会观察 reactive 数据的，所以也不需要 observer 这个 API。至于第 3 步确实还没有比较好的复用数据的方式。这也就是 @kaokei/use-vue-service 主要做的事情。\n\n参考这个demo，分析如下：\n\n 1. 采用类来定义服务，但是需要具体声明各个属性和方法的性质，比如@observable @computed @action\n 2. 然后导出一个类的实例，这里就能看出来至少在这个项目中服务都是单例的，如果需要多例，就需要自己手动 new 多个实例。\n 3. 然后在根组件使用 Provider，这个 Provider 比较特殊，可以注入任意个值。\n 4. 然后在组件中就可以@inject('articlesStore')类似这样注入服务，然后就可以通过 this.props 获取到特定 store 数据。\n 5. 因为定义组件时，会将组件当作参数传递给 observer 函数，所以当数据有变化时，observer 函数就会更新组件。\n\n再参考这个demo\n\n这里没有使用 Provider，而是通过 props 从根组件一层层传递服务，这也是一种方式，但是就略显麻烦，但是证明了只要能获取到 store，就可以使用该 store 的数据和方法。而且能看出来，相比于 redux 和 react-redux，mobx 和 mobx-react 结合的更加紧密，完全不能独立分开使用。\n\n\n# mobx-state-tree\n\n\n\n * mobxjs/mobx-state-tree\n\nmobx-state-tree 虽然是基于 mobx 的，但是定位应该是和 mobx 是一样的，只不过在于组织代码方面有所区别。\n\n参考这个例子\n\n可以发现居然还可以和 redux 相结合，虽然我觉得有点脱裤子放屁了。这里面有很多的重复性工作。\n\n依赖 redux 的 Provider 来提供全局单一数据源，然后依赖 connect 订阅数据源。\n\n在定义 mobx-state-tree 的模型的 actions 时，需要 actions 常量作为方法名。\n\n在 mapDispatchToProps 时也需要 actions 常量生成方法名，关键是组件中的 props 还是需要定义一摸一样的方法名来接受 props。\n\n总之就是非常繁琐，而且耦合非常严重，但是确实可以工作，而且能非常明确的看出来 mobx-state-tree 具体做了什么工作，没有做什么工作。\n\n注意 mobx-state-tree 非常明显的语法特征：\n\nconst SomeStore = types.model(\"modelName\").props({someProps}).views({someViews}).actions({someActions})\n\n看起来狂拽酷炫吊炸天，实际上就是一个类的换一种写法，也就是 mobx-state-tree 中服务的定义形式。\n\n需要注意的是 mobx-state-tree 自带一套类型系统，尤其是其中的 Model 类型，是可以嵌套的。从而可以形成一个 state-tree。\n\n还有一点就是实际使用 mobx-state-tree 时，还是需要我们手动初始化 Model 的。\n\nconst someStore = SomeStore.create(initialState)\n\n参考这个例子\n\n这个例子可以明显看出来 mobx-state-tree 是代替了 mobx，并且配合 mobx-react 来工作的。\n\n上面有分析过，主要就是 Provider 和 inject 注入 store，并且 mobx-state-tree 是依赖 mobx 的，所以数据本身也是响应式的。\n\n可以明显看出来，mobx-state-tree 和 mobx 的区别在于组织代码的区别。\n\n * mobx 是采用类来组织数据和方法。\n * mobx-state-tree 是基于自带的类型定义采用链式方法调用来定义数据和方法。并且 Model 本身就是类型，也就意味着 Model 是可以嵌套的，所以这也是 mobx-state-tree 名称的来源，因为 Model 就是 state，嵌套之后就会形成一颗树。但是 mobx 中的类则不能相互嵌套形成复杂的“类树”。\n\n可以看出来 mobx-state-tree 这个库相比于 mobx 更加的 opinionated，它有一套自己的代码组织方式。但是我现在觉得单一数据源就是有原罪的。\n\n\n# redux-thunk\n\n\n\n * reduxjs/redux-thunk\n\n这个是 redux 的中间件，而且是官方的中间件。用来解决 redux 本身不支持异步更新的缺点。如果看了源代码会惊讶的发现只有十几行代码。\n\n原来的 store.dispatch 只支持对象作为参数，经过 redux-thunk 中间件的加持就可以额外支持 dispatch 一个函数了，而且函数的第一个参数还是 dispatch，意味着我们可以在函数内部再次调用 dispatch。在函数内部我们可以写条件判断逻辑，可以异步执行 dispatch。\n\n再加上 async/await 的加持，基本可以解决所有异步问题。而且可以避免深度回调的噩梦。\n\n再来说说问题的本质。redux 本身只是提供了 store 来保存数据，通过 store.dispatch 来更新数据。它本身并不支持异步更新和条件更新。\n\n实际上这只是客观描述这个现状，这本身并不是一个问题。问题在于我们非要把这些条件逻辑和异步逻辑放到 redux 中来管理而已。\n\n通过 redux-thunk 的加持，我们可以这样写代码：\n\nstore.dispatch((dispatch) => {\n  setTimeout(function() {\n    dispatch({\n      type: 'add',\n      payload: 1\n    });\n  }, 5000);\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n但是实际上没有 redux-thunk 中间件，我们可以这样写代码：\n\nsetTimeout(function() {\n  store.dispatch({\n    type: 'add',\n    payload: 1\n  })\n}, 5000)\n\n\n1\n2\n3\n4\n5\n6\n\n\n只不过缺点是没有纳入 redux 中被管理起来，我们可能需要把这些逻辑抽取出来，放到一个公共的模块中。然后 import 到当前模块中使用。\n\n\n# redux-saga\n\n\n\n * redux-saga/redux-saga\n * redux-saga 中文文档\n * Vuex、Flux、Redux、Redux-saga、Dva、MobX\n * Redux-Saga 漫谈\n * 彻彻底底教会你使用 Redux-saga(包含样例代码)\n * redux-saga 实现原理及 umi, dva 设计思想解析\n * redux-saga 实践总结\n\nsaga 是英语 传奇 的意思。它的思想是 拦截。\n\n同样是 redux 的中间件，和 redux-thunk 一样都是为了解决 redux 解决不了的副作用的问题。\n\n据说是用来解决复杂异步场景下的问题。\n\n我没有 redux-saga 的使用经验，之前尝试入门过好几次，每次都是放弃了，是真正的从入门到放弃。这次因为要写总结，还是硬着头皮看了一些文章，大概弄明白了 saga 的原理。\n\n像 redux-thunk、redux-promise 这些中间件都是特别简单的，源代码都没有几行。总体思路都是增强 store.dispatch 函数的能力。\n\n原始 store.dispatch 只支持 dispatch 普通对象，redux-thunk 中间件则可以支持 dispatch 函数，redux-promise 中间件则可以 dispatch promise。\n\n针对 redux-thunk 分析 store.dispatch(action)，如果 action 是函数，那么就执行这个函数，而且函数参数就是 dispatch，这样在 action 内部可以再次使用 dispatch 去真正的 dispatch 一个普通对象，达到修改 store 中数据的效果。\n\n对比分析一下 redux-saga，它也是增强了 store.dispatch 能力，但是不像 redux-thunk 是判断 action 本身是不是函数来执行不同的策略。redux-saga 虽然增强了 store.dispatch 的能力，但是它还是只能 dispatch 普通对象，这就意味着我们很难从 store.dispatch 区分我们到底是 dispatch 一个普通 action，还是一个 saga action。因为它们的格式都是:\n\n{\n  type: 'ACTION_NAME',\n  payload: some_data\n}\n\n\n1\n2\n3\n4\n\n\n那么 redux-saga 是如何增强 store.dispatch 的呢？我的理解是基于字符串匹配的。因为在使用 redux-saga 时，第一步是定义 saga，然后是需要注册 saga，注册的时候，其实就是配置 ACTION_NAME 和 saga 的映射。\n\n那么当用户手动 store.dispatch 一个普通对象时，redux-saga 这个中间件会去自己注册的 saga 列表中去找有没有对应的 ACTION_NAME，如果找到了该 ACTION_NAME，那么就执行该 ACTION_NAME 对应的 saga 函数。剩下的逻辑和 redux-thunk 是一样的，thunk 本身就是一个普通函数，只是具有访问 dispatch 的能力，这样我们就可以随意在 thunk 函数中调用 dispatch 函数来更新 store 中的数据。saga 也是一个函数，它倒是不能直接访问 dispatch 函数，但是提供了更多更复杂的函数来帮助我们处理副作用、异步逻辑。其中的 put 函数就是类似 dispatch 的能力。还有一点需要注意，类似 put 这类的 effect function 是从从全局包导入的。import { call, put, takeEvery, takeLatest } from 'redux-saga/effects'，这意味着他们是全局唯一的，也意味着他们是单例的，也意味着全局 store 也是单例的，但是在 redux-thunk 是可以实现多例的。\n\n如果要是找不到对应的 ACTION_NAME，那么就走正常的 redux 原始的 store.dispatch 逻辑，也就是直接通过 reducer 来消费该 action，最终修改了 store 中的数据。这里还可以再强调一点，正常 redux 的逻辑是由多个 reducer 组合而成的，这些 reducer 内部会消费 action，隐含逻辑是所有 reducer 中的 ACTION_NAME 都是全局的，是不能同名的，否则可能会引起逻辑错误。\n\n总结就是 redux-thunk 是通过类型来判断当前 action 到底是函数，还是普通对象。redux-saga 则是通过字符串匹配来检查到底是 saga action，还是原来的普通的 action。\n\n还有一点区别是 redux-saga 是需要常驻内存的监听器的，redux-thunk 则不需要。\n\n有人说 redux-saga 是通过事件监听机制来实现的，或者说观察者订阅者模式实现的，但是底层还是依赖字符串匹配。\n\n\n# redux-observable\n\n\n\n * redux-observable/redux-observable\n\n看名字就知道是基于 rxjs 的 redux 的中间件。我没有使用过该库，只是看了看文档。\n\n因为我有过 angular 的开发经验，所以对 rxjs 还算比较熟悉。当我在熟悉 redux-saga 的过程中，我就发现其 api 的设计和 rxjs 非常相似。这里的相似是指操作符部分。\n\nrxjs 中提供了很多的操作符函数来帮助我们操作流，redux-saga 中提供了很多 effect function 来帮助我们操作副作用。\n\n再来看 redux-observable 的 api，我发现 redux-saga 和 redux-observable 非常相似。这里的相似是指架构设计部分。\n\nredux-saga 中主要概念是 saga，对应 redux-observable 中主要概念是 epic。通过声明式的语句定义好这些 saga 或者 epic，然后在通过 combine 函数组合成 rootSaga 或者 rootEpic。\n\n在注册完 redux 中间件后，即 applyMiddle 后，还需要 run(rootSaga)或者 run(rootEpic)。\n\n不管是 saga 还是 epic，他们的思想都是通过 store.dispatch(plain action)来触发异步调用，并调用另一些 store.dispatch(plain action)。\n\n本质都是要根据字符串匹配找到对应的 saga 或者 epic，然后执行相应的异步逻辑。该异步逻辑又会通过 dispatch(plain action)来修改 store 中的数据。\n\n\n# dva\n\n\n\n * dvajs/dva\n * 一图胜千言, 何况是四图? 图解 DVA\n * Dva 源码解析\n\ndva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。\n\n通过官方介绍，可以知道 dva 是通过组合 redux、redux-saga、react-router、fetch、antd 这些项目必须的常用库，以及采用约定大于配置的思想定义了自己的开发规范。并且提供了 dva-cli 脚手架快速初始化项目目录。\n\napp.model({\n  namespace: 'count', // 全局store的一级属性\n  state: { // store.count的子属性\n    record: 0,\n    current: 0,\n  },\n  reducers: { // redux概念中的reducers\n    add(state) {},\n    minus(state) {},\n  },\n  effects: { // redux-saga概念中的saga\n    *add(action, { call, put }) {\n      yield call(delay, 1000);\n      yield put({ type: 'minus' });\n    },\n  },\n  subscriptions: { // 新增加的概念，主要是帮助我们订阅其他事件\n    keyboardWatcher({ dispatch }) {\n      key('⌘+up, ctrl+up', () => { dispatch({type:'add'}) });\n    },\n  },\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n可以看出主要特点是把 store 及 saga 统一为一个 model 的概念, 写在一个 js 文件里面，增加了一个 Subscriptions, 用于收集其他来源的 action, eg: 键盘操作\n\n可以把 dva 理解为换一种方式组织 react、redux、saga 代码。虽然看起来没有新东西，但是确实有助于管理代码，提升开发效率，所以又有人说 dva 只是 react 开发的一种最佳实践。\n\n再回过头看看上面的示例代码，其他属性都不用太关心，唯有 namespace 是必须要要关心的，目前我知道有两个作用：\n\n第一：自动作为全局 store 的一级属性，意味着在 connect 时，必须以 namespace 作为参数解构。 第二：prefixNamespace 函数使用 reduce 对每一个 model 做处理，为 model 的 reducers 和 effects 中的方法添加了 namespace 的前缀。解决了 redux 中 action 重名的问题，以及 saga 中 action 重名的问题。\n\n可以直接指定namespace来跨model通信\nyield call({ type: 'namespace/foo' });\nyield take({ type: 'namespace/bar' });\n\n\n1\n2\n3\n\n\n\n# rematch\n\n\n\n * rematch/rematch\n * rematch 官方文档\n\n\n# composition-api\n\n\n\n * vuejs/composition-api\n\n\n# rxjs\n\n\n\n * ReactiveX/rxjs\n\n有人说 rxjs 和 promise 非常像，确实如此。但是随着学习的深入，就会发现差别越来越大。\n\n * promise 只有单个值，observable 则可以有多个值。\n * promise 函数是立即执行的，observable 则是订阅后才执行的。\n * promise 不能被取消，observable 则可以取消订阅。\n * promise 没有提供便利的操作符函数，observable 则提供了一系列强大的操作符函数。\n * 以上这些差异最终导致 promise 是需要使用的时候才去使用的，是命令式的；observable 则容易上瘾，我自己容易把所有的业务逻辑变成 observable 的衍变逻辑，是声明式的。\n\n\n# vue-rx\n\n\n\n * vuejs/vue-rx\n\nnew Vue({\n  // requires `Rx` passed to Vue.use() to expose `Subject`\n  domStreams: ['plus$'],\n  subscriptions () {\n    // use this.plus$\n  }\n})\n\n<button v-stream:click=\"{ subject: plus$, data: someData }\">+</button>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n作为 Vue 的插件，我们可以通过 subscriptions 属性声明 observable 属性，可以通过 domStreams 属性声明流式事件。\n\n唯一不习惯的是 subscriptions 声明的属性一般没有$后缀，因为在模版中使用的时候确实不是 observable 对象，但是有时候我们确实又想知道这个变量到底是不是流。\n\n总之没有在 angular 使用的这么舒服，并且和 vue 本身的配合还是有一些不和谐的地方。subscriptions 对象本身每个属性都是流，但是我们实际使用的时候，已经变成普通数据了，就像 data 属性声明的那些属性一样。这就导致一些问题。\n\n第一、认知方面的转变，我们定义的是流，使用的时候却是数据，只不过该数据会被流驱动修改。\n\n第二、所有流式 api 都只能在 subscriptions 内部使用，其他地方都不能（不建议）使用流相关的 api。\n\n第三、官网中有说到，因为初始化顺序问题，导致不能直接在 watch 中观察 subscriptions。这也是 subscriptions 和 data 的区别。\n\n第四、新增加了很多概念以及 api，有上手成本。\n\n\n# Recoil todo\n\n\n\n * Recoil 仓库\n * Recoil 官方文档\n * 如何评价 Facebook 的 React 状态管理库 Recoil？\n\n\n# immer\n\n\n\n * immerjs/immer\n * immutable-js/immutable-js\n * 官方文档\n * immer.js:也许更适合你的 immutable js 库\n\nimmerjs 和 immutable-js 都是用来实现 immutable 效果的库。我自己之前一直没有意识到我在写代码的时候，也会不自觉的使用了 immutable 特性。比如：\n\nconst baseArray = [1, 2, 3];\nconst baseObj = { name: 'zhangsan', age: 12 };\n\nconst newArray = baseArray.map(val => val + 1);\nconst newArray = [...baseArray];\nconst newObj = {...baseObj, age: 13};\n\n\n1\n2\n3\n4\n5\n6\n\n\n但是这些方式都属于浅拷贝，有时候我们需要处理复杂的 json 数据，就需要用到深拷贝，比如lodash.deepClone。\n\n但是每次修改都需要深拷贝的话，性能方面比较差，所以就有了 immerjs 和 immutable-js，他们的实现原理都是只会拷贝修改部分的数据，没有修改过的数据则不会拷贝。\n\nimmutable-js 的特点是采用 fromJS 和 toJS，可以将普通 js 类型和 immutable-js 自带的类型之间转化，所有的修改都需要嗲用 immutable-js 自带的类型的特定方法去修改数据，但是最终消费数据的时候，还是需要采用 toJS 转化为普通对象。\n\n这种转换来转换去的操作，我不是很喜欢，而且 api 众多，上手成本过高。但是优点是兼容性比较好。\n\n反果类 immerjs 这个库只是提供了 produce 这个函数来实现 immutable 特性。参考如下代码：\n\nimport produce from \"immer\"\n\nconst baseState = [\n    {\n        todo: \"Learn typescript\",\n        done: true\n    },\n    {\n        todo: \"Try immer\",\n        done: false\n    }\n]\n\nconst nextState = produce(baseState, draftState => {\n    draftState.push({todo: \"Tweet about it\"})\n    draftState[1].done = true\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n观察示例代码，使用 produce 函数，可以通过 reducer 的处理 baseState，得到一个新的对象 nextState。说实话，我光看这个示例代码没有办法想出来它底层原理是如何实现的。当然最简单的实现肯定是先把 baseState 深拷贝一份，然后当作参数传递给 draftState，然后返回值就是 nextState 了。但是显然这么做完全不需要 immerjs 了，用户只需要一个深拷贝函数就行了。因为这并没有实现只拷贝修改的部分。上面参考文章中有提到它内部其实是用到了 Proxy 来实现的，具体可以看那篇文章。\n\n\n# concent\n\n\n\n * concentjs/concent\n * concent 知乎专栏\n * concent minimal-example\n * concent complete-example\n\n从服务的角度来理解就非常容易理解 concent 的思路，当然有些细节不看源码还是不太了解。\n\n观察官网的示例代码，通过对象的形式定义服务，并且通过 run 函数注册服务。需要注意这里的服务可以包含数据 state，computed，也有方法 reducer，甚至还有 watch 和 lifecycle。\n\n注意官网一直说的是 module，我这里说的是服务，虽然名词不一样，但是指的是一个东西。需要注意这里的服务的标识符号是字符串。那么在使用服务的时候。 在类组件上使用@register(\"counter\")，在函数组件上使用useConcent(\"counter\");。可以明显看出来服务的标识符就是字符串。\n\n另外@register 和 useConcent 这两个 api 不仅仅是只能接受一个字符串来代表一个服务，或者说 module。\n\n在知乎专栏这篇文章中有展示其他使用方式，比如：\n\nuseConcent('login');\nuseConcent({connect: ['login']});\nuseConcent({module: \"login\", state: spState});\nuseConcent({module: \"login\", state: spState, setup});\nuseConcent({setup, state: iState, props});\nuseConcent({state: iState});\n\n\n1\n2\n3\n4\n5\n6\n\n\n可以看出来目前就有 connect，module，state，setup，props 这些属性，注意到 module 本身也是有 state 的，组件本身也是有 state 的；connect 和 module 的区别是什么？setup 又是做什么的？ 总体来说还是太复杂了。\n\n不清楚服务，或者说 module 是否支持多例，主要是看到示例代码中有关生命周期部分的注释有提到多例，但是不清楚如何实现的。\n\n\n# dob\n\n\n\n * dobjs/dob\n * 要不要支持一下国产的 dob?\n\n理念与 mobx 相同，使用 proxy 让使用过程更流畅，数组不会搞成纯对象，有依赖注入最佳实践，还能配合 redux。\n\n只是看了看官网的示例代码，感觉和 mobx 非常像，api 一样，代码组织方式都基本是一样的。\n\n\n# xreact\n\n\n\n * reactive-react/xreact\n * FP, FRP, observable, declarative, monadic, composable, reactivex, fantasyland\n\n这个项目应该类似 vue-rx，但是对于这种项目我个人理解价值不大。我的理解是像 rxjs 这种库，就像 jquery、lodash 一样，就是一种工具库。我们使用这些工具库也不需要专门的 react-jquery，react-lodash。 像 xreact，vue-rx 这种库，一般都是 opinionated library，提供自己的开发规范。当然如果认可这种开发规范，对开发效率应该是有提升的。但是我还是更愿意自己手写 rxjs 代码，就像在 angular 中一样。\n\n我硬着头皮看了看官方文档，比我想的要复杂得多，并没有像 vue-rx 那样是在 vue 基础上增加了很少的概念，xreact 增加的概念就比较多了。官方文档介绍了如何使用 xreact，一共分成 3 步：\n\n第一步：定义视图组件，也叫受控组件、展示组件、无状态组件\n\n这里还是 react 的概念，只不过对 props 有固定的要求，即必须含有 props.actions 属性，该属性包含了改变数据的所有方法。\n\n第二步：定义 Plan\n\n这里开始出现 xreact 特有的概念了，plan 本身就是一个函数，只不过对入参和出参有固定的要求。\n\n入参是 intent$, 本身是一个流，其中的值就是 action。\n\n出参是一个对象，包含 update$ 和 actions 两个属性。update$ 类似于 redux 中的 reducer，actions 属性则是类似于 redux 中的 action creator\n\n这里需要注意第一步中定义组件时也有一个 actions，我的理解是这两个 actions 虽然有关联，但是不完全一致，其中 props.actions 更加像 redux 中的 store.dispatch(action)\n\n我看了一下项目的 package.json，本身是不依赖 redux 的，所以应该是自己实现了类似的 api，但是似乎没有发现类似 combineReducers 的函数。\n\n目前我看到的示例代码都是一个 plan 对应一个组件，似乎没有类似 combinePlan 这样的函数来组合 plan。\n\n第三步：我认为就是链接 plan 和组件\n\n但是命名有点过于简约了。比如 X、 x。\n\n<X x={rx}>\n  <Counter />\n</X>,\n\n猜测功能应该类似于\n\n<Provider store={store}>\n  <Counter />\n</Provider>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n还有一点也需要注意：\n\nimport {x, X} from 'xreact/lib/x'\nconst Counter = x(plan)(CounterView)\n\n\n1\n2\n\n\n这里的 x 是一个函数，但是<X x={rx}>中的 x 只是一个 props 属性\n\n\n# stamen\n\n\n\n * forsigner/stamen\n * 简洁的 React 状态管理库 - Stamen - 该文档太旧了，和最新版本的 api 不太一致\n * Stamen 文档\n\nStamen 是一个 immutable React 状态管理库。api 非常简洁，内部采用 immer 实现 immutable 特性。\n\n我刚开始看的是知乎的文章，后来才看的是 github 主页，发现知乎的文章是 2018 年的，最新版本已经有很大变化了。\n\n只看最新版本的话，api 变得特别像 redux 和 dva 了。\n\n通过 createStore 返回 useStore 和 dispatch，其中 useStore 可以获取数据，dispatch 可以修改数据。\n\n多 store 的实现，依赖 import/export 来手动导入导出。\n\n组件依赖多个 store 的场景，需要重命名 useStore 和 dispatch。\n\n\n# redux-arena\n\n\n\n * hapood/redux-arena\n * 全新的 redux 模块化框架，redux-arena\n\n我的理解 redux-arena 的特点是依赖 react、redux、redux-saga、immutable 实现 state、saga、action、Component 在组件级别可复用。\n\n如果把 state、saga、action 理解为服务的一种形式，这句话可以解释为实现服务在组件层面可复用。是不是有 angular 的味道了。\n\n\n# 各个库的特性总结\n\n * 如何定义服务\n   * 类\n   * 工厂函数\n   * 函数链式调用\n   * reducer\n * 如何组织/组合服务\n   * 依赖注入\n   * combineReducers\n   * 单例还是多例\n * 如何获取服务\n   * 自动初始化还是手动初始化\n   * 全局 Provider+connect 还是手动 import 还是依赖注入\n * 数据如何驱动模板\n\n\n# vue 和 react 的数据驱动的区别\n\nimmutable 和 mutable react 是修改完数据后再次执行函数组件或者 render 函数来更新视图 vue 是视图订阅数据，数据变更后通知视图更新。 xxx 场景下，理论上 vue 的效率要比 react 高。\n\n\n# 其他参考文章\n\n * Redux 与它的中间件：redux-thunk，redux-actions，redux-promise，redux-saga\n * redux 异步处理之 redux-thunk 和 redux-saga—阿楠\n * redux-thunk 和 redux-saga 的区别？\n * 异步方案选型 redux-saga 和 redux-thunk（async/await）\n * Redux 源码解析\n * Rectx - 通过引入基类提供默认的 setState 方式管理数据\n * 除 Redux 外，目前还有哪些状态管理解决方案？1\n * 除 Redux 外，目前还有哪些状态管理解决方案？2\n * 除 Redux 外，目前还有哪些状态管理解决方案？3\n * 除 Redux 外，目前还有哪些状态管理解决方案？4\n * 两种状态管理模型\n * Redux 数据流管理架构有什么致命缺陷,未来会如何改进？1\n * Redux 数据流管理架构有什么致命缺陷,未来会如何改进？2\n * Redux 数据流管理架构有什么致命缺陷,未来会如何改进？3\n * 鬼才！我居然把 Vue3 的原理用到了 React 上？\n * Vue 3 核心原理 -- reactivity 自己实现\n * React Hooks 是否可以改为用类似 Vue 3 Composition API 的方式实现？1\n * React Hooks 是否可以改为用类似 Vue 3 Composition API 的方式实现？2\n * React Hooks 是否可以改为用类似 Vue 3 Composition API 的方式实现？3",normalizedContent:"# 常见库的理解\n\n简单记录一下常见库的个人理解，把这些库放在一起对比后可以比较方便的知道各个库的不同，以及凸显 @kaokei/use-vue-service 的差异点和必要性。\n\n可以从这几个方面来分析库的不同点。\n\n * 如何定义服务\n * 如何组织/组合/管理/注册服务\n * 如何获取服务\n * 数据如何驱动模板\n\n这里的服务的定义是：特定领域相关数据和方法的集合。\n\n\n# 定义服务的方式\n\n 1. class\n\n// 定义服务\nclass counter {\n  count: 0;\n}\n\nconst counter1 = new counter(); // 获取服务实例\nconst counter2 = new counter(); // 获取服务实例\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. function\n\n// 定义服务\nfunction getcounter() {\n  return {\n    count: 0\n  }\n}\n\nconst counter1 = getcounter(); // 获取服务实例\nconst counter2 = getcounter(); // 获取服务实例\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 3. 对象字面量\n\nconst counter = {\n  count: 0\n}\n\n\n1\n2\n3\n\n\n注意这里第 3 种方式是单例模式，如果想要多个实例，只能使用 deepclone 来复制数据了。实际上没有哪个库是采用这种方式。\n\n这里只是想明确一下服务声明和服务本身是两个不同的概念。服务定义可以有多种不同的形式，但是服务本身就是一个普通 js 对象。\n\n\n# redux 以及 react-redux\n\n\n\n * reduxjs/redux\n * reduxjs/react-redux\n * redux 中文文档\n * 官网 github demo\n * 官网文档 examples\n * 官网文档 中间件选择\n\nredux 本身的概念比较简单，而且是和具体 ui 框架无关的。所以必须要配合 react-redux 一起使用才能更好的在 react 中使用。\n\n// 观察redux的主要api调用\nconst rootreducer = combinereducers({subreducer1, subreducer2});\nconst store = createstore(rootreducer);\nstore.subscribe(() => console.log(store.getstate()));\nstore.dispatch({type: 'sometype'});\n\n\n1\n2\n3\n4\n5\n\n\n第一点需要弄明白的就是 reducer 的定义。reducer 本身是一个纯函数，是和 redux 无关的。\n\n但是函数签名必须满足：(previousstate = initialstate, action) => newstate，其实这也是和类所表达的服务是一个东西，是数据和方法的封装。\n\n其中 state 部分就是数据，但是要注意这里的 state 部分，虽然说 reducer 是一个纯函数，但其实并不够纯，因为 initalstate 必然属于闭包中的一个变量值。\n\n而 action 部分就是方法。只不过这里的 action 部分使用的是 type 字段，类型是字符串而已。\n\n再看 combinereducers 只是组合服务的一种方式而已。\n\n然后再通过 createstore 创建一个全局 store，通过 store 来管理这些服务，最重要的一种管理方式就是只能通过 store.dispatch 来修改数据。\n\n又因为 store 是全局的，我们可以通过单例模式，import 到需要的模块中，就达到获取服务的目的了。\n\n而 store.subscribe 则是实现数据驱动模板更新的最底层的机制。\n\n如果不使用 react-redux，可以参考这个简单的例子。\n\n这个例子中可以明显看出来如何通过 store.subscribe 来实现数据变化进而驱动模板更新。但是这样操作的性能太低了。\n\n再来看看 react-redux，它是基于 redux 的连接 react 和 redux 的库，基本特性和 redux 一致，主要是解决了 store 中数据变化时，模版也会自动更新。\n\n主要 api 是 connect 和 provider。\n\nprovider 通过 context 提供了全局的 store，是为了 conenct 服务的。在 connect 中可以随时通过 context 获取到 store。从而读取数据。\n\nconnect 本身是是一个函数，该函数返回值是一个高阶组件。注意高阶组件是一个函数，而不是组件。这个高阶组件函数可以包裹我们自己的组件，返回一个新组件。\n\n该高阶组件可以通过闭包拿到 connect 提供的 mapstatetoprops 和 mapdispatchtoprops，通过这两个函数再加上 context 中的 store，就可以获取到相应数据和方法了。\n\n其中数据部分是：store+mapstatetoprops=>newstate，其中方法部分是：store.dispatch+mapdispatchtoprops=>newactions。\n\n目前为止还只能解决组件第一次渲染的时候获取数据的问题，关键还是要解决数据变化的时候，组件如何响应更新。\n\n实际上还是需要依赖 store.subscribe 这个 api，会在组件 mounted 时注册一个监听器，卸载组件时取消监听器。\n\n该监听器每次会重新从 store 获取数据，并和缓存中的数据做对比，如果数据有变化，那么执行 setstate 操作，从而更新组件。\n\nredux 的缺点是模版代码很多，而且在 reducer 中已经定义了数据和方法了，在 connect 中还是需要再次定义数据和方法。再加上 action、actioncreator 等等。\n\n> 使用 reduce 表达服务，使用闭包中的 initialstate 作为服务的初始值 使用 combinereducers 来组合服务 使用 createstore 来管理服务 使用 provider 提供全局的 store，组件使用 connect 来订阅 store 中的数据和方法 组件通过 store.dispatch 来修改数据，当 store 中数据变化时，因为 connect 订阅了 store，所以会接收到 store.subscribe 的通知，从而可以更新组件\n\n\n# 对比 vuex 和 redux 的区别 todo\n\nmutable 和 immutable 自顶向下 直接触达\n\n\n# mobx 和 mobx-react\n\n\n\n * mobxjs/mobx\n * mobxjs/mobx-react\n * mobx 官方例子\n * 参考官方文档\n\nmobx 和 vue 非常像，可以说大部分能力 vue 已经天生支持了，剩下的就是如何组织代码的区别而已。\n\nmobx 使用步骤\n\n 1. 定义可观察数据，可以是对象或者类。这里依赖 mobx 的 observable 这个 api。\n 2. 定义组件。这里依赖 mobx-react 的 observer 这个 api。\n 3. 通过依赖注入 store 到组件，依赖 mobx-react 的 provider 和 inject 两个 api\n 4. 然后我们只要改变了数据，组件就会自动更新。\n\n再对比 vue3 中的实现，第 1 步其实就是 reactive 这个 api，第 2 步中 vue 组件默认就是会观察 reactive 数据的，所以也不需要 observer 这个 api。至于第 3 步确实还没有比较好的复用数据的方式。这也就是 @kaokei/use-vue-service 主要做的事情。\n\n参考这个demo，分析如下：\n\n 1. 采用类来定义服务，但是需要具体声明各个属性和方法的性质，比如@observable @computed @action\n 2. 然后导出一个类的实例，这里就能看出来至少在这个项目中服务都是单例的，如果需要多例，就需要自己手动 new 多个实例。\n 3. 然后在根组件使用 provider，这个 provider 比较特殊，可以注入任意个值。\n 4. 然后在组件中就可以@inject('articlesstore')类似这样注入服务，然后就可以通过 this.props 获取到特定 store 数据。\n 5. 因为定义组件时，会将组件当作参数传递给 observer 函数，所以当数据有变化时，observer 函数就会更新组件。\n\n再参考这个demo\n\n这里没有使用 provider，而是通过 props 从根组件一层层传递服务，这也是一种方式，但是就略显麻烦，但是证明了只要能获取到 store，就可以使用该 store 的数据和方法。而且能看出来，相比于 redux 和 react-redux，mobx 和 mobx-react 结合的更加紧密，完全不能独立分开使用。\n\n\n# mobx-state-tree\n\n\n\n * mobxjs/mobx-state-tree\n\nmobx-state-tree 虽然是基于 mobx 的，但是定位应该是和 mobx 是一样的，只不过在于组织代码方面有所区别。\n\n参考这个例子\n\n可以发现居然还可以和 redux 相结合，虽然我觉得有点脱裤子放屁了。这里面有很多的重复性工作。\n\n依赖 redux 的 provider 来提供全局单一数据源，然后依赖 connect 订阅数据源。\n\n在定义 mobx-state-tree 的模型的 actions 时，需要 actions 常量作为方法名。\n\n在 mapdispatchtoprops 时也需要 actions 常量生成方法名，关键是组件中的 props 还是需要定义一摸一样的方法名来接受 props。\n\n总之就是非常繁琐，而且耦合非常严重，但是确实可以工作，而且能非常明确的看出来 mobx-state-tree 具体做了什么工作，没有做什么工作。\n\n注意 mobx-state-tree 非常明显的语法特征：\n\nconst somestore = types.model(\"modelname\").props({someprops}).views({someviews}).actions({someactions})\n\n看起来狂拽酷炫吊炸天，实际上就是一个类的换一种写法，也就是 mobx-state-tree 中服务的定义形式。\n\n需要注意的是 mobx-state-tree 自带一套类型系统，尤其是其中的 model 类型，是可以嵌套的。从而可以形成一个 state-tree。\n\n还有一点就是实际使用 mobx-state-tree 时，还是需要我们手动初始化 model 的。\n\nconst somestore = somestore.create(initialstate)\n\n参考这个例子\n\n这个例子可以明显看出来 mobx-state-tree 是代替了 mobx，并且配合 mobx-react 来工作的。\n\n上面有分析过，主要就是 provider 和 inject 注入 store，并且 mobx-state-tree 是依赖 mobx 的，所以数据本身也是响应式的。\n\n可以明显看出来，mobx-state-tree 和 mobx 的区别在于组织代码的区别。\n\n * mobx 是采用类来组织数据和方法。\n * mobx-state-tree 是基于自带的类型定义采用链式方法调用来定义数据和方法。并且 model 本身就是类型，也就意味着 model 是可以嵌套的，所以这也是 mobx-state-tree 名称的来源，因为 model 就是 state，嵌套之后就会形成一颗树。但是 mobx 中的类则不能相互嵌套形成复杂的“类树”。\n\n可以看出来 mobx-state-tree 这个库相比于 mobx 更加的 opinionated，它有一套自己的代码组织方式。但是我现在觉得单一数据源就是有原罪的。\n\n\n# redux-thunk\n\n\n\n * reduxjs/redux-thunk\n\n这个是 redux 的中间件，而且是官方的中间件。用来解决 redux 本身不支持异步更新的缺点。如果看了源代码会惊讶的发现只有十几行代码。\n\n原来的 store.dispatch 只支持对象作为参数，经过 redux-thunk 中间件的加持就可以额外支持 dispatch 一个函数了，而且函数的第一个参数还是 dispatch，意味着我们可以在函数内部再次调用 dispatch。在函数内部我们可以写条件判断逻辑，可以异步执行 dispatch。\n\n再加上 async/await 的加持，基本可以解决所有异步问题。而且可以避免深度回调的噩梦。\n\n再来说说问题的本质。redux 本身只是提供了 store 来保存数据，通过 store.dispatch 来更新数据。它本身并不支持异步更新和条件更新。\n\n实际上这只是客观描述这个现状，这本身并不是一个问题。问题在于我们非要把这些条件逻辑和异步逻辑放到 redux 中来管理而已。\n\n通过 redux-thunk 的加持，我们可以这样写代码：\n\nstore.dispatch((dispatch) => {\n  settimeout(function() {\n    dispatch({\n      type: 'add',\n      payload: 1\n    });\n  }, 5000);\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n但是实际上没有 redux-thunk 中间件，我们可以这样写代码：\n\nsettimeout(function() {\n  store.dispatch({\n    type: 'add',\n    payload: 1\n  })\n}, 5000)\n\n\n1\n2\n3\n4\n5\n6\n\n\n只不过缺点是没有纳入 redux 中被管理起来，我们可能需要把这些逻辑抽取出来，放到一个公共的模块中。然后 import 到当前模块中使用。\n\n\n# redux-saga\n\n\n\n * redux-saga/redux-saga\n * redux-saga 中文文档\n * vuex、flux、redux、redux-saga、dva、mobx\n * redux-saga 漫谈\n * 彻彻底底教会你使用 redux-saga(包含样例代码)\n * redux-saga 实现原理及 umi, dva 设计思想解析\n * redux-saga 实践总结\n\nsaga 是英语 传奇 的意思。它的思想是 拦截。\n\n同样是 redux 的中间件，和 redux-thunk 一样都是为了解决 redux 解决不了的副作用的问题。\n\n据说是用来解决复杂异步场景下的问题。\n\n我没有 redux-saga 的使用经验，之前尝试入门过好几次，每次都是放弃了，是真正的从入门到放弃。这次因为要写总结，还是硬着头皮看了一些文章，大概弄明白了 saga 的原理。\n\n像 redux-thunk、redux-promise 这些中间件都是特别简单的，源代码都没有几行。总体思路都是增强 store.dispatch 函数的能力。\n\n原始 store.dispatch 只支持 dispatch 普通对象，redux-thunk 中间件则可以支持 dispatch 函数，redux-promise 中间件则可以 dispatch promise。\n\n针对 redux-thunk 分析 store.dispatch(action)，如果 action 是函数，那么就执行这个函数，而且函数参数就是 dispatch，这样在 action 内部可以再次使用 dispatch 去真正的 dispatch 一个普通对象，达到修改 store 中数据的效果。\n\n对比分析一下 redux-saga，它也是增强了 store.dispatch 能力，但是不像 redux-thunk 是判断 action 本身是不是函数来执行不同的策略。redux-saga 虽然增强了 store.dispatch 的能力，但是它还是只能 dispatch 普通对象，这就意味着我们很难从 store.dispatch 区分我们到底是 dispatch 一个普通 action，还是一个 saga action。因为它们的格式都是:\n\n{\n  type: 'action_name',\n  payload: some_data\n}\n\n\n1\n2\n3\n4\n\n\n那么 redux-saga 是如何增强 store.dispatch 的呢？我的理解是基于字符串匹配的。因为在使用 redux-saga 时，第一步是定义 saga，然后是需要注册 saga，注册的时候，其实就是配置 action_name 和 saga 的映射。\n\n那么当用户手动 store.dispatch 一个普通对象时，redux-saga 这个中间件会去自己注册的 saga 列表中去找有没有对应的 action_name，如果找到了该 action_name，那么就执行该 action_name 对应的 saga 函数。剩下的逻辑和 redux-thunk 是一样的，thunk 本身就是一个普通函数，只是具有访问 dispatch 的能力，这样我们就可以随意在 thunk 函数中调用 dispatch 函数来更新 store 中的数据。saga 也是一个函数，它倒是不能直接访问 dispatch 函数，但是提供了更多更复杂的函数来帮助我们处理副作用、异步逻辑。其中的 put 函数就是类似 dispatch 的能力。还有一点需要注意，类似 put 这类的 effect function 是从从全局包导入的。import { call, put, takeevery, takelatest } from 'redux-saga/effects'，这意味着他们是全局唯一的，也意味着他们是单例的，也意味着全局 store 也是单例的，但是在 redux-thunk 是可以实现多例的。\n\n如果要是找不到对应的 action_name，那么就走正常的 redux 原始的 store.dispatch 逻辑，也就是直接通过 reducer 来消费该 action，最终修改了 store 中的数据。这里还可以再强调一点，正常 redux 的逻辑是由多个 reducer 组合而成的，这些 reducer 内部会消费 action，隐含逻辑是所有 reducer 中的 action_name 都是全局的，是不能同名的，否则可能会引起逻辑错误。\n\n总结就是 redux-thunk 是通过类型来判断当前 action 到底是函数，还是普通对象。redux-saga 则是通过字符串匹配来检查到底是 saga action，还是原来的普通的 action。\n\n还有一点区别是 redux-saga 是需要常驻内存的监听器的，redux-thunk 则不需要。\n\n有人说 redux-saga 是通过事件监听机制来实现的，或者说观察者订阅者模式实现的，但是底层还是依赖字符串匹配。\n\n\n# redux-observable\n\n\n\n * redux-observable/redux-observable\n\n看名字就知道是基于 rxjs 的 redux 的中间件。我没有使用过该库，只是看了看文档。\n\n因为我有过 angular 的开发经验，所以对 rxjs 还算比较熟悉。当我在熟悉 redux-saga 的过程中，我就发现其 api 的设计和 rxjs 非常相似。这里的相似是指操作符部分。\n\nrxjs 中提供了很多的操作符函数来帮助我们操作流，redux-saga 中提供了很多 effect function 来帮助我们操作副作用。\n\n再来看 redux-observable 的 api，我发现 redux-saga 和 redux-observable 非常相似。这里的相似是指架构设计部分。\n\nredux-saga 中主要概念是 saga，对应 redux-observable 中主要概念是 epic。通过声明式的语句定义好这些 saga 或者 epic，然后在通过 combine 函数组合成 rootsaga 或者 rootepic。\n\n在注册完 redux 中间件后，即 applymiddle 后，还需要 run(rootsaga)或者 run(rootepic)。\n\n不管是 saga 还是 epic，他们的思想都是通过 store.dispatch(plain action)来触发异步调用，并调用另一些 store.dispatch(plain action)。\n\n本质都是要根据字符串匹配找到对应的 saga 或者 epic，然后执行相应的异步逻辑。该异步逻辑又会通过 dispatch(plain action)来修改 store 中的数据。\n\n\n# dva\n\n\n\n * dvajs/dva\n * 一图胜千言, 何况是四图? 图解 dva\n * dva 源码解析\n\ndva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。\n\n通过官方介绍，可以知道 dva 是通过组合 redux、redux-saga、react-router、fetch、antd 这些项目必须的常用库，以及采用约定大于配置的思想定义了自己的开发规范。并且提供了 dva-cli 脚手架快速初始化项目目录。\n\napp.model({\n  namespace: 'count', // 全局store的一级属性\n  state: { // store.count的子属性\n    record: 0,\n    current: 0,\n  },\n  reducers: { // redux概念中的reducers\n    add(state) {},\n    minus(state) {},\n  },\n  effects: { // redux-saga概念中的saga\n    *add(action, { call, put }) {\n      yield call(delay, 1000);\n      yield put({ type: 'minus' });\n    },\n  },\n  subscriptions: { // 新增加的概念，主要是帮助我们订阅其他事件\n    keyboardwatcher({ dispatch }) {\n      key('⌘+up, ctrl+up', () => { dispatch({type:'add'}) });\n    },\n  },\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n可以看出主要特点是把 store 及 saga 统一为一个 model 的概念, 写在一个 js 文件里面，增加了一个 subscriptions, 用于收集其他来源的 action, eg: 键盘操作\n\n可以把 dva 理解为换一种方式组织 react、redux、saga 代码。虽然看起来没有新东西，但是确实有助于管理代码，提升开发效率，所以又有人说 dva 只是 react 开发的一种最佳实践。\n\n再回过头看看上面的示例代码，其他属性都不用太关心，唯有 namespace 是必须要要关心的，目前我知道有两个作用：\n\n第一：自动作为全局 store 的一级属性，意味着在 connect 时，必须以 namespace 作为参数解构。 第二：prefixnamespace 函数使用 reduce 对每一个 model 做处理，为 model 的 reducers 和 effects 中的方法添加了 namespace 的前缀。解决了 redux 中 action 重名的问题，以及 saga 中 action 重名的问题。\n\n可以直接指定namespace来跨model通信\nyield call({ type: 'namespace/foo' });\nyield take({ type: 'namespace/bar' });\n\n\n1\n2\n3\n\n\n\n# rematch\n\n\n\n * rematch/rematch\n * rematch 官方文档\n\n\n# composition-api\n\n\n\n * vuejs/composition-api\n\n\n# rxjs\n\n\n\n * reactivex/rxjs\n\n有人说 rxjs 和 promise 非常像，确实如此。但是随着学习的深入，就会发现差别越来越大。\n\n * promise 只有单个值，observable 则可以有多个值。\n * promise 函数是立即执行的，observable 则是订阅后才执行的。\n * promise 不能被取消，observable 则可以取消订阅。\n * promise 没有提供便利的操作符函数，observable 则提供了一系列强大的操作符函数。\n * 以上这些差异最终导致 promise 是需要使用的时候才去使用的，是命令式的；observable 则容易上瘾，我自己容易把所有的业务逻辑变成 observable 的衍变逻辑，是声明式的。\n\n\n# vue-rx\n\n\n\n * vuejs/vue-rx\n\nnew vue({\n  // requires `rx` passed to vue.use() to expose `subject`\n  domstreams: ['plus$'],\n  subscriptions () {\n    // use this.plus$\n  }\n})\n\n<button v-stream:click=\"{ subject: plus$, data: somedata }\">+</button>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n作为 vue 的插件，我们可以通过 subscriptions 属性声明 observable 属性，可以通过 domstreams 属性声明流式事件。\n\n唯一不习惯的是 subscriptions 声明的属性一般没有$后缀，因为在模版中使用的时候确实不是 observable 对象，但是有时候我们确实又想知道这个变量到底是不是流。\n\n总之没有在 angular 使用的这么舒服，并且和 vue 本身的配合还是有一些不和谐的地方。subscriptions 对象本身每个属性都是流，但是我们实际使用的时候，已经变成普通数据了，就像 data 属性声明的那些属性一样。这就导致一些问题。\n\n第一、认知方面的转变，我们定义的是流，使用的时候却是数据，只不过该数据会被流驱动修改。\n\n第二、所有流式 api 都只能在 subscriptions 内部使用，其他地方都不能（不建议）使用流相关的 api。\n\n第三、官网中有说到，因为初始化顺序问题，导致不能直接在 watch 中观察 subscriptions。这也是 subscriptions 和 data 的区别。\n\n第四、新增加了很多概念以及 api，有上手成本。\n\n\n# recoil todo\n\n\n\n * recoil 仓库\n * recoil 官方文档\n * 如何评价 facebook 的 react 状态管理库 recoil？\n\n\n# immer\n\n\n\n * immerjs/immer\n * immutable-js/immutable-js\n * 官方文档\n * immer.js:也许更适合你的 immutable js 库\n\nimmerjs 和 immutable-js 都是用来实现 immutable 效果的库。我自己之前一直没有意识到我在写代码的时候，也会不自觉的使用了 immutable 特性。比如：\n\nconst basearray = [1, 2, 3];\nconst baseobj = { name: 'zhangsan', age: 12 };\n\nconst newarray = basearray.map(val => val + 1);\nconst newarray = [...basearray];\nconst newobj = {...baseobj, age: 13};\n\n\n1\n2\n3\n4\n5\n6\n\n\n但是这些方式都属于浅拷贝，有时候我们需要处理复杂的 json 数据，就需要用到深拷贝，比如lodash.deepclone。\n\n但是每次修改都需要深拷贝的话，性能方面比较差，所以就有了 immerjs 和 immutable-js，他们的实现原理都是只会拷贝修改部分的数据，没有修改过的数据则不会拷贝。\n\nimmutable-js 的特点是采用 fromjs 和 tojs，可以将普通 js 类型和 immutable-js 自带的类型之间转化，所有的修改都需要嗲用 immutable-js 自带的类型的特定方法去修改数据，但是最终消费数据的时候，还是需要采用 tojs 转化为普通对象。\n\n这种转换来转换去的操作，我不是很喜欢，而且 api 众多，上手成本过高。但是优点是兼容性比较好。\n\n反果类 immerjs 这个库只是提供了 produce 这个函数来实现 immutable 特性。参考如下代码：\n\nimport produce from \"immer\"\n\nconst basestate = [\n    {\n        todo: \"learn typescript\",\n        done: true\n    },\n    {\n        todo: \"try immer\",\n        done: false\n    }\n]\n\nconst nextstate = produce(basestate, draftstate => {\n    draftstate.push({todo: \"tweet about it\"})\n    draftstate[1].done = true\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n观察示例代码，使用 produce 函数，可以通过 reducer 的处理 basestate，得到一个新的对象 nextstate。说实话，我光看这个示例代码没有办法想出来它底层原理是如何实现的。当然最简单的实现肯定是先把 basestate 深拷贝一份，然后当作参数传递给 draftstate，然后返回值就是 nextstate 了。但是显然这么做完全不需要 immerjs 了，用户只需要一个深拷贝函数就行了。因为这并没有实现只拷贝修改的部分。上面参考文章中有提到它内部其实是用到了 proxy 来实现的，具体可以看那篇文章。\n\n\n# concent\n\n\n\n * concentjs/concent\n * concent 知乎专栏\n * concent minimal-example\n * concent complete-example\n\n从服务的角度来理解就非常容易理解 concent 的思路，当然有些细节不看源码还是不太了解。\n\n观察官网的示例代码，通过对象的形式定义服务，并且通过 run 函数注册服务。需要注意这里的服务可以包含数据 state，computed，也有方法 reducer，甚至还有 watch 和 lifecycle。\n\n注意官网一直说的是 module，我这里说的是服务，虽然名词不一样，但是指的是一个东西。需要注意这里的服务的标识符号是字符串。那么在使用服务的时候。 在类组件上使用@register(\"counter\")，在函数组件上使用useconcent(\"counter\");。可以明显看出来服务的标识符就是字符串。\n\n另外@register 和 useconcent 这两个 api 不仅仅是只能接受一个字符串来代表一个服务，或者说 module。\n\n在知乎专栏这篇文章中有展示其他使用方式，比如：\n\nuseconcent('login');\nuseconcent({connect: ['login']});\nuseconcent({module: \"login\", state: spstate});\nuseconcent({module: \"login\", state: spstate, setup});\nuseconcent({setup, state: istate, props});\nuseconcent({state: istate});\n\n\n1\n2\n3\n4\n5\n6\n\n\n可以看出来目前就有 connect，module，state，setup，props 这些属性，注意到 module 本身也是有 state 的，组件本身也是有 state 的；connect 和 module 的区别是什么？setup 又是做什么的？ 总体来说还是太复杂了。\n\n不清楚服务，或者说 module 是否支持多例，主要是看到示例代码中有关生命周期部分的注释有提到多例，但是不清楚如何实现的。\n\n\n# dob\n\n\n\n * dobjs/dob\n * 要不要支持一下国产的 dob?\n\n理念与 mobx 相同，使用 proxy 让使用过程更流畅，数组不会搞成纯对象，有依赖注入最佳实践，还能配合 redux。\n\n只是看了看官网的示例代码，感觉和 mobx 非常像，api 一样，代码组织方式都基本是一样的。\n\n\n# xreact\n\n\n\n * reactive-react/xreact\n * fp, frp, observable, declarative, monadic, composable, reactivex, fantasyland\n\n这个项目应该类似 vue-rx，但是对于这种项目我个人理解价值不大。我的理解是像 rxjs 这种库，就像 jquery、lodash 一样，就是一种工具库。我们使用这些工具库也不需要专门的 react-jquery，react-lodash。 像 xreact，vue-rx 这种库，一般都是 opinionated library，提供自己的开发规范。当然如果认可这种开发规范，对开发效率应该是有提升的。但是我还是更愿意自己手写 rxjs 代码，就像在 angular 中一样。\n\n我硬着头皮看了看官方文档，比我想的要复杂得多，并没有像 vue-rx 那样是在 vue 基础上增加了很少的概念，xreact 增加的概念就比较多了。官方文档介绍了如何使用 xreact，一共分成 3 步：\n\n第一步：定义视图组件，也叫受控组件、展示组件、无状态组件\n\n这里还是 react 的概念，只不过对 props 有固定的要求，即必须含有 props.actions 属性，该属性包含了改变数据的所有方法。\n\n第二步：定义 plan\n\n这里开始出现 xreact 特有的概念了，plan 本身就是一个函数，只不过对入参和出参有固定的要求。\n\n入参是 intent$, 本身是一个流，其中的值就是 action。\n\n出参是一个对象，包含 update$ 和 actions 两个属性。update$ 类似于 redux 中的 reducer，actions 属性则是类似于 redux 中的 action creator\n\n这里需要注意第一步中定义组件时也有一个 actions，我的理解是这两个 actions 虽然有关联，但是不完全一致，其中 props.actions 更加像 redux 中的 store.dispatch(action)\n\n我看了一下项目的 package.json，本身是不依赖 redux 的，所以应该是自己实现了类似的 api，但是似乎没有发现类似 combinereducers 的函数。\n\n目前我看到的示例代码都是一个 plan 对应一个组件，似乎没有类似 combineplan 这样的函数来组合 plan。\n\n第三步：我认为就是链接 plan 和组件\n\n但是命名有点过于简约了。比如 x、 x。\n\n<x x={rx}>\n  <counter />\n</x>,\n\n猜测功能应该类似于\n\n<provider store={store}>\n  <counter />\n</provider>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n还有一点也需要注意：\n\nimport {x, x} from 'xreact/lib/x'\nconst counter = x(plan)(counterview)\n\n\n1\n2\n\n\n这里的 x 是一个函数，但是<x x={rx}>中的 x 只是一个 props 属性\n\n\n# stamen\n\n\n\n * forsigner/stamen\n * 简洁的 react 状态管理库 - stamen - 该文档太旧了，和最新版本的 api 不太一致\n * stamen 文档\n\nstamen 是一个 immutable react 状态管理库。api 非常简洁，内部采用 immer 实现 immutable 特性。\n\n我刚开始看的是知乎的文章，后来才看的是 github 主页，发现知乎的文章是 2018 年的，最新版本已经有很大变化了。\n\n只看最新版本的话，api 变得特别像 redux 和 dva 了。\n\n通过 createstore 返回 usestore 和 dispatch，其中 usestore 可以获取数据，dispatch 可以修改数据。\n\n多 store 的实现，依赖 import/export 来手动导入导出。\n\n组件依赖多个 store 的场景，需要重命名 usestore 和 dispatch。\n\n\n# redux-arena\n\n\n\n * hapood/redux-arena\n * 全新的 redux 模块化框架，redux-arena\n\n我的理解 redux-arena 的特点是依赖 react、redux、redux-saga、immutable 实现 state、saga、action、component 在组件级别可复用。\n\n如果把 state、saga、action 理解为服务的一种形式，这句话可以解释为实现服务在组件层面可复用。是不是有 angular 的味道了。\n\n\n# 各个库的特性总结\n\n * 如何定义服务\n   * 类\n   * 工厂函数\n   * 函数链式调用\n   * reducer\n * 如何组织/组合服务\n   * 依赖注入\n   * combinereducers\n   * 单例还是多例\n * 如何获取服务\n   * 自动初始化还是手动初始化\n   * 全局 provider+connect 还是手动 import 还是依赖注入\n * 数据如何驱动模板\n\n\n# vue 和 react 的数据驱动的区别\n\nimmutable 和 mutable react 是修改完数据后再次执行函数组件或者 render 函数来更新视图 vue 是视图订阅数据，数据变更后通知视图更新。 xxx 场景下，理论上 vue 的效率要比 react 高。\n\n\n# 其他参考文章\n\n * redux 与它的中间件：redux-thunk，redux-actions，redux-promise，redux-saga\n * redux 异步处理之 redux-thunk 和 redux-saga—阿楠\n * redux-thunk 和 redux-saga 的区别？\n * 异步方案选型 redux-saga 和 redux-thunk（async/await）\n * redux 源码解析\n * rectx - 通过引入基类提供默认的 setstate 方式管理数据\n * 除 redux 外，目前还有哪些状态管理解决方案？1\n * 除 redux 外，目前还有哪些状态管理解决方案？2\n * 除 redux 外，目前还有哪些状态管理解决方案？3\n * 除 redux 外，目前还有哪些状态管理解决方案？4\n * 两种状态管理模型\n * redux 数据流管理架构有什么致命缺陷,未来会如何改进？1\n * redux 数据流管理架构有什么致命缺陷,未来会如何改进？2\n * redux 数据流管理架构有什么致命缺陷,未来会如何改进？3\n * 鬼才！我居然把 vue3 的原理用到了 react 上？\n * vue 3 核心原理 -- reactivity 自己实现\n * react hooks 是否可以改为用类似 vue 3 composition api 的方式实现？1\n * react hooks 是否可以改为用类似 vue 3 composition api 的方式实现？2\n * react hooks 是否可以改为用类似 vue 3 composition api 的方式实现？3",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"前端框架浅显对比",frontmatter:{author:"kaokei",title:"前端框架浅显对比",date:"2021-12-19T16:52:54.000Z",permalink:"/pages/8b25d1/",sidebar:"auto",categories:["随笔","技术"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/framework-comparison.html",relativePath:"_posts/framework-comparison.md",key:"v-9f0855b6",path:"/pages/8b25d1/",headers:[{level:2,title:"vue、react 以及 Angular 对比",slug:"vue、react-以及-angular-对比",normalizedTitle:"vue、react 以及 angular 对比",charIndex:2},{level:2,title:"常见库的实现对比",slug:"常见库的实现对比",normalizedTitle:"常见库的实现对比",charIndex:4512},{level:2,title:"需要解决的问题",slug:"需要解决的问题",normalizedTitle:"需要解决的问题",charIndex:7726},{level:2,title:"vue 和 react 的数据驱动的区别",slug:"vue-和-react-的数据驱动的区别",normalizedTitle:"vue 和 react 的数据驱动的区别",charIndex:7825}],headersStr:"vue、react 以及 Angular 对比 常见库的实现对比 需要解决的问题 vue 和 react 的数据驱动的区别",content:"# vue、react 以及 Angular 对比\n\n我第一个接触的框架是 vue，在 vue 之前我用的是 jquery。\n\n这里可以先对比一下 jquery 是如何写代码的。其实关键还是数据和视图的同步工作。\n\n比如某个变量的值改变了（先暂时不管是怎么改变的），现在要把这个数据反应到视图上，就必须首先使用 jquery 获取到相应的 dom，然后修改 dom 的属性。如果是大范围的视图变化，可能还需要相应的前端模版技术配合，比如 underscore 或者 handlebars。\n\n如果用户点击了某个按钮，我们需要响应用户的点击事件。 前提是我们先要使用 jquery 注册 click 事件。 然后在事件内部，我们先获取 input 的数据，然后按照业务逻辑更新内存中的变量。 更新完变量同时后可能还需要更新其他依赖这个变量的 dom。\n\n综上，可以看出来前端的主要工作一直都是保持数据和视图的一致性。\n\n后来我开始使用 vue 来开发页面。整个过程完全不一样了。 我们定义初始数据，然后开发模版，并把数据和模版绑定。 同时在模版上监听事件。在事件处理器内部我们还是只需要更新数据即可。 整个过程完全不需要操作 dom。只要我们更新了数据，视图会自动更新。\n\n人们常说 vue 是数据驱动的。这里非常明显的能感觉到和 jquery 不一样的地方，并且大大提升了开发效率。可以非常明显的感受到数据驱动的优势。\n\n后来我又接触了 react，刚开始接触 react，最难的莫过于 jsx，搞不懂 jsx 和 js 之间的关系。后来理解之后就逐渐喜欢上 react 了。\n\n可以这样理解 jsx React.createElement(type, props, children); 这是一个函数调用，返回一个对象，就是一个普通的 js 对象，了解到这些就够了。 之后我就发现 jsx 代码就自动变成 js 代码了。该怎么写代码，就怎么写代码。 React 中没有新的概念，没有新的语法，完全就是在写 js 代码。\n\n在使用 vue 和 react 的过程中，不可避免的要使用到 vuex 和 redux。这种全局单一数据源的想法根深蒂固。 直到我接触到 angular。一开始我就在寻找 angular 中类似的单一数据源。但是我在项目中居然没有找到，接着我又去网上找到了 ngrx。 当然我还没有开始用上它，就发现了单一数据源完全不是必须的，我只需要定义好相应的 service，然后把该 service 注册到相应的组件上即可。 因为服务中是带有数据的。在组件中是可以直接获取到服务中的数据的。 所以如果我想要在全局所有组件中都使用该服务，那么就把该 service 注册到根组件； 如果是某个页面需要该 service，那么就注册到该路由组件即可； 如果只是某个表格组件需要该 service，那么就注册到该表格组件即可； 总之服务本身的定义是服务自己的事；至于服务具体的访问范围则完全取决于注册服务的位置。 而且服务也不一定就是单例的，在不同的地方多次注册，就意味着可以有多个实例。 更方便的是服务和服务之间也是可以互相注入的。\n\n再然后就是我想着能不能在 vue 和 react 中也实现一下依赖注入的能力，于是就有了 @kaokei/use-vue-service。至于 use-react-service 则还在开发中。\n\n类和函数\n\n我之前是非常喜欢函数，而不喜欢类的。有很多原因，比如函数在 js 中是第一位的。 没有什么是函数解决不了的，比如模块化 amd 和 commonjs 都依赖函数的闭包。 再一个就是函数可以很纯粹，没有副作用。 类的底层实现也不过是函数的语法糖。\n\n后来我发现某些场景还是类比较适合。甚至是唯一的选择。 比如我想要封装一些数据和方法。当然我可以采用工厂函数来生产新对象，该对象包含所有的数据和方法。 但是缺点是这些方法没有必要重复生产。 当然我们可以把这些方法提出来作为新生产的对象的原型，这样就可以复用这些方法了。 但是我们想要依赖装饰器的能力时，则只能使用类了。\n\nSOA\n\n先来看看什么是 soa，翻译过来就是面向服务的体系架构。关键的一个名词是服务。服务又是什么呢？\n\n服务是数据和方法的集合，并且数据和方法都是可选的。意味着可以是类，函数，字符串，数字，布尔值等等。\n\n但是在当前 ts 环境下，数据和方法的封装最好的方式还是类，再加上装饰器只支持类。所以在 ts 中类是服务最好的表现形式。 当然如果你只需要数据或者只需要方法，是不一定非得需要类。 关于函数装饰器，目前基本毫无希望了。\n\n类还有一个好处，在依赖注入中，我们需要 Key-Value，类可以既当作 Key，也可以当作 Value。 可以直接使用const countService = useService(CountService)获取服务。\n\n如果我们想要注入一个字符串http://test.com/，那么我们还要同时定义一个 Key，比如是const publicPath = 'PUBLIC_PATH'。 然后使用declareProviders([{provide: publicPath, useValue: 'http://test.com/'}])注册服务， 再使用const publicPathValue = useService(publicPath)获取服务\n\n领域驱动设计 可以参考这篇文章，非常有深度，虽然我也不能完全理解到位，但是我觉的非常有共鸣。\n\n注意一下数据驱动这个术语的不同含义，上面有提到 vue 是数据驱动的，我的理解是 vue 的组件是数据驱动模版的，数据变化了，模板会跟着更新。 而知乎文章里提到的数据驱动设计是相对于领域驱动设计的，说的不是一回事。 我的简单的理解是数据驱动设计是全局单一数据源，然后组件订阅该数据源部分数据。领域驱动设计重点区别在于不是全局的。而是聚焦于特定领域。 所谓特定领域则是特定的一些数据和方法的集合。比如学生服务 StudentService 是学生相关的数据和方法的集合。\n\n顺便再提一句我认为 angular 中 ngModule 绝对不是必需的。只不过是 angular 团队的一种选择而已，还是目前的一种选择。最新版的 angular11 已经开始支持可以不使用 ngModule 了。 只要分析一下 ngModule 的 3 个属性就能大概理解 ngModule 的作用了： declarations 声明当前 module 有哪些组件，指令，管道 exports 导出当前 module 的部分组件，指令，管道 imports 导入其它 module 导出的组件，指令，管道\n\n这些内容angular 官网上都有，每个字都能看的懂，但是却还是不太理解有什么用。 实际上可以简单的理解为 angular 在编译模板的时候，需要知道模板中出现的那些标签（准确的叫做选择器）到底对应哪个组件、指令或者管道。 只要参考一下 vue 中是怎么做的就更容易理解了，vue 中需要在组件中 components 属性注册当前组件依赖的其它组件。所以 vue 中的做法是在每一个组件上注册自己依赖的其他组件。\n\n但是在 angular 中则是在一个 module 中注册需要的组件。\n\n再来看看这篇文章，这里提供了一种思路可以做到自动化全局注册组件。全局注册也是有缺点的，比如没有使用到的组件也会被加载，组件重名问题。\n\n所以声明组件依赖有三种方式：组件本身，module，全局。只不过 angular 选择了 module 而已。然后 angular 又在 module 的基础上附加了其他功能，比如声明服务的 providers。回到问题本身，答案就是这是 angular 团队的选择而已，并不是必不可少的，也不是毫无缺点的。\n\n再对比一下 vue 和 react 中声明组件的区别，在 vue 中首先需要 import 组件，然后在 components 属性中注册组件。总共需要两步。 但是在 react 中则只需要 import 组件即可以使用了，这是因为 jsx 和 js 是作用域是一致的。所以我一直觉得 vue 中局部注册组件是毫无必要的，因为我都已经 import 了，为什么模板不能从当前作用域中寻找对应的组件呢？\n\n具体原因没有研究过，期待有人能告诉我一下。我个人猜测是和 vue 中组件名称比较混乱有关，有好几种格式。导致模板编译的时候不知道应该编译成那种形式的变量名？ 比如在 react 的 jsx 中遇到标签 UserInfo，那么组件名一定就是 UserInfo，而且 react 强制要求组件名首字母必须大写。但是在 vue 中则不一定了。导致编译成 render 函数时不能直接编译过来，现在还是通过标签名在 components 对象中去查找，而且会按照优先级依次判断各种格式的组件名，直到查找到组件为止。 createElement 源码链接 resolveAsset 源码链接\n\n但是都无所谓了，因为借助setup 提案，现在我们也不需要手动在 components 中注册组件了，只需要 import 相应的组件即可。\n\n当然在 vuex 中也是可以划分 module 的，此 module 和 angular 中的 module 不是一回事，它更像是 angular 中的 service。所以也可以说 vuex 也具有部分领域驱动的特性。 但是相比于 angular 中 service 的依赖注入的特点，显得不够灵活。\n\nvue 缺点\n\nvue 中注册局部 components 比较麻烦 vue 中 api 和语法比较多，总是记不住。=\n\ntemplate 和 jsx 区别？ 第一层：template 相比于拼接字符串有了很大的提升 第二层：jsx 是什么玩意？完全看不懂为啥能在模版里直接写 js 第三层：jsx 真香，template 显得太不灵活了 第四层：jsx 过于灵活了，导致代码逻辑混乱，完全没有做到 UI 和逻辑的分离。相反 template 只是做了它该做的事情。 第五层：jsx 和 template 都有它的优点。看个人喜好以及场景决定使用哪个。\n\ncomputed 和 watch 的区别\n\n这个在 mobx 中叫做 computed 和 reactions。 computed 是多个值计算出一个新的值，watch 则是观察一个值，然后触发一些副作用，这些副作用可以修改多个值。 说到这里不得不提的就是 rxjs 了，可以理解为 rxjs 就是 computed 和 reactions 的集合，但是更加强大。 比如 rxjs 中的流可以衍生出新的流，也可以多个流衍生出新的流。每个流都可以 subscribe 自己的副作用。\n\n\n# 常见库的实现对比\n\nreduxjs/redux\n\nredux 本身的概念比较简单，但是复杂的地方在于很难单独使用它，必须结合 react-redux 这样的连接库才能比较方便的工作。 这就意味着必须要同时掌握 redux 和 react-redux 才能顺利使用。\n\nconst store = createStore(someReducer);\nstore.subscribe(() => console.log(store.getState()));\nstore.dispatch({type: 'someType'});\n\n\n1\n2\n3\n\n\n最核心的 api 就是这三个了，当然比较关键的还有一点是 reducer 的定义。reducer 本身是一个纯函数，是和 redux 无关的。但是函数签名必须满足： (previousState, action) => newState，其实这也是和类所表达的服务是一个东西。是数据和方法的封装。其中 state 部分就是数据。action 部分就是方法。只不过这里的 action 部分使用的是 type，类型是字符串而已。\n\n尤其要注意其中的 state 部分，虽然说 reducer 是一个纯函数，但其实并不够纯，以为 initalState 必然属于闭包中的一个变量值。\n\n如果不使用 react-redux，可以参考这个简单的例子。 这里还有 redux 官网其他例子。\n\n使用 reduce 表达服务 使用 combineReducers 来组合服务 可以读取 store 中的数据，以及通过 dispatch 修改数据，但是数据并不会自动更新模板\n\nreduxjs/react-redux\n\n基于 redux 的链接 react 和 redux 的库，基本特性和 redux 一致，主要是解决了 store 中数据变化时，模版也会自动更新。\n\n主要 api 是 connect 和 Provider。 Provider 通过 context 提供了全局的 store，是为了 conenct 服务的。在 connect 中可以随时通过 context 获取到 store。从而读取数据。 connect 本身是是一个函数，该函数返回值是一个高阶组件。注意高阶组件是一个函数，而不是组件。这个函数可以包裹我们自己的组件。 该高阶组件可以通过闭包拿到 connect 提供的 mapStateToProps 和 mapDispatchToProps，通过这两个函数再加上 context 中的 store，就可以获取到相应数据和方法了。 其中数据部分是：store+mapStateToProps=>newState，其中方法部分是：store.dispatch+mapDispatchToProps=>newActions。 目前为止还只能解决组件第一次渲染的时候获取数据的问题，关键还是要解决数据变化的时候，组件如何响应更新。\n\n实际上还是需要依赖 store.subscribe 这个 api，会在组建 mounted 时注册一个监听器，卸载组件时取消监听器。 该监听器每次会重新从 store 获取数据，并和缓存中的数据做对比，如果数据有变化，那么执行 setState 操作，从而更新组件。\n\n缺点是模版代码很多，而且在 reducer 中已经定义了数据和方法了，在 connect 中还是需要再次定义数据和方法。\n\nmobxjs/mobx mobxjs/mobx-react mobx 官方例子\n\nmobx 和 vue 非常像，可以说大部分能力 vue 已经天生支持了，剩下的就是如何组织代码而已。参考官方文档。\n\n 1. 第一步：定义可观察数据，可以是对象或者类。这里依赖 mobx 的 observable 这个 API。\n 2. 第二步：定义组件。这里依赖 mobx-react 的 observer 这个 API。\n 3. 第三步其实和 mobx 就没有关系了，我们只要改变了数据，组件就会自动更新。\n\n再对比 vue3 中的实现，第一步其实就是 reactive 这个 api，第二步中 vue 组件默认就是会观察 reactive 数据的，所以也不需要 observer 这个 API。\n\n参考这个demo\n\n 1. 采用类来定义服务，但是需要具体声明各个属性和方法的性质，比如@observable @computed @action\n 2. 然后导出一个类的实例，这里就能看出来至少在这个项目中服务都是单例的，如果需要多例，就需要自己手动 new 多个实例。\n 3. 然后在根组件使用 Provider\n 4. 然后在组件中就可以@inject('articlesStore')类似这样注入服务\n\n参考这个demo 这里没有使用 Provider，而是通过 props 从根组件一层层传递服务\n\nmobxjs/mobx-state-tree\n\nmobx-state-tree 虽然是基于 mobx 的，但是定位应该是和 mobx 是一样的，只不过在于组织代码方面有所区别。\n\n参考这个例子\n\n可以发现居然还可以和 redux 相结合，虽然我觉得有点脱裤子放屁了。这里面有很多的重复性工作。 依赖 redux 的 Provider 来提供全局单一数据源，然后依赖 connect 订阅数据源。 在定义 mobx-state-tree 的模型的 actions 时，需要 actions 常量作为方法名。 在 mapDispatchToProps 时也需要 actions 常量生成方法名，关键是组件中的 props 还是需要定义一摸一样的方法名来接受 props。 总之就是非常繁琐，而且耦合非常严重，但是确实可以工作，而且能非常明确的看出来 mobx-state-tree 具体做了什么工作，没有做什么工作。 还有一点就是 mobx-state-tree 首先是定义了模型（model），这里的 model 可以看作服务，数据和方法的集合。但是实际使用时，还是需要我们手动初始化的。 const someStore = SomeStore.create(initialState)\n\n参考这个例子 这个例子可以明显看出来 mobx-state-tree 是代替了 mobx，并且配合 mobx-react 来工作的。 上面有分析过，主要就是 Provider 和 inject 注入 store，并且 mobx-state-tree 是依赖 mobx 的，所以数据本身也是响应式的。 可以明显看出来，mobx-state-tree 和 mobx 的区别在于组织代码的区别。 mobx 是采用类来组织数据和方法。 mobx-state-tree 是基于自带的类型定义采用链式方法调用来定义数据和方法。并且 Model 本身就是类型，也就意味着 Model 是可以嵌套的，所以这也是 mobx-state-tree 名称的来源，因为 Model 就是 state，嵌套之后就会形成一颗树。但是 mobx 中的类则不能相互嵌套形成复杂的“类树”。\n\nreduxjs/redux-thunk redux-saga/redux-saga redux-observable/redux-observable\n\ndvajs/dva\n\nvuejs/composition-api concentjs/concent concent 知乎专栏 yisar/doux\n\nReactiveX/rxjs vuejs/vue-rx\n\nimmerjs/immer\n\n这个库不是做状态管理的，只是提供了 produce 这个函数来实现 immutable 特性。\n\n\n# 需要解决的问题\n\n单例和多例 服务的边界-数据和方法 类 reducer+connect 数据驱动模版/组件 Provider 服务如何管理/组合 依赖注入 combineReducers\n\n\n# vue 和 react 的数据驱动的区别",normalizedContent:"# vue、react 以及 angular 对比\n\n我第一个接触的框架是 vue，在 vue 之前我用的是 jquery。\n\n这里可以先对比一下 jquery 是如何写代码的。其实关键还是数据和视图的同步工作。\n\n比如某个变量的值改变了（先暂时不管是怎么改变的），现在要把这个数据反应到视图上，就必须首先使用 jquery 获取到相应的 dom，然后修改 dom 的属性。如果是大范围的视图变化，可能还需要相应的前端模版技术配合，比如 underscore 或者 handlebars。\n\n如果用户点击了某个按钮，我们需要响应用户的点击事件。 前提是我们先要使用 jquery 注册 click 事件。 然后在事件内部，我们先获取 input 的数据，然后按照业务逻辑更新内存中的变量。 更新完变量同时后可能还需要更新其他依赖这个变量的 dom。\n\n综上，可以看出来前端的主要工作一直都是保持数据和视图的一致性。\n\n后来我开始使用 vue 来开发页面。整个过程完全不一样了。 我们定义初始数据，然后开发模版，并把数据和模版绑定。 同时在模版上监听事件。在事件处理器内部我们还是只需要更新数据即可。 整个过程完全不需要操作 dom。只要我们更新了数据，视图会自动更新。\n\n人们常说 vue 是数据驱动的。这里非常明显的能感觉到和 jquery 不一样的地方，并且大大提升了开发效率。可以非常明显的感受到数据驱动的优势。\n\n后来我又接触了 react，刚开始接触 react，最难的莫过于 jsx，搞不懂 jsx 和 js 之间的关系。后来理解之后就逐渐喜欢上 react 了。\n\n可以这样理解 jsx react.createelement(type, props, children); 这是一个函数调用，返回一个对象，就是一个普通的 js 对象，了解到这些就够了。 之后我就发现 jsx 代码就自动变成 js 代码了。该怎么写代码，就怎么写代码。 react 中没有新的概念，没有新的语法，完全就是在写 js 代码。\n\n在使用 vue 和 react 的过程中，不可避免的要使用到 vuex 和 redux。这种全局单一数据源的想法根深蒂固。 直到我接触到 angular。一开始我就在寻找 angular 中类似的单一数据源。但是我在项目中居然没有找到，接着我又去网上找到了 ngrx。 当然我还没有开始用上它，就发现了单一数据源完全不是必须的，我只需要定义好相应的 service，然后把该 service 注册到相应的组件上即可。 因为服务中是带有数据的。在组件中是可以直接获取到服务中的数据的。 所以如果我想要在全局所有组件中都使用该服务，那么就把该 service 注册到根组件； 如果是某个页面需要该 service，那么就注册到该路由组件即可； 如果只是某个表格组件需要该 service，那么就注册到该表格组件即可； 总之服务本身的定义是服务自己的事；至于服务具体的访问范围则完全取决于注册服务的位置。 而且服务也不一定就是单例的，在不同的地方多次注册，就意味着可以有多个实例。 更方便的是服务和服务之间也是可以互相注入的。\n\n再然后就是我想着能不能在 vue 和 react 中也实现一下依赖注入的能力，于是就有了 @kaokei/use-vue-service。至于 use-react-service 则还在开发中。\n\n类和函数\n\n我之前是非常喜欢函数，而不喜欢类的。有很多原因，比如函数在 js 中是第一位的。 没有什么是函数解决不了的，比如模块化 amd 和 commonjs 都依赖函数的闭包。 再一个就是函数可以很纯粹，没有副作用。 类的底层实现也不过是函数的语法糖。\n\n后来我发现某些场景还是类比较适合。甚至是唯一的选择。 比如我想要封装一些数据和方法。当然我可以采用工厂函数来生产新对象，该对象包含所有的数据和方法。 但是缺点是这些方法没有必要重复生产。 当然我们可以把这些方法提出来作为新生产的对象的原型，这样就可以复用这些方法了。 但是我们想要依赖装饰器的能力时，则只能使用类了。\n\nsoa\n\n先来看看什么是 soa，翻译过来就是面向服务的体系架构。关键的一个名词是服务。服务又是什么呢？\n\n服务是数据和方法的集合，并且数据和方法都是可选的。意味着可以是类，函数，字符串，数字，布尔值等等。\n\n但是在当前 ts 环境下，数据和方法的封装最好的方式还是类，再加上装饰器只支持类。所以在 ts 中类是服务最好的表现形式。 当然如果你只需要数据或者只需要方法，是不一定非得需要类。 关于函数装饰器，目前基本毫无希望了。\n\n类还有一个好处，在依赖注入中，我们需要 key-value，类可以既当作 key，也可以当作 value。 可以直接使用const countservice = useservice(countservice)获取服务。\n\n如果我们想要注入一个字符串http://test.com/，那么我们还要同时定义一个 key，比如是const publicpath = 'public_path'。 然后使用declareproviders([{provide: publicpath, usevalue: 'http://test.com/'}])注册服务， 再使用const publicpathvalue = useservice(publicpath)获取服务\n\n领域驱动设计 可以参考这篇文章，非常有深度，虽然我也不能完全理解到位，但是我觉的非常有共鸣。\n\n注意一下数据驱动这个术语的不同含义，上面有提到 vue 是数据驱动的，我的理解是 vue 的组件是数据驱动模版的，数据变化了，模板会跟着更新。 而知乎文章里提到的数据驱动设计是相对于领域驱动设计的，说的不是一回事。 我的简单的理解是数据驱动设计是全局单一数据源，然后组件订阅该数据源部分数据。领域驱动设计重点区别在于不是全局的。而是聚焦于特定领域。 所谓特定领域则是特定的一些数据和方法的集合。比如学生服务 studentservice 是学生相关的数据和方法的集合。\n\n顺便再提一句我认为 angular 中 ngmodule 绝对不是必需的。只不过是 angular 团队的一种选择而已，还是目前的一种选择。最新版的 angular11 已经开始支持可以不使用 ngmodule 了。 只要分析一下 ngmodule 的 3 个属性就能大概理解 ngmodule 的作用了： declarations 声明当前 module 有哪些组件，指令，管道 exports 导出当前 module 的部分组件，指令，管道 imports 导入其它 module 导出的组件，指令，管道\n\n这些内容angular 官网上都有，每个字都能看的懂，但是却还是不太理解有什么用。 实际上可以简单的理解为 angular 在编译模板的时候，需要知道模板中出现的那些标签（准确的叫做选择器）到底对应哪个组件、指令或者管道。 只要参考一下 vue 中是怎么做的就更容易理解了，vue 中需要在组件中 components 属性注册当前组件依赖的其它组件。所以 vue 中的做法是在每一个组件上注册自己依赖的其他组件。\n\n但是在 angular 中则是在一个 module 中注册需要的组件。\n\n再来看看这篇文章，这里提供了一种思路可以做到自动化全局注册组件。全局注册也是有缺点的，比如没有使用到的组件也会被加载，组件重名问题。\n\n所以声明组件依赖有三种方式：组件本身，module，全局。只不过 angular 选择了 module 而已。然后 angular 又在 module 的基础上附加了其他功能，比如声明服务的 providers。回到问题本身，答案就是这是 angular 团队的选择而已，并不是必不可少的，也不是毫无缺点的。\n\n再对比一下 vue 和 react 中声明组件的区别，在 vue 中首先需要 import 组件，然后在 components 属性中注册组件。总共需要两步。 但是在 react 中则只需要 import 组件即可以使用了，这是因为 jsx 和 js 是作用域是一致的。所以我一直觉得 vue 中局部注册组件是毫无必要的，因为我都已经 import 了，为什么模板不能从当前作用域中寻找对应的组件呢？\n\n具体原因没有研究过，期待有人能告诉我一下。我个人猜测是和 vue 中组件名称比较混乱有关，有好几种格式。导致模板编译的时候不知道应该编译成那种形式的变量名？ 比如在 react 的 jsx 中遇到标签 userinfo，那么组件名一定就是 userinfo，而且 react 强制要求组件名首字母必须大写。但是在 vue 中则不一定了。导致编译成 render 函数时不能直接编译过来，现在还是通过标签名在 components 对象中去查找，而且会按照优先级依次判断各种格式的组件名，直到查找到组件为止。 createelement 源码链接 resolveasset 源码链接\n\n但是都无所谓了，因为借助setup 提案，现在我们也不需要手动在 components 中注册组件了，只需要 import 相应的组件即可。\n\n当然在 vuex 中也是可以划分 module 的，此 module 和 angular 中的 module 不是一回事，它更像是 angular 中的 service。所以也可以说 vuex 也具有部分领域驱动的特性。 但是相比于 angular 中 service 的依赖注入的特点，显得不够灵活。\n\nvue 缺点\n\nvue 中注册局部 components 比较麻烦 vue 中 api 和语法比较多，总是记不住。=\n\ntemplate 和 jsx 区别？ 第一层：template 相比于拼接字符串有了很大的提升 第二层：jsx 是什么玩意？完全看不懂为啥能在模版里直接写 js 第三层：jsx 真香，template 显得太不灵活了 第四层：jsx 过于灵活了，导致代码逻辑混乱，完全没有做到 ui 和逻辑的分离。相反 template 只是做了它该做的事情。 第五层：jsx 和 template 都有它的优点。看个人喜好以及场景决定使用哪个。\n\ncomputed 和 watch 的区别\n\n这个在 mobx 中叫做 computed 和 reactions。 computed 是多个值计算出一个新的值，watch 则是观察一个值，然后触发一些副作用，这些副作用可以修改多个值。 说到这里不得不提的就是 rxjs 了，可以理解为 rxjs 就是 computed 和 reactions 的集合，但是更加强大。 比如 rxjs 中的流可以衍生出新的流，也可以多个流衍生出新的流。每个流都可以 subscribe 自己的副作用。\n\n\n# 常见库的实现对比\n\nreduxjs/redux\n\nredux 本身的概念比较简单，但是复杂的地方在于很难单独使用它，必须结合 react-redux 这样的连接库才能比较方便的工作。 这就意味着必须要同时掌握 redux 和 react-redux 才能顺利使用。\n\nconst store = createstore(somereducer);\nstore.subscribe(() => console.log(store.getstate()));\nstore.dispatch({type: 'sometype'});\n\n\n1\n2\n3\n\n\n最核心的 api 就是这三个了，当然比较关键的还有一点是 reducer 的定义。reducer 本身是一个纯函数，是和 redux 无关的。但是函数签名必须满足： (previousstate, action) => newstate，其实这也是和类所表达的服务是一个东西。是数据和方法的封装。其中 state 部分就是数据。action 部分就是方法。只不过这里的 action 部分使用的是 type，类型是字符串而已。\n\n尤其要注意其中的 state 部分，虽然说 reducer 是一个纯函数，但其实并不够纯，以为 initalstate 必然属于闭包中的一个变量值。\n\n如果不使用 react-redux，可以参考这个简单的例子。 这里还有 redux 官网其他例子。\n\n使用 reduce 表达服务 使用 combinereducers 来组合服务 可以读取 store 中的数据，以及通过 dispatch 修改数据，但是数据并不会自动更新模板\n\nreduxjs/react-redux\n\n基于 redux 的链接 react 和 redux 的库，基本特性和 redux 一致，主要是解决了 store 中数据变化时，模版也会自动更新。\n\n主要 api 是 connect 和 provider。 provider 通过 context 提供了全局的 store，是为了 conenct 服务的。在 connect 中可以随时通过 context 获取到 store。从而读取数据。 connect 本身是是一个函数，该函数返回值是一个高阶组件。注意高阶组件是一个函数，而不是组件。这个函数可以包裹我们自己的组件。 该高阶组件可以通过闭包拿到 connect 提供的 mapstatetoprops 和 mapdispatchtoprops，通过这两个函数再加上 context 中的 store，就可以获取到相应数据和方法了。 其中数据部分是：store+mapstatetoprops=>newstate，其中方法部分是：store.dispatch+mapdispatchtoprops=>newactions。 目前为止还只能解决组件第一次渲染的时候获取数据的问题，关键还是要解决数据变化的时候，组件如何响应更新。\n\n实际上还是需要依赖 store.subscribe 这个 api，会在组建 mounted 时注册一个监听器，卸载组件时取消监听器。 该监听器每次会重新从 store 获取数据，并和缓存中的数据做对比，如果数据有变化，那么执行 setstate 操作，从而更新组件。\n\n缺点是模版代码很多，而且在 reducer 中已经定义了数据和方法了，在 connect 中还是需要再次定义数据和方法。\n\nmobxjs/mobx mobxjs/mobx-react mobx 官方例子\n\nmobx 和 vue 非常像，可以说大部分能力 vue 已经天生支持了，剩下的就是如何组织代码而已。参考官方文档。\n\n 1. 第一步：定义可观察数据，可以是对象或者类。这里依赖 mobx 的 observable 这个 api。\n 2. 第二步：定义组件。这里依赖 mobx-react 的 observer 这个 api。\n 3. 第三步其实和 mobx 就没有关系了，我们只要改变了数据，组件就会自动更新。\n\n再对比 vue3 中的实现，第一步其实就是 reactive 这个 api，第二步中 vue 组件默认就是会观察 reactive 数据的，所以也不需要 observer 这个 api。\n\n参考这个demo\n\n 1. 采用类来定义服务，但是需要具体声明各个属性和方法的性质，比如@observable @computed @action\n 2. 然后导出一个类的实例，这里就能看出来至少在这个项目中服务都是单例的，如果需要多例，就需要自己手动 new 多个实例。\n 3. 然后在根组件使用 provider\n 4. 然后在组件中就可以@inject('articlesstore')类似这样注入服务\n\n参考这个demo 这里没有使用 provider，而是通过 props 从根组件一层层传递服务\n\nmobxjs/mobx-state-tree\n\nmobx-state-tree 虽然是基于 mobx 的，但是定位应该是和 mobx 是一样的，只不过在于组织代码方面有所区别。\n\n参考这个例子\n\n可以发现居然还可以和 redux 相结合，虽然我觉得有点脱裤子放屁了。这里面有很多的重复性工作。 依赖 redux 的 provider 来提供全局单一数据源，然后依赖 connect 订阅数据源。 在定义 mobx-state-tree 的模型的 actions 时，需要 actions 常量作为方法名。 在 mapdispatchtoprops 时也需要 actions 常量生成方法名，关键是组件中的 props 还是需要定义一摸一样的方法名来接受 props。 总之就是非常繁琐，而且耦合非常严重，但是确实可以工作，而且能非常明确的看出来 mobx-state-tree 具体做了什么工作，没有做什么工作。 还有一点就是 mobx-state-tree 首先是定义了模型（model），这里的 model 可以看作服务，数据和方法的集合。但是实际使用时，还是需要我们手动初始化的。 const somestore = somestore.create(initialstate)\n\n参考这个例子 这个例子可以明显看出来 mobx-state-tree 是代替了 mobx，并且配合 mobx-react 来工作的。 上面有分析过，主要就是 provider 和 inject 注入 store，并且 mobx-state-tree 是依赖 mobx 的，所以数据本身也是响应式的。 可以明显看出来，mobx-state-tree 和 mobx 的区别在于组织代码的区别。 mobx 是采用类来组织数据和方法。 mobx-state-tree 是基于自带的类型定义采用链式方法调用来定义数据和方法。并且 model 本身就是类型，也就意味着 model 是可以嵌套的，所以这也是 mobx-state-tree 名称的来源，因为 model 就是 state，嵌套之后就会形成一颗树。但是 mobx 中的类则不能相互嵌套形成复杂的“类树”。\n\nreduxjs/redux-thunk redux-saga/redux-saga redux-observable/redux-observable\n\ndvajs/dva\n\nvuejs/composition-api concentjs/concent concent 知乎专栏 yisar/doux\n\nreactivex/rxjs vuejs/vue-rx\n\nimmerjs/immer\n\n这个库不是做状态管理的，只是提供了 produce 这个函数来实现 immutable 特性。\n\n\n# 需要解决的问题\n\n单例和多例 服务的边界-数据和方法 类 reducer+connect 数据驱动模版/组件 provider 服务如何管理/组合 依赖注入 combinereducers\n\n\n# vue 和 react 的数据驱动的区别",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"friend",frontmatter:{title:"friend",date:"2022-02-17T21:14:09.000Z",permalink:"/friends/",article:!1,sidebar:!1,showSidebar:!1},regularPath:"/_posts/friend.html",relativePath:"_posts/friend.md",key:"v-75939a25",path:"/friends/",headers:[{level:3,title:"友链申请",slug:"友链申请",normalizedTitle:"友链申请",charIndex:5030}],headersStr:"友链申请",content:'麋鹿鲁哟\n\n大道至简，知易行难\n\nXAOXUU\n\n#IOS #Volantis主题作者\n\nlookroot的个人空间\n\n寻求理想和显示的平衡\n\n平凡的你我\n\n理想成为大牛的\n小陈同学\n\nznote\n\n荷尽已无擎雨盖，\n菊残犹有傲霜枝。\n\n全栈软件开发直通车\n\n全栈软件开发技术博客，\n从小白到大神!\n\n易良同学的博客\n\n正在努力！\n\n永远的救赎者\n\n知者减半，省者全无。\n\n辰旭博客\n\n凤鸣初阳，百鸟朝凰\n\nJokerM\'s Palace\n\nTake your heart\n\nSaul.J.Wu\n\n立身之本，不在高低。\n\nLake\'s blog\n\n不积跬步，无以至千里；不积小流，无以成江海。\n\nCubik的小站\n\nRECOMMENDED BY DR.CREATIVE\n\nx·π\n\n为开发者量身制作的技术博客和知识库管理平台。\n\n眼里有光\n\n道阻且长，行则将至\n\nHeo\n\n爱折腾的设计师\n\nChuyuxuan\n\n临渊羡鱼，不如退而结网\n\n全栈杂货站\n\n千里万里杂货站里，天青色等烟雨，而我在等你。\n\n小鱼博客\n\n总是半途而废的废柴\n\n大胡子\n\n记录你我，分享精彩。\n\n嘟先生学WebGL\n\n流水不争先，争的是滔滔不绝。\n\n@小右_\n\n学而不厌 不耻下问\n\n途中的树\n\n走出自己的傲慢，承认自己的局限。\n\nHaobo\'s Blog\n\n半只脚跨入炼丹师的大门的新人\n\n小胖墩er\n\n迟到总比不到的好，所以好好加油吧。\n\nJoseph Z.\n\nJoseph Z.的小站\n\n- name: 麋鹿鲁哟\n  desc: 大道至简，知易行难\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200122153807.jpg # 可选\n  link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgColor: "#CBEAFA" # 可选，默认var(--bodyBg)。颜色值有#号时请添加单引号\n  textColor: "#6854A1" # 可选，默认var(--textColor)\n- name: XAOXUU\n  desc: "#IOS #Volantis主题作者"\n  avatar: https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png\n  link: https://xaoxuu.com\n  bgColor: "#B9D59C"\n  textColor: "#3B551F"\n- name: lookroot的个人空间\n  desc: 寻求理想和显示的平衡\n  avatar: https://www.lookroot.cn/logo.png\n  link: https://www.lookroot.cn/\n  bgColor: "#B7DBFF"\n  textColor: "#294D71"\n- name: 平凡的你我\n  desc: 理想成为大牛的<br/>小陈同学\n  avatar: https://reinness.com/static/avatar.png\n  link: https://reinness.com\n  bgColor: "#FFE5B4"\n  textColor: "#A05F2C"\n- name: znote\n  desc: 荷尽已无擎雨盖，<br/>菊残犹有傲霜枝。\n  avatar: https://zpj80231.gitee.io/znote/vuepress/head-fish.jpg\n  link: https://zpj80231.gitee.io/znote/\n  bgColor: "#FCE5BF"\n  textColor: "#7B2532"\n- name: 全栈软件开发直通车\n  desc: 全栈软件开发技术博客，<br/>从小白到大神!\n  avatar: https://gitee.com/wangshibiao/blog_picBed2/raw/master/images/20200806151030.png\n  link: https://sofineday.com\n  bgColor: "#FBEBEC"\n  textColor: "#603420"\n- name: 易良同学的博客\n  desc: 正在努力！\n  avatar: https://yiliang.site/assets/images/avatar.jpeg\n  link: https://yiliang.site\n  bgColor: "#FFEFE2"\n  textColor: "#A05F2C"\n- name: 永远的救赎者\n  desc: 知者减半，省者全无。\n  avatar: https://i.loli.net/2020/08/10/PkQMGL6pATW1vBg.jpg\n  link: http://www.yuanchengcheng.vip/\n  bgColor: "#FBEBEC"\n  textColor: "#603420"\n- name: 辰旭博客\n  desc: 凤鸣初阳，百鸟朝凰\n  avatar: https://s1.ax1x.com/2020/08/09/aoLTDx.png\n  link: https://kareny.cn\n  bgColor: "#FFCEDE"\n  textColor: "#621529"\n- name: JokerM\'s Palace\n  desc: Take your heart\n  avatar: https://jokerm.com/wp-content/uploads/2020/09/jmflogo.png\n  link: https://jokerm.com/\n- name: Saul.J.Wu\n  desc: 立身之本，不在高低。\n  avatar: https://gitee.com/SaulJWu/blog-images/raw/master/images/20210627222322.jpg\n  link: https://sauljwu.github.io/\n- name: Lake\'s blog\n  desc: 不积跬步，无以至千里；不积小流，无以成江海。\n  avatar: https://cdn.jsdelivr.net/gh/taixingyiji/image_store@main/blog/logo/img.png\n  link: https://taixingyiji.com/\n- name: Cubik的小站\n  desc: RECOMMENDED BY DR.CREATIVE\n  avatar: https://cdn.jsdelivr.net/gh/Cubik65536/cubik-favicons@main/CubikLogo.png\n  link: https://www.cubik65536.top/\n- name: x·π\n  desc: 为开发者量身制作的技术博客和知识库管理平台。\n  avatar: https://cdn.jsdelivr.net/gh/Ezuy-Lee/RainzeDrawingBed/media/logo.png\n  link: https://ezuy-lee.github.io/xpai/\n- name: 眼里有光\n  desc: 道阻且长，行则将至\n  avatar: https://icooloop.gitee.io/img/logo.jpg\n  link: https://icooloop.gitee.io/\n- name: Heo\n  desc: 爱折腾的设计师\n  link: https://blog.zhheo.com/\n  avatar: https://blog.zhheo.com/img/avatar.png\n- name: Chuyuxuan\n  desc: 临渊羡鱼，不如退而结网\n  link: https://blog.chuyuxuan.top/\n  avatar: http://blog.chuyuxuan.top/img/avatar1.jpg\n- name: 全栈杂货站\n  desc: 千里万里杂货站里，天青色等烟雨，而我在等你。\n  avatar: http://cdn.tea-culture.top/tech/images/avatar/3.jpg\n  link: http://tech.tea-culture.top/\n- name: 小鱼博客\n  desc: 总是半途而废的废柴\n  avatar: https://cdn.jsdelivr.net/gh/xiaoyu-666/image_store/blog/minion.png\n  link: https://xiaoyu-666.github.io/\n- name: 大胡子\n  desc: 记录你我，分享精彩。\n  avatar: https://photo.jakehu.cn/favicon.png\n  link: https://www.jakehu.cn\n- name: 嘟先生学WebGL\n  desc: 流水不争先，争的是滔滔不绝。\n  avatar: https://joy1412.cn/img/dudu.jpeg\n  link: https://joy1412.cn\n- name: "@小右_"\n  desc: 学而不厌 不耻下问\n  avatar: https://lordblog.cn/upload/2021/05/logo%20(4)-742f1f7e15db44a1b3140035104ea239.png\n  link: https://lordblog.cn/\n- name: 途中的树\n  desc: 走出自己的傲慢，承认自己的局限。\n  avatar: https://zkpeace.com/blog/img/avatar.jpg\n  link: https://zkpeace.com/\n- name: Haobo\'s Blog\n  link: https://discover304.top/\n  avatar: https://discover304.top/img/head.png\n  desc: 半只脚跨入炼丹师的大门的新人\n- name: 小胖墩er\n  desc: 迟到总比不到的好，所以好好加油吧。\n  avatar: https://cdn.jsdelivr.net/gh/Chubby-Duner/image-hosting@master/blog/logo.jpeg\n  link: https://chubbyduner.top\n- name: Joseph Z.\n  desc: Joseph Z.的小站\n  avatar: https://josephz.top/res/joseph.jpg\n  link: https://josephz.top/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n\n\n\n# 友链申请\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: kaokei\'s blog # 昵称\n  desc: 项目文档，学习笔记，游戏，demo # 介绍\n  avatar: https://cdn.jsdelivr.net/gh/kaokei/static-cdn/logo/white/logo@512.png # 头像\n  link: https://kaokei.com/ # 链接\n\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~',normalizedContent:'麋鹿鲁哟\n\n大道至简，知易行难\n\nxaoxuu\n\n#ios #volantis主题作者\n\nlookroot的个人空间\n\n寻求理想和显示的平衡\n\n平凡的你我\n\n理想成为大牛的\n小陈同学\n\nznote\n\n荷尽已无擎雨盖，\n菊残犹有傲霜枝。\n\n全栈软件开发直通车\n\n全栈软件开发技术博客，\n从小白到大神!\n\n易良同学的博客\n\n正在努力！\n\n永远的救赎者\n\n知者减半，省者全无。\n\n辰旭博客\n\n凤鸣初阳，百鸟朝凰\n\njokerm\'s palace\n\ntake your heart\n\nsaul.j.wu\n\n立身之本，不在高低。\n\nlake\'s blog\n\n不积跬步，无以至千里；不积小流，无以成江海。\n\ncubik的小站\n\nrecommended by dr.creative\n\nx·π\n\n为开发者量身制作的技术博客和知识库管理平台。\n\n眼里有光\n\n道阻且长，行则将至\n\nheo\n\n爱折腾的设计师\n\nchuyuxuan\n\n临渊羡鱼，不如退而结网\n\n全栈杂货站\n\n千里万里杂货站里，天青色等烟雨，而我在等你。\n\n小鱼博客\n\n总是半途而废的废柴\n\n大胡子\n\n记录你我，分享精彩。\n\n嘟先生学webgl\n\n流水不争先，争的是滔滔不绝。\n\n@小右_\n\n学而不厌 不耻下问\n\n途中的树\n\n走出自己的傲慢，承认自己的局限。\n\nhaobo\'s blog\n\n半只脚跨入炼丹师的大门的新人\n\n小胖墩er\n\n迟到总比不到的好，所以好好加油吧。\n\njoseph z.\n\njoseph z.的小站\n\n- name: 麋鹿鲁哟\n  desc: 大道至简，知易行难\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200122153807.jpg # 可选\n  link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgcolor: "#cbeafa" # 可选，默认var(--bodybg)。颜色值有#号时请添加单引号\n  textcolor: "#6854a1" # 可选，默认var(--textcolor)\n- name: xaoxuu\n  desc: "#ios #volantis主题作者"\n  avatar: https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png\n  link: https://xaoxuu.com\n  bgcolor: "#b9d59c"\n  textcolor: "#3b551f"\n- name: lookroot的个人空间\n  desc: 寻求理想和显示的平衡\n  avatar: https://www.lookroot.cn/logo.png\n  link: https://www.lookroot.cn/\n  bgcolor: "#b7dbff"\n  textcolor: "#294d71"\n- name: 平凡的你我\n  desc: 理想成为大牛的<br/>小陈同学\n  avatar: https://reinness.com/static/avatar.png\n  link: https://reinness.com\n  bgcolor: "#ffe5b4"\n  textcolor: "#a05f2c"\n- name: znote\n  desc: 荷尽已无擎雨盖，<br/>菊残犹有傲霜枝。\n  avatar: https://zpj80231.gitee.io/znote/vuepress/head-fish.jpg\n  link: https://zpj80231.gitee.io/znote/\n  bgcolor: "#fce5bf"\n  textcolor: "#7b2532"\n- name: 全栈软件开发直通车\n  desc: 全栈软件开发技术博客，<br/>从小白到大神!\n  avatar: https://gitee.com/wangshibiao/blog_picbed2/raw/master/images/20200806151030.png\n  link: https://sofineday.com\n  bgcolor: "#fbebec"\n  textcolor: "#603420"\n- name: 易良同学的博客\n  desc: 正在努力！\n  avatar: https://yiliang.site/assets/images/avatar.jpeg\n  link: https://yiliang.site\n  bgcolor: "#ffefe2"\n  textcolor: "#a05f2c"\n- name: 永远的救赎者\n  desc: 知者减半，省者全无。\n  avatar: https://i.loli.net/2020/08/10/pkqmgl6patw1vbg.jpg\n  link: http://www.yuanchengcheng.vip/\n  bgcolor: "#fbebec"\n  textcolor: "#603420"\n- name: 辰旭博客\n  desc: 凤鸣初阳，百鸟朝凰\n  avatar: https://s1.ax1x.com/2020/08/09/aoltdx.png\n  link: https://kareny.cn\n  bgcolor: "#ffcede"\n  textcolor: "#621529"\n- name: jokerm\'s palace\n  desc: take your heart\n  avatar: https://jokerm.com/wp-content/uploads/2020/09/jmflogo.png\n  link: https://jokerm.com/\n- name: saul.j.wu\n  desc: 立身之本，不在高低。\n  avatar: https://gitee.com/sauljwu/blog-images/raw/master/images/20210627222322.jpg\n  link: https://sauljwu.github.io/\n- name: lake\'s blog\n  desc: 不积跬步，无以至千里；不积小流，无以成江海。\n  avatar: https://cdn.jsdelivr.net/gh/taixingyiji/image_store@main/blog/logo/img.png\n  link: https://taixingyiji.com/\n- name: cubik的小站\n  desc: recommended by dr.creative\n  avatar: https://cdn.jsdelivr.net/gh/cubik65536/cubik-favicons@main/cubiklogo.png\n  link: https://www.cubik65536.top/\n- name: x·π\n  desc: 为开发者量身制作的技术博客和知识库管理平台。\n  avatar: https://cdn.jsdelivr.net/gh/ezuy-lee/rainzedrawingbed/media/logo.png\n  link: https://ezuy-lee.github.io/xpai/\n- name: 眼里有光\n  desc: 道阻且长，行则将至\n  avatar: https://icooloop.gitee.io/img/logo.jpg\n  link: https://icooloop.gitee.io/\n- name: heo\n  desc: 爱折腾的设计师\n  link: https://blog.zhheo.com/\n  avatar: https://blog.zhheo.com/img/avatar.png\n- name: chuyuxuan\n  desc: 临渊羡鱼，不如退而结网\n  link: https://blog.chuyuxuan.top/\n  avatar: http://blog.chuyuxuan.top/img/avatar1.jpg\n- name: 全栈杂货站\n  desc: 千里万里杂货站里，天青色等烟雨，而我在等你。\n  avatar: http://cdn.tea-culture.top/tech/images/avatar/3.jpg\n  link: http://tech.tea-culture.top/\n- name: 小鱼博客\n  desc: 总是半途而废的废柴\n  avatar: https://cdn.jsdelivr.net/gh/xiaoyu-666/image_store/blog/minion.png\n  link: https://xiaoyu-666.github.io/\n- name: 大胡子\n  desc: 记录你我，分享精彩。\n  avatar: https://photo.jakehu.cn/favicon.png\n  link: https://www.jakehu.cn\n- name: 嘟先生学webgl\n  desc: 流水不争先，争的是滔滔不绝。\n  avatar: https://joy1412.cn/img/dudu.jpeg\n  link: https://joy1412.cn\n- name: "@小右_"\n  desc: 学而不厌 不耻下问\n  avatar: https://lordblog.cn/upload/2021/05/logo%20(4)-742f1f7e15db44a1b3140035104ea239.png\n  link: https://lordblog.cn/\n- name: 途中的树\n  desc: 走出自己的傲慢，承认自己的局限。\n  avatar: https://zkpeace.com/blog/img/avatar.jpg\n  link: https://zkpeace.com/\n- name: haobo\'s blog\n  link: https://discover304.top/\n  avatar: https://discover304.top/img/head.png\n  desc: 半只脚跨入炼丹师的大门的新人\n- name: 小胖墩er\n  desc: 迟到总比不到的好，所以好好加油吧。\n  avatar: https://cdn.jsdelivr.net/gh/chubby-duner/image-hosting@master/blog/logo.jpeg\n  link: https://chubbyduner.top\n- name: joseph z.\n  desc: joseph z.的小站\n  avatar: https://josephz.top/res/joseph.jpg\n  link: https://josephz.top/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n\n\n\n# 友链申请\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: kaokei\'s blog # 昵称\n  desc: 项目文档，学习笔记，游戏，demo # 介绍\n  avatar: https://cdn.jsdelivr.net/gh/kaokei/static-cdn/logo/white/logo@512.png # 头像\n  link: https://kaokei.com/ # 链接\n\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"前端发展各个阶段",frontmatter:{author:"kaokei",title:"前端发展各个阶段",date:"2021-12-19T16:52:54.000Z",permalink:"/pages/37da4b/",sidebar:"auto",categories:["随笔","技术"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/frontend-stage.html",relativePath:"_posts/frontend-stage.md",key:"v-eb1da8f6",path:"/pages/37da4b/",headers:[{level:2,title:"前端的 4 个阶段",slug:"前端的-4-个阶段",normalizedTitle:"前端的 4 个阶段",charIndex:2},{level:2,title:"jquery 阶段",slug:"jquery-阶段",normalizedTitle:"jquery 阶段",charIndex:18},{level:2,title:"组件阶段",slug:"组件阶段",normalizedTitle:"组件阶段",charIndex:129},{level:2,title:"hooks 阶段",slug:"hooks-阶段",normalizedTitle:"hooks 阶段",charIndex:506},{level:2,title:"服务阶段",slug:"服务阶段",normalizedTitle:"服务阶段",charIndex:938}],headersStr:"前端的 4 个阶段 jquery 阶段 组件阶段 hooks 阶段 服务阶段",content:"# 前端的 4 个阶段\n\n\n\n\n# jquery 阶段\n\njquery 时代，以及 jquery 之前的时代，是完全命令式的编程。没有模块化，没有工程化，只不过可以通过 jquery 实现跨浏览器的兼容性，以及基于 jquery 生态的插件化开发。\n\n\n# 组件阶段\n\n由上图可知组件自带状态和逻辑，当然还有视图。当我们定义好一个组件时，该组件是可以在多个地方使用的，这是组件在代码复用层面的优势。\n\n组件的另一个优势则是响应式编程。这是与命令式编程相对应的另一种编程模式。响应式编程又可以理解为数据驱动式编程。\n\n在 jquery 时代，当用户点击了某个按钮，在监听事件中，我们需要自己做两件事，第一件事是根据用户点击行为修改内存中的某些数据。第二件事是根据修改后的数据，再次修改网页上的视图部分。目的是为了保证数据和视图的一致性。\n\n但是在组件时代，我们不需要自己来做这两件事了。我们只需要修改数据即可。前端框架会帮我们保证数据和视图的一致性。也就是当数据修改了，页面视图部分会自动更新。\n\n除了组件本身的优势以外，我们还可以借助 babel 来实现前端的模块化和工程化，从而提升开发体验以及效率。\n\n\n# hooks 阶段\n\n组件时代看起来已经很完美了。但是依然还是有缺陷的。就是组件和组件之间不能共享逻辑代码。\n\n比如在 A 组件中有一个功能是展示当前用户的 name，已经可以编辑该 name。在另一个 B 组件中也有类似的功能。\n\n在没有 hooks 之前，我们可能会把这个功能抽象成一个组件 NameComponent，然后分别在 A 组件和 B 组件中使用 NameComponent 即可。但是如果我们想要在 A 组件和 B 组件中的样式不一样。那么我们就需要给 NameComponent 增加 props，然后在 A 和 B 组件中分别传入不同的参数。\n\n现在这样做是不够解藕的。逻辑的归逻辑，视图的归视图。我们可以利用 hooks 函数做到逻辑和视图彻底的解藕。\n\n把状态和逻辑从组件中分离出来，主要依赖于 composition api，主要是封装成类似 react 中的 hooks 函数。这样的好处是，这个函数是可以在多个组件中复用的。\n\n\n# 服务阶段\n\n在 hooks 阶段 中，组件已经和逻辑分离了，但是，还是强耦合的。这里的强耦合是相对的。是需要一定的视角去理解的。\n\n那么如何理解服务呢？其实从大体上来理解是非常简单的。hooks 就是服务的实例化，服务是 hooks 的抽象。实例化和抽象可以参考类的实例和类的关系。\n\n从代码使用风格上来看，我们之前是直接在组件内调用 hooks 函数。现在我们是在组件内调用服务类来获取服务实例，也就是通过服务类来获取 hooks 实例。\n\n尤其要注意这里的差别，以前是直接就使用 hooks 了，现在是通过中间的服务才能使用 hooks。所以说以前是强依赖 hooks 的，现在则是面向抽象编程、面向接口编程。\n\n面向抽象编程、面向接口编程这些有逼格的文案其实没什么意思。如果只看以上的介绍，其实也看不出来直接调用 hooks 函数和通过服务获取 hooks 的差别是什么。其实真的没什么差别，如果我们什么也不做的话。\n\n最关键的地方在于直接调用 hooks 函数，我们没有办法干预这个 hooks 执行的过程。但是通过服务来获取 hooks 的过程我们是可以干预的。从而实现以下这样的效果。\n\n * 本来通过 AService 应该获取的是 AService 的实例，实际上通过配置可以对使用方透明的替换成 BService 的实例。\n * 在以前 hooks 时代，hooks 执行后，hooks 的状态是一定和当前组件强制绑定的。但是现在可以统一管理服务，服务的状态不是强制和当前组件绑定的，而是可以选择和某个组件绑定，并且在其他组件中也可以获取同一个服务实例，从而方便的实现跨组件通信。\n\n回过头来看，可以清楚的看到 hooks 时代，组件是强制依赖 hooks 的，但是服务时代，则需要通过服务这个概念来间接的使用 hooks，从而可以方便的实现跨组件通信以及状态管理。\n\n很久之前就看过一句话，react 和 vue 迟早有一天会变成 angular。",normalizedContent:"# 前端的 4 个阶段\n\n\n\n\n# jquery 阶段\n\njquery 时代，以及 jquery 之前的时代，是完全命令式的编程。没有模块化，没有工程化，只不过可以通过 jquery 实现跨浏览器的兼容性，以及基于 jquery 生态的插件化开发。\n\n\n# 组件阶段\n\n由上图可知组件自带状态和逻辑，当然还有视图。当我们定义好一个组件时，该组件是可以在多个地方使用的，这是组件在代码复用层面的优势。\n\n组件的另一个优势则是响应式编程。这是与命令式编程相对应的另一种编程模式。响应式编程又可以理解为数据驱动式编程。\n\n在 jquery 时代，当用户点击了某个按钮，在监听事件中，我们需要自己做两件事，第一件事是根据用户点击行为修改内存中的某些数据。第二件事是根据修改后的数据，再次修改网页上的视图部分。目的是为了保证数据和视图的一致性。\n\n但是在组件时代，我们不需要自己来做这两件事了。我们只需要修改数据即可。前端框架会帮我们保证数据和视图的一致性。也就是当数据修改了，页面视图部分会自动更新。\n\n除了组件本身的优势以外，我们还可以借助 babel 来实现前端的模块化和工程化，从而提升开发体验以及效率。\n\n\n# hooks 阶段\n\n组件时代看起来已经很完美了。但是依然还是有缺陷的。就是组件和组件之间不能共享逻辑代码。\n\n比如在 a 组件中有一个功能是展示当前用户的 name，已经可以编辑该 name。在另一个 b 组件中也有类似的功能。\n\n在没有 hooks 之前，我们可能会把这个功能抽象成一个组件 namecomponent，然后分别在 a 组件和 b 组件中使用 namecomponent 即可。但是如果我们想要在 a 组件和 b 组件中的样式不一样。那么我们就需要给 namecomponent 增加 props，然后在 a 和 b 组件中分别传入不同的参数。\n\n现在这样做是不够解藕的。逻辑的归逻辑，视图的归视图。我们可以利用 hooks 函数做到逻辑和视图彻底的解藕。\n\n把状态和逻辑从组件中分离出来，主要依赖于 composition api，主要是封装成类似 react 中的 hooks 函数。这样的好处是，这个函数是可以在多个组件中复用的。\n\n\n# 服务阶段\n\n在 hooks 阶段 中，组件已经和逻辑分离了，但是，还是强耦合的。这里的强耦合是相对的。是需要一定的视角去理解的。\n\n那么如何理解服务呢？其实从大体上来理解是非常简单的。hooks 就是服务的实例化，服务是 hooks 的抽象。实例化和抽象可以参考类的实例和类的关系。\n\n从代码使用风格上来看，我们之前是直接在组件内调用 hooks 函数。现在我们是在组件内调用服务类来获取服务实例，也就是通过服务类来获取 hooks 实例。\n\n尤其要注意这里的差别，以前是直接就使用 hooks 了，现在是通过中间的服务才能使用 hooks。所以说以前是强依赖 hooks 的，现在则是面向抽象编程、面向接口编程。\n\n面向抽象编程、面向接口编程这些有逼格的文案其实没什么意思。如果只看以上的介绍，其实也看不出来直接调用 hooks 函数和通过服务获取 hooks 的差别是什么。其实真的没什么差别，如果我们什么也不做的话。\n\n最关键的地方在于直接调用 hooks 函数，我们没有办法干预这个 hooks 执行的过程。但是通过服务来获取 hooks 的过程我们是可以干预的。从而实现以下这样的效果。\n\n * 本来通过 aservice 应该获取的是 aservice 的实例，实际上通过配置可以对使用方透明的替换成 bservice 的实例。\n * 在以前 hooks 时代，hooks 执行后，hooks 的状态是一定和当前组件强制绑定的。但是现在可以统一管理服务，服务的状态不是强制和当前组件绑定的，而是可以选择和某个组件绑定，并且在其他组件中也可以获取同一个服务实例，从而方便的实现跨组件通信。\n\n回过头来看，可以清楚的看到 hooks 时代，组件是强制依赖 hooks 的，但是服务时代，则需要通过服务这个概念来间接的使用 hooks，从而可以方便的实现跨组件通信以及状态管理。\n\n很久之前就看过一句话，react 和 vue 迟早有一天会变成 angular。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"gitee自动同步和部署",frontmatter:{title:"gitee自动同步和部署",date:"2021-12-21T18:45:32.000Z",permalink:"/pages/f9d7e8/",sidebar:"auto",categories:["随笔","技术"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/gitee%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E5%92%8C%E9%83%A8%E7%BD%B2.html",relativePath:"_posts/gitee自动同步和部署.md",key:"v-74ab1dd5",path:"/pages/f9d7e8/",headers:[{level:2,title:"参考这里",slug:"参考这里",normalizedTitle:"参考这里",charIndex:192}],headersStr:"参考这里",content:"# gitee 自动同步和部署\n\n需要知道 gitee 的自动部署功能属于 gitee-pro 的特性。\n\n主要是借助 github 的 workflow 的能力。\n\n分别是 wearerequired/git-mirror-action@master 实现同步功能。\n\nyanglbme/gitee-pages-action@main 实现自动部署功能。\n\ntest005\n\n\n# 参考这里\n\n参考文档",normalizedContent:"# gitee 自动同步和部署\n\n需要知道 gitee 的自动部署功能属于 gitee-pro 的特性。\n\n主要是借助 github 的 workflow 的能力。\n\n分别是 wearerequired/git-mirror-action@master 实现同步功能。\n\nyanglbme/gitee-pages-action@main 实现自动部署功能。\n\ntest005\n\n\n# 参考这里\n\n参考文档",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"json schema入门",frontmatter:{title:"json schema入门",date:"2021-12-30T14:58:16.000Z",permalink:"/pages/8ab175/",sidebar:"auto",categories:["随笔"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/json%20schema%E5%85%A5%E9%97%A8.html",relativePath:"_posts/json schema入门.md",key:"v-62bb08c9",path:"/pages/8ab175/",headers:[{level:2,title:"一句话介绍 json schema 的作用",slug:"一句话介绍-json-schema-的作用",normalizedTitle:"一句话介绍 json schema 的作用",charIndex:21},{level:2,title:"一篇文章入门 json schema",slug:"一篇文章入门-json-schema",normalizedTitle:"一篇文章入门 json schema",charIndex:537},{level:2,title:"深入理解 json schema",slug:"深入理解-json-schema",normalizedTitle:"深入理解 json schema",charIndex:3196},{level:2,title:"schema 组合",slug:"schema-组合",normalizedTitle:"schema 组合",charIndex:4203},{level:2,title:"条件关键字",slug:"条件关键字",normalizedTitle:"条件关键字",charIndex:4660},{level:2,title:"引用 schema",slug:"引用-schema",normalizedTitle:"引用 schema",charIndex:4882},{level:2,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:6239},{level:2,title:"各种实现",slug:"各种实现",normalizedTitle:"各种实现",charIndex:6252},{level:2,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:6267}],headersStr:"一句话介绍 json schema 的作用 一篇文章入门 json schema 深入理解 json schema schema 组合 条件关键字 引用 schema 示例 各种实现 注意事项",content:'# json schema 入门\n\n\n# 一句话介绍 json schema 的作用\n\n校验输入的 json 是否符合预期的格式。\n\n可以考虑存在这样的一个函数 validate(inputJson, inputJsonSchema) => boolean;\n\n需要注意 json 的定义。json 包含以下这些类型。object array string integer number boolean null。\n\n关键是要意识到基本类型也属于 json 的定义。\n\n另一方面，json schema 的则一定是 object。当然 json schema 也是一个 json。\n\n比如描述字符串的 json schema 则是{"type": "string"}。 可以看出来描述基本类型的 json 已经需要一个 object 类型的 json schema 类描述了。\n\njson schema 同时也是一个 json 文件。这既是它的优势，也是它的劣势。因为 json 非常容易序列化，所以在跨语言方面表现的非常好。 但是 json 本身的逻辑表达能力非常欠缺，不能表达非常复杂的逻辑关系。\n\njson schema 主要用于验证 json 的类型结构。\n\n\n# 一篇文章入门 json schema\n\n原始入门文章\n\n{\n  // 可选字段，指定schema版本\n  "$schema": "https://json-schema.org/draft/2020-12/schema",\n  // 可选字段，指定当前schema文件的uri\n  "$id": "https://example.com/product.schema.json",\n  // 可选字段，指定当前schema文件的短描述\n  "title": "Product",\n  // 可选字段，指定当前schema文件的长描述\n  "description": "A product in the catalog",\n  // 必填字段，指定输入json的类型\n  "type": "object",\n  // 因为当前json是一个object，所以需要指定有哪些属性\n  "properties": {\n    // 声明字段名productId\n    "productId": {\n      // 描述字段含义\n      "description": "The unique identifier for a product",\n      // 描述字段类型\n      "type": "integer"\n    },\n    // 声明字段名productName\n    "productName": {\n      "description": "Name of the product",\n      "type": "string"\n    },\n    // 声明字段名price\n    "price": {\n      "description": "The price of the product",\n      "type": "number",\n      // 价格必须大于0\n      "exclusiveMinimum": 0\n    },\n    // 声明字段名tags，是一个数组\n    "tags": {\n      "description": "Tags for the product",\n      "type": "array",\n      // tags数组中的元素都是字符串\n      "items": {\n        "type": "string"\n      },\n      // tags数组最少有一个tag\n      "minItems": 1,\n      // tags数组中元素必须唯一\n      "uniqueItems": true\n    },\n    // 声明字段名dimensions，是一个对象\n    // 这里演示了嵌套对象的json schema\n    "dimensions": {\n      "type": "object",\n      "properties": {\n        "length": {\n          "type": "number"\n        },\n        "width": {\n          "type": "number"\n        },\n        "height": {\n          "type": "number"\n        }\n      },\n      "required": ["length", "width", "height"]\n    },\n    // 声明字段名dimensions，是一个对象\n    // 这里演示了使用$ref来引用一个外部json schema\n    "warehouseLocation": {\n      "description": "Coordinates of the warehouse where the product is located.",\n      "$ref": "https://example.com/geographical-location.schema.json"\n    }\n  },\n  // 指定哪些属性是必填字段\n  "required": ["productId", "productName", "price"]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n以下是另一个 json schema 文件，被上面的 json schema 文件通过$ref指向$id引用\n\n{\n  "$id": "https://example.com/geographical-location.schema.json",\n  "$schema": "https://json-schema.org/draft/2020-12/schema",\n  "title": "Longitude and Latitude",\n  "description": "A geographical coordinate on a planet (most commonly Earth).",\n  "required": ["latitude", "longitude"],\n  "type": "object",\n  "properties": {\n    "latitude": {\n      "type": "number",\n      "minimum": -90,\n      "maximum": 90\n    },\n    "longitude": {\n      "type": "number",\n      "minimum": -180,\n      "maximum": 180\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 深入理解 json schema\n\n原始官方文章\n\n# 顶层关键字\n\n$schema $id title description type required properties\n\n$schema只能在顶层使用。而且一旦使用就不能被外部引用，这里有点疑问，因为上面的例子展示了外部引用???\n\n# string 类型的关键字\n\nminLength maxLength pattern format\n\n# number 类型的关键字\n\nmultipleOf minimum maximum exclusiveMinimum exclusiveMaximum\n\n# object 类型的关键字\n\n除了使用 type 指定属性类型，还可以使用 enum 来指定枚举类型\n\n除了使用 properties 来描述属性，还可以通过 patternProperties 来指定非特定的属性。\n\nadditionalProperties 控制是否可以有多余属性\n\nunevaluatedProperties ???\n\nif then\n\npropertyNames\n\nminProperties maxProperties\n\n# array 类型的关键字\n\nitems prefixItems minItems maxItems uniqueItems contains minContains maxContains\n\n# 通用关键字\n\ntitle description default examples deprecated readOnly writeOnly\n\n$comment 相当于代码注释，是给后续修改该 json schema 的人看的，而不是给使用 json schema 的工具使用的。\n\ntype enum const 指定属性类型的 3 种方式。\n\n# 媒体类型关键字\n\n相当于是 string 类型的子类型，更加详细的描述了 string 类型。\n\n{\n  "type": "string",\n  "contentMediaType": "text/html"\n}\n\n\n1\n2\n3\n4\n\n\n{\n  "type": "string",\n  "contentEncoding": "base64",\n  "contentMediaType": "image/png"\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# schema 组合\n\nallOf anyOf oneOf not\n\n注意到 oneOf 是严格限制只能是满足其中一个 subschema，anyOf 则可以是 1 个或者多个 subschema\n\n# 组合错误\n\n// 不可能同时存在既是string又是number\n{\n  "allOf": [{ "type": "string" }, { "type": "number" }]\n}\n\n\n1\n2\n3\n4\n\n\n# 组合重构\n\n{\n  "oneOf": [\n    { "type": "number", "multipleOf": 5 },\n    { "type": "number", "multipleOf": 3 }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n// 上面的json schema可以重构成这样的\n{\n  "type": "number",\n  "oneOf": [{ "multipleOf": 5 }, { "multipleOf": 3 }]\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 条件关键字\n\ndependentRequired，默认是单向的，如果需要双向依赖，则需要手动维护依赖关系。含义是当输入的 json 数据包含某个字段 A，则必须包含对应的字段 B、C、D...\n\ndependentSchemas 功能类似，只是语法不一样。\n\nif-then-else，单纯的 if-then-else 只能判断一个条件，不能实现 else-if 的效果。可以配置 allOf 和多个 if-then 来达到这个效果。\n\n\n# 引用 schema\n\n首先需要注意区分$schema和$id的区别。\n\n参考这里介绍了$schema应该在顶层使用，类似于 html 中的 dtd 文件，是一种 meta-schema。\n\n参考这里介绍了$id不是必须的，如果不存在则代表是一个匿名 schema。虽然$id是一个 URI，但是不代表具体实现会通过这个 URI 来获取这个 schema，它只是一个 ID 而已。 虽然只是一个 ID，但是在计算相对路径时，还是和 URL 的计算规则时相似的。\n\n# Retrieval URI\n\n代表具体实现获取 schema 的 URI。如果具体实现并不是通过网络获取，而是直接访问的匿名 schema，那么就没有 Retrieval URI。\n\n# Base URI\n\nBase URI 是参考的rfc3986的概念。\n\n一般就是 Retrieval URI 或者 根据 $id 来计算生成。\n\nBase URI 是非常重要的概念，因为后续在计算外部 schema 的路径时，就是根据 Base URI 来计算的。\n\n# $id\n\n如果$id是一个绝对URI，那么Base URI就是$id。如果$id 是一个相对路径，那么需要根据 Retrieval URI 来生成一个 Base URI。\n\n# subschema\n\n可以使用 JSON Pointer 来指向 subschema。\n\n其实就是利用 URI 中的 fragment 来定位 json schema 中的片段。https://example.com/schemas/address#/properties/street_address\n\n另一种不常见的方式时使用$anchor关键字来定义一个命名 fragment。https://example.com/schemas/address#street_address\n\n# $defs\n\n可以在当前 schema 内部定义可以复用的 subschema。\n\n{\n  "$defs": {\n    "name": { "type": "string" }\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n# $ref\n\n上面都是在说定义 schema 和 subschema，这里说一下怎么引用外部 schema。\n\n$ref可以时绝对 URI，也可以时相对 URI，如果是相对 URI，那么就需要借助 Base URI 来计算出绝对 URI。\n\n当然，如果缺少 Base URI，同时$ref同时又是一个相对 URI，那么就会导致计算失败。\n\n$ref还可以引用$defs，比如"$ref": "#/$defs/name"\n\n$ref还可以递归引用自身 schema，语法是"$ref": "#"，当然需要避免循环引用。\n\n# 打包\n\n开发 schema 的时候，将多个 schema 分开到多个文件是一个最佳实践。但是发布一个 schema，最佳实践最好是打包成一个文件。\n\n主要还是利用的$defs来声明 embedded schema。然后利用$ref来指向 embedded schema 的$id。注意这里需要区分 embedded schema 和 subschema 的区别。\n\n\n# 示例\n\n参考这里\n\n\n# 各种实现\n\n参考这里\n\n\n# 注意事项\n\ntype 可以是数组，表示满足任意一个类型定义即可\n\n最简单的 json schema 是{}，可以接受任意合法 json\n\njson schema 可以区分整数和数字，integer 和 number\n\n如果输入属性在满足 json schema 的基础上还有多余的属性，默认是可以通过校验的。通过 additionalProperties 关键字来控制。\n\nobject 的属性默认不是必填的，需要在 required 数组中声明必填字段\n\njson schema 中出现了非关键字，不会有任何影响，也不会自动参与 validate 的过程，这是显然的，因为 validate 函数是别人实现的。除非我们自己实现自己的 validate 函数。\b 那么就可以处理新增加的关键字。',normalizedContent:'# json schema 入门\n\n\n# 一句话介绍 json schema 的作用\n\n校验输入的 json 是否符合预期的格式。\n\n可以考虑存在这样的一个函数 validate(inputjson, inputjsonschema) => boolean;\n\n需要注意 json 的定义。json 包含以下这些类型。object array string integer number boolean null。\n\n关键是要意识到基本类型也属于 json 的定义。\n\n另一方面，json schema 的则一定是 object。当然 json schema 也是一个 json。\n\n比如描述字符串的 json schema 则是{"type": "string"}。 可以看出来描述基本类型的 json 已经需要一个 object 类型的 json schema 类描述了。\n\njson schema 同时也是一个 json 文件。这既是它的优势，也是它的劣势。因为 json 非常容易序列化，所以在跨语言方面表现的非常好。 但是 json 本身的逻辑表达能力非常欠缺，不能表达非常复杂的逻辑关系。\n\njson schema 主要用于验证 json 的类型结构。\n\n\n# 一篇文章入门 json schema\n\n原始入门文章\n\n{\n  // 可选字段，指定schema版本\n  "$schema": "https://json-schema.org/draft/2020-12/schema",\n  // 可选字段，指定当前schema文件的uri\n  "$id": "https://example.com/product.schema.json",\n  // 可选字段，指定当前schema文件的短描述\n  "title": "product",\n  // 可选字段，指定当前schema文件的长描述\n  "description": "a product in the catalog",\n  // 必填字段，指定输入json的类型\n  "type": "object",\n  // 因为当前json是一个object，所以需要指定有哪些属性\n  "properties": {\n    // 声明字段名productid\n    "productid": {\n      // 描述字段含义\n      "description": "the unique identifier for a product",\n      // 描述字段类型\n      "type": "integer"\n    },\n    // 声明字段名productname\n    "productname": {\n      "description": "name of the product",\n      "type": "string"\n    },\n    // 声明字段名price\n    "price": {\n      "description": "the price of the product",\n      "type": "number",\n      // 价格必须大于0\n      "exclusiveminimum": 0\n    },\n    // 声明字段名tags，是一个数组\n    "tags": {\n      "description": "tags for the product",\n      "type": "array",\n      // tags数组中的元素都是字符串\n      "items": {\n        "type": "string"\n      },\n      // tags数组最少有一个tag\n      "minitems": 1,\n      // tags数组中元素必须唯一\n      "uniqueitems": true\n    },\n    // 声明字段名dimensions，是一个对象\n    // 这里演示了嵌套对象的json schema\n    "dimensions": {\n      "type": "object",\n      "properties": {\n        "length": {\n          "type": "number"\n        },\n        "width": {\n          "type": "number"\n        },\n        "height": {\n          "type": "number"\n        }\n      },\n      "required": ["length", "width", "height"]\n    },\n    // 声明字段名dimensions，是一个对象\n    // 这里演示了使用$ref来引用一个外部json schema\n    "warehouselocation": {\n      "description": "coordinates of the warehouse where the product is located.",\n      "$ref": "https://example.com/geographical-location.schema.json"\n    }\n  },\n  // 指定哪些属性是必填字段\n  "required": ["productid", "productname", "price"]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n以下是另一个 json schema 文件，被上面的 json schema 文件通过$ref指向$id引用\n\n{\n  "$id": "https://example.com/geographical-location.schema.json",\n  "$schema": "https://json-schema.org/draft/2020-12/schema",\n  "title": "longitude and latitude",\n  "description": "a geographical coordinate on a planet (most commonly earth).",\n  "required": ["latitude", "longitude"],\n  "type": "object",\n  "properties": {\n    "latitude": {\n      "type": "number",\n      "minimum": -90,\n      "maximum": 90\n    },\n    "longitude": {\n      "type": "number",\n      "minimum": -180,\n      "maximum": 180\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 深入理解 json schema\n\n原始官方文章\n\n# 顶层关键字\n\n$schema $id title description type required properties\n\n$schema只能在顶层使用。而且一旦使用就不能被外部引用，这里有点疑问，因为上面的例子展示了外部引用???\n\n# string 类型的关键字\n\nminlength maxlength pattern format\n\n# number 类型的关键字\n\nmultipleof minimum maximum exclusiveminimum exclusivemaximum\n\n# object 类型的关键字\n\n除了使用 type 指定属性类型，还可以使用 enum 来指定枚举类型\n\n除了使用 properties 来描述属性，还可以通过 patternproperties 来指定非特定的属性。\n\nadditionalproperties 控制是否可以有多余属性\n\nunevaluatedproperties ???\n\nif then\n\npropertynames\n\nminproperties maxproperties\n\n# array 类型的关键字\n\nitems prefixitems minitems maxitems uniqueitems contains mincontains maxcontains\n\n# 通用关键字\n\ntitle description default examples deprecated readonly writeonly\n\n$comment 相当于代码注释，是给后续修改该 json schema 的人看的，而不是给使用 json schema 的工具使用的。\n\ntype enum const 指定属性类型的 3 种方式。\n\n# 媒体类型关键字\n\n相当于是 string 类型的子类型，更加详细的描述了 string 类型。\n\n{\n  "type": "string",\n  "contentmediatype": "text/html"\n}\n\n\n1\n2\n3\n4\n\n\n{\n  "type": "string",\n  "contentencoding": "base64",\n  "contentmediatype": "image/png"\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# schema 组合\n\nallof anyof oneof not\n\n注意到 oneof 是严格限制只能是满足其中一个 subschema，anyof 则可以是 1 个或者多个 subschema\n\n# 组合错误\n\n// 不可能同时存在既是string又是number\n{\n  "allof": [{ "type": "string" }, { "type": "number" }]\n}\n\n\n1\n2\n3\n4\n\n\n# 组合重构\n\n{\n  "oneof": [\n    { "type": "number", "multipleof": 5 },\n    { "type": "number", "multipleof": 3 }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n// 上面的json schema可以重构成这样的\n{\n  "type": "number",\n  "oneof": [{ "multipleof": 5 }, { "multipleof": 3 }]\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 条件关键字\n\ndependentrequired，默认是单向的，如果需要双向依赖，则需要手动维护依赖关系。含义是当输入的 json 数据包含某个字段 a，则必须包含对应的字段 b、c、d...\n\ndependentschemas 功能类似，只是语法不一样。\n\nif-then-else，单纯的 if-then-else 只能判断一个条件，不能实现 else-if 的效果。可以配置 allof 和多个 if-then 来达到这个效果。\n\n\n# 引用 schema\n\n首先需要注意区分$schema和$id的区别。\n\n参考这里介绍了$schema应该在顶层使用，类似于 html 中的 dtd 文件，是一种 meta-schema。\n\n参考这里介绍了$id不是必须的，如果不存在则代表是一个匿名 schema。虽然$id是一个 uri，但是不代表具体实现会通过这个 uri 来获取这个 schema，它只是一个 id 而已。 虽然只是一个 id，但是在计算相对路径时，还是和 url 的计算规则时相似的。\n\n# retrieval uri\n\n代表具体实现获取 schema 的 uri。如果具体实现并不是通过网络获取，而是直接访问的匿名 schema，那么就没有 retrieval uri。\n\n# base uri\n\nbase uri 是参考的rfc3986的概念。\n\n一般就是 retrieval uri 或者 根据 $id 来计算生成。\n\nbase uri 是非常重要的概念，因为后续在计算外部 schema 的路径时，就是根据 base uri 来计算的。\n\n# $id\n\n如果$id是一个绝对uri，那么base uri就是$id。如果$id 是一个相对路径，那么需要根据 retrieval uri 来生成一个 base uri。\n\n# subschema\n\n可以使用 json pointer 来指向 subschema。\n\n其实就是利用 uri 中的 fragment 来定位 json schema 中的片段。https://example.com/schemas/address#/properties/street_address\n\n另一种不常见的方式时使用$anchor关键字来定义一个命名 fragment。https://example.com/schemas/address#street_address\n\n# $defs\n\n可以在当前 schema 内部定义可以复用的 subschema。\n\n{\n  "$defs": {\n    "name": { "type": "string" }\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n# $ref\n\n上面都是在说定义 schema 和 subschema，这里说一下怎么引用外部 schema。\n\n$ref可以时绝对 uri，也可以时相对 uri，如果是相对 uri，那么就需要借助 base uri 来计算出绝对 uri。\n\n当然，如果缺少 base uri，同时$ref同时又是一个相对 uri，那么就会导致计算失败。\n\n$ref还可以引用$defs，比如"$ref": "#/$defs/name"\n\n$ref还可以递归引用自身 schema，语法是"$ref": "#"，当然需要避免循环引用。\n\n# 打包\n\n开发 schema 的时候，将多个 schema 分开到多个文件是一个最佳实践。但是发布一个 schema，最佳实践最好是打包成一个文件。\n\n主要还是利用的$defs来声明 embedded schema。然后利用$ref来指向 embedded schema 的$id。注意这里需要区分 embedded schema 和 subschema 的区别。\n\n\n# 示例\n\n参考这里\n\n\n# 各种实现\n\n参考这里\n\n\n# 注意事项\n\ntype 可以是数组，表示满足任意一个类型定义即可\n\n最简单的 json schema 是{}，可以接受任意合法 json\n\njson schema 可以区分整数和数字，integer 和 number\n\n如果输入属性在满足 json schema 的基础上还有多余的属性，默认是可以通过校验的。通过 additionalproperties 关键字来控制。\n\nobject 的属性默认不是必填的，需要在 required 数组中声明必填字段\n\njson schema 中出现了非关键字，不会有任何影响，也不会自动参与 validate 的过程，这是显然的，因为 validate 函数是别人实现的。除非我们自己实现自己的 validate 函数。\b 那么就可以处理新增加的关键字。',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"kubernetes基础概念",frontmatter:{title:"kubernetes基础概念",date:"2022-02-16T17:09:11.000Z",permalink:"/pages/acbdc0/",sidebar:"auto",categories:["随笔"],tags:[null],showSidebar:!1},regularPath:"/_posts/kubernetes%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.html",relativePath:"_posts/kubernetes基础概念.md",key:"v-1f70189d",path:"/pages/acbdc0/",headers:[{level:2,title:"硬件角度",slug:"硬件角度",normalizedTitle:"硬件角度",charIndex:2},{level:2,title:"软件角度",slug:"软件角度",normalizedTitle:"软件角度",charIndex:284},{level:2,title:"DNS",slug:"dns",normalizedTitle:"dns",charIndex:712},{level:2,title:"Ingress",slug:"ingress",normalizedTitle:"ingress",charIndex:783}],headersStr:"硬件角度 软件角度 DNS Ingress",content:"# 硬件角度\n\ncluster 由 node 组成。即集群由节点构成。\n\nnode 一般认为是一组 CPU 和 RAM。可以是台式电脑，笔记本电脑，也可以是机架服务器，甚至可以是虚拟机。\n\n集群的优点是让程序员不再关心程序具体是运行在哪台机器上，不用再担心机器损坏导致服务不可用。\n\nnamespace 命名空间又叫作名字空间。用于创建虚拟集群，它们底层依赖于同一个物理集群。\n\nPersistent Volumes 又叫作持久卷。可以看作是集群的硬盘。容易理解 node 自带的文件系统只能是作为临时缓存使用。所以要想实现持久化的功能，必须要持久卷来实现。\n\n\n# 软件角度\n\nContainer 又叫作容器。容器是一种开放且广泛使用的标准，所以我们可以使用现有的很多容器。最常见的就是 docker 容器。这里需要注意 container 和 image 的区别。\n\nPod，不知道怎么翻译，一般也不说中文。注意到 Pod 可以包含多个 Container，但是一般也只有一个 Container，如果有其他 Container，一般称呼为 side-cars。\n\nDeployment，一般翻译为部署。一个部署可以包含若干个 Pod，一般建议最少 2 个，互为备份。Pod 的数量又称为副本个数，英文是 Replicas。部署的好处是可以监控 Pod 的健康度，如果其中一个挂掉，部署会自动创建一个新的 Pod。\n\n服务，一开始容易和部署这个概念混淆，因为都是一组 Pod。部署强调的是管理 Pod 的状态。服务则是强调外部 ip 和 Pod 的对应关系，因为 Pod 具有临时性，可能随时被删除或者替换掉。\n\n\n# DNS\n\nKubernetes 为服务和 Pods 创建 DNS 记录。 你可以使用一致的 DNS 名称而非 IP 地址来访问服务。\n\n\n# Ingress\n\n可以理解为集群的 nginx。用于连接集群和外部网络。\n\nKubernetes 101: Pods, Nodes, Containers, and Clusters Kubernetes 110: Your First Deployment Kubernetes 120: Networking Basics 使用 Service 连接到应用 Kubernetes 架构简介 Kubernetes 词汇表",normalizedContent:"# 硬件角度\n\ncluster 由 node 组成。即集群由节点构成。\n\nnode 一般认为是一组 cpu 和 ram。可以是台式电脑，笔记本电脑，也可以是机架服务器，甚至可以是虚拟机。\n\n集群的优点是让程序员不再关心程序具体是运行在哪台机器上，不用再担心机器损坏导致服务不可用。\n\nnamespace 命名空间又叫作名字空间。用于创建虚拟集群，它们底层依赖于同一个物理集群。\n\npersistent volumes 又叫作持久卷。可以看作是集群的硬盘。容易理解 node 自带的文件系统只能是作为临时缓存使用。所以要想实现持久化的功能，必须要持久卷来实现。\n\n\n# 软件角度\n\ncontainer 又叫作容器。容器是一种开放且广泛使用的标准，所以我们可以使用现有的很多容器。最常见的就是 docker 容器。这里需要注意 container 和 image 的区别。\n\npod，不知道怎么翻译，一般也不说中文。注意到 pod 可以包含多个 container，但是一般也只有一个 container，如果有其他 container，一般称呼为 side-cars。\n\ndeployment，一般翻译为部署。一个部署可以包含若干个 pod，一般建议最少 2 个，互为备份。pod 的数量又称为副本个数，英文是 replicas。部署的好处是可以监控 pod 的健康度，如果其中一个挂掉，部署会自动创建一个新的 pod。\n\n服务，一开始容易和部署这个概念混淆，因为都是一组 pod。部署强调的是管理 pod 的状态。服务则是强调外部 ip 和 pod 的对应关系，因为 pod 具有临时性，可能随时被删除或者替换掉。\n\n\n# dns\n\nkubernetes 为服务和 pods 创建 dns 记录。 你可以使用一致的 dns 名称而非 ip 地址来访问服务。\n\n\n# ingress\n\n可以理解为集群的 nginx。用于连接集群和外部网络。\n\nkubernetes 101: pods, nodes, containers, and clusters kubernetes 110: your first deployment kubernetes 120: networking basics 使用 service 连接到应用 kubernetes 架构简介 kubernetes 词汇表",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"linux 命令",frontmatter:{title:"linux 命令",date:"2022-01-04T15:24:36.000Z",permalink:"/pages/84b761/",sidebar:"auto",categories:["随笔"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/linux%20%E5%91%BD%E4%BB%A4.html",relativePath:"_posts/linux 命令.md",key:"v-92c74e7e",path:"/pages/84b761/",headers:[{level:2,title:"查看文件第 n 行内容",slug:"查看文件第-n-行内容",normalizedTitle:"查看文件第 n 行内容",charIndex:2},{level:2,title:"查看文件第 m...n 行的内容",slug:"查看文件第-m-n-行的内容",normalizedTitle:"查看文件第 m...n 行的内容",charIndex:338},{level:2,title:"检查端口占用",slug:"检查端口占用",normalizedTitle:"检查端口占用",charIndex:802},{level:2,title:"常用命令",slug:"常用命令",normalizedTitle:"常用命令",charIndex:1257}],headersStr:"查看文件第 n 行内容 查看文件第 m...n 行的内容 检查端口占用 常用命令",content:"# 查看文件第 n 行内容\n\n一般应该用不到这个命令，我的使用场景是因为在分析巨型日志文件的时候，编辑器都不能正常工作，只能获取指定行数的日志内容来分析了。\n\n方法一：\n\nhead -m  filename | tail -1\nhead -200 data.log | tail -1\n\n\n1\n2\n\n\n方法二：\n\nnl filename | sed -n 'mp'\nnl data.log | sed -n '200p'\n\n\n1\n2\n\n\n方法三：\n\nsed -n 'mp' data.log\nsed -n '200p' data.log\n\n\n1\n2\n\n\n方法四：\n\nawk 'NR==m' filename\nawk 'NR==200' data.log\n\n\n1\n2\n\n\n\n# 查看文件第 m...n 行的内容\n\n方法一：\n\n# 取前x行后再取后y行\n# 也就是取x-y到x之间的内容\ncat filename | head -n x | tail -n y\n\n\n1\n2\n3\n\n\n方法二：\n\n# 取后y行内容后再取前x行内容\n# 这里注意是获取整个文件的靠后面内容，所以没有办法确定是第几行到第几行\ncat filename | tail -n y | head -n x\n\n\n1\n2\n3\n\n\n方法三：\n\n# 取前x行内容后后再从y行开始取到最后\n# 也就是取y到x之间的内容\ncat filename | head -n x | tail -n +y\n\n\n1\n2\n3\n\n\n方法四：\n\n# 从y行开始取到最后再取前x行\n# 也就是取y到x+y之间的内容\ncat filename | tail -n +y | head -n x\n\n\n1\n2\n3\n\n\n方法五：\n\n# x,y是正整数\n# 就是表面含义，取文件的第x行到第y行之间的内容\nsed -n 'x,yp' filename\n\n\n1\n2\n3\n\n\n\n# 检查端口占用\n\n# 常用端口\n\n * HTTP – TCP 80\n * HTTPS – TCP 443\n * POP3 – TCP 110\n * SMTP – TCP 25\n * SSH – TCP 22\n * DNS/DOMAIN – TCP/UDP 53\n\n# 检查命令\n\n * cat /etc/services\n * grep -w 80 /etc/services\n * egrep -w '53/(tcp|udp)' /etc/services\n * grep -E -w '7001/(tcp|udp)' /etc/services\n * lsof -i -P -n | grep LISTEN\n * netstat -tulpn | grep LISTEN\n * netstat -tulpn | grep :443\n * netstat -tulpn\n * ss -tulpn | grep LISTEN\n * ss -tulpn | grep ':22'\n * ss -tulpn\n\n\n# 常用命令\n\n# 找到最大的10个文件\nfind . -type f -exec du -h {} + | grep -v 'node_modules' | grep -v 'dist' | grep -v 'build' | grep -v 'temp' | grep -v '.git' | sort -r -h | head -10\n\n\n1\n2\n",normalizedContent:"# 查看文件第 n 行内容\n\n一般应该用不到这个命令，我的使用场景是因为在分析巨型日志文件的时候，编辑器都不能正常工作，只能获取指定行数的日志内容来分析了。\n\n方法一：\n\nhead -m  filename | tail -1\nhead -200 data.log | tail -1\n\n\n1\n2\n\n\n方法二：\n\nnl filename | sed -n 'mp'\nnl data.log | sed -n '200p'\n\n\n1\n2\n\n\n方法三：\n\nsed -n 'mp' data.log\nsed -n '200p' data.log\n\n\n1\n2\n\n\n方法四：\n\nawk 'nr==m' filename\nawk 'nr==200' data.log\n\n\n1\n2\n\n\n\n# 查看文件第 m...n 行的内容\n\n方法一：\n\n# 取前x行后再取后y行\n# 也就是取x-y到x之间的内容\ncat filename | head -n x | tail -n y\n\n\n1\n2\n3\n\n\n方法二：\n\n# 取后y行内容后再取前x行内容\n# 这里注意是获取整个文件的靠后面内容，所以没有办法确定是第几行到第几行\ncat filename | tail -n y | head -n x\n\n\n1\n2\n3\n\n\n方法三：\n\n# 取前x行内容后后再从y行开始取到最后\n# 也就是取y到x之间的内容\ncat filename | head -n x | tail -n +y\n\n\n1\n2\n3\n\n\n方法四：\n\n# 从y行开始取到最后再取前x行\n# 也就是取y到x+y之间的内容\ncat filename | tail -n +y | head -n x\n\n\n1\n2\n3\n\n\n方法五：\n\n# x,y是正整数\n# 就是表面含义，取文件的第x行到第y行之间的内容\nsed -n 'x,yp' filename\n\n\n1\n2\n3\n\n\n\n# 检查端口占用\n\n# 常用端口\n\n * http – tcp 80\n * https – tcp 443\n * pop3 – tcp 110\n * smtp – tcp 25\n * ssh – tcp 22\n * dns/domain – tcp/udp 53\n\n# 检查命令\n\n * cat /etc/services\n * grep -w 80 /etc/services\n * egrep -w '53/(tcp|udp)' /etc/services\n * grep -e -w '7001/(tcp|udp)' /etc/services\n * lsof -i -p -n | grep listen\n * netstat -tulpn | grep listen\n * netstat -tulpn | grep :443\n * netstat -tulpn\n * ss -tulpn | grep listen\n * ss -tulpn | grep ':22'\n * ss -tulpn\n\n\n# 常用命令\n\n# 找到最大的10个文件\nfind . -type f -exec du -h {} + | grep -v 'node_modules' | grep -v 'dist' | grep -v 'build' | grep -v 'temp' | grep -v '.git' | sort -r -h | head -10\n\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"markdown示例文章",frontmatter:{title:"markdown示例文章",date:"2022-01-11T23:38:37.000Z",permalink:"/pages/6e93a2/",sidebar:"auto",categories:["随笔"],tags:["markdown","vuepress","vdoing"],showSidebar:!1},regularPath:"/_posts/markdown%E7%A4%BA%E4%BE%8B%E6%96%87%E7%AB%A0.html",relativePath:"_posts/markdown示例文章.md",key:"v-11d9b8ac",path:"/pages/6e93a2/",headers:[{level:2,title:"二级标题",slug:"二级标题",normalizedTitle:"二级标题",charIndex:71},{level:3,title:"三级标题",slug:"三级标题",normalizedTitle:"三级标题",charIndex:98},{level:2,title:"字体",slug:"字体",normalizedTitle:"字体",charIndex:243},{level:2,title:"分割线+删除线+下划线",slug:"分割线-删除线-下划线",normalizedTitle:"分割线+删除线+下划线",charIndex:367},{level:2,title:"列表",slug:"列表",normalizedTitle:"列表",charIndex:542},{level:2,title:"引用",slug:"引用",normalizedTitle:"引用",charIndex:892},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:1118},{level:2,title:"链接",slug:"链接",normalizedTitle:"链接",charIndex:1383},{level:2,title:"高级链接",slug:"高级链接",normalizedTitle:"高级链接",charIndex:1491},{level:2,title:"图片",slug:"图片",normalizedTitle:"图片",charIndex:1569},{level:2,title:"表格",slug:"表格",normalizedTitle:"表格",charIndex:2022},{level:2,title:"支持 HTML 元素",slug:"支持-html-元素",normalizedTitle:"支持 html 元素",charIndex:2297},{level:2,title:"转义",slug:"转义",normalizedTitle:"转义",charIndex:2536},{level:2,title:"Emoji 表情",slug:"emoji-表情",normalizedTitle:"emoji 表情",charIndex:2755},{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2901},{level:2,title:"自定义容器",slug:"自定义容器",normalizedTitle:"自定义容器",charIndex:3031},{level:2,title:"卡片列表",slug:"卡片列表",normalizedTitle:"卡片列表",charIndex:3040},{level:2,title:"徽章组件",slug:"徽章组件",normalizedTitle:"徽章组件",charIndex:3048},{level:2,title:"外部标签",slug:"外部标签",normalizedTitle:"外部标签",charIndex:3056},{level:2,title:"流程图",slug:"流程图",normalizedTitle:"流程图",charIndex:3064}],headersStr:"二级标题 三级标题 字体 分割线+删除线+下划线 列表 引用 代码 链接 高级链接 图片 表格 支持 HTML 元素 转义 Emoji 表情 目录 自定义容器 卡片列表 徽章组件 外部标签 流程图",content:'# markdown 示例文章\n\n\n# 一级标题\n\n一级标题应该只有一个，而且第一个一级标题不会显示出来。这里其实是第二个一级标题。\n\n\n# 二级标题\n\n注意到只有二级标题才有底部横线。\n\n\n# 三级标题\n\n注意到侧边栏只会显示到三级标题。\n\n# 四级标题\n\n# 五级标题\n\n# 六级标题\n\n标题\n\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n#### 四级标题\n\n##### 五级标题\n\n###### 六级标题\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 字体\n\n斜体文本 斜体文本\n\n粗体文本 粗体文本\n\n粗斜体文本 粗斜体文本\n\n字体\n\n_斜体文本_\n_斜体文本_\n\n**粗体文本**\n**粗体文本**\n\n**_粗斜体文本_**\n**_粗斜体文本_**\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 分割线+删除线+下划线\n\n---可以画一个全宽的横线。注意到上面的横线是二级标题自带的横线，下面才是我画的横线。\n\n----------------------------------------\n\nBAIDU.COM\n\n带下划线文本\n\n分割线\n\n---\n\n~~BAIDU.COM~~\n\n<u>带下划线文本</u>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 列表\n\n分为有序列表和无序列表\n\n * 第一项\n   * 第一项嵌套的第一个元素\n   * 第一项嵌套的第二个元素\n * 第二项\n   * 第二项嵌套的第一个元素\n   * 第二项嵌套的第二个元素\n * 第三项\n   1. 第 3 项嵌套的第 1 个元素\n   2. 第 3 项嵌套的第 2 个元素\n   3. 第 3 项嵌套的第 3 个元素\n\n列表\n\n- 第一项\n  - 第一项嵌套的第一个元素\n  - 第一项嵌套的第二个元素\n- 第二项\n  - 第二项嵌套的第一个元素\n  - 第二项嵌套的第二个元素\n- 第三项\n  1. 第 3 项嵌套的第 1 个元素\n  2. 第 3 项嵌套的第 2 个元素\n  3. 第 3 项嵌套的第 3 个元素\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 引用\n\n嵌套引用\n\n> 最外层\n> \n> > 第一层嵌套\n> > \n> > > 第二层嵌套\n\n区块中使用列表\n\n> 区块中使用列表\n> \n>  1. 第一项\n>  2. 第二项\n> \n>  * 第一项\n>  * 第二项\n>  * 第三项\n\n列表中使用区块\n\n * 第一项\n   \n   > 菜鸟教程 学的不仅是技术更是梦想\n\n * 第二项\n\n引用\n\n> 最外层\n>\n> > 第一层嵌套\n> >\n> > > 第二层嵌套\n\n\n1\n2\n3\n4\n5\n\n\n\n# 代码\n\n这是内联代码：printf() 函数\n\n以下是代码块。这里是合法的语言列表\n\n常见语言代码：markdown js css html bash ts\n\n\n\n \n\n\n\n$(document).ready(function () {\n  alert("RUNOOB");\n});\n\n\n1\n2\n3\n\n代码\n\n`printf()`\n\n```javascript {2}\n$(document).ready(function () {\n  alert("RUNOOB");\n});\n```\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 链接\n\n百度地址\n\nhttps://www.baidu.com/\n\n链接\n\n[百度地址](https://www.baidu.com/)\n\n<https://www.baidu.com/>\n\n\n1\n2\n3\n\n\n\n# 高级链接\n\n这个链接用 1 作为 Google 网址变量 Google\n\n这个链接用 baidu 作为网址变量 baidu\n\n这个链接用 kaokei 作为图片网址变量 kaokei\n\n然后在文档的结尾为变量赋值（网址）\n\n高级链接\n\n这个链接用 1 作为 Google 网址变量 [Google][1]\n\n这个链接用 Baidu 作为网址变量 [Baidu][baidu]\n\n然后在文档的结尾为变量赋值（网址）\n\n[1]: https://www.google.com/\n[baidu]: https://www.baidu.com/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 图片\n\n\n\n图片\n\n![kaokei 图标](https://cdn.jsdelivr.net/gh/kaokei/static-cdn/logo/white/logo@512.png "KAOKEI")\n\n<img title="KAOKEI" alt="kaokei" src="https://cdn.jsdelivr.net/gh/kaokei/static-cdn/logo/white/logo@512.png" width="20%">\n\n\n1\n2\n3\n\n\n\n# 表格\n\n左对齐     居中对齐   右对齐\n单元格 1   单元格    单元格\n单元格 2   单元格    单元格\n单元格 3   单元格    单元格\n单元格 4   单元格    单元格\n\n表格\n\n| 左对齐   | 居中对齐 | 右对齐 |\n| :------- | :------: | -----: |\n| 单元格 1 |  单元格  | 单元格 |\n| 单元格 2 |  单元格  | 单元格 |\n| 单元格 3 |  单元格  | 单元格 |\n| 单元格 4 |  单元格  | 单元格 |\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 支持 HTML 元素\n\n目前支持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br> <mark>等。\n\n使用 Ctrl+Alt+Del 重启电脑\n\nVdoing 是一款简洁高效的知识管理和博客主题\n\n支持 HTML 元素\n\n使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n\nVdoing 是一款简洁高效的<mark>知识管理和博客</mark>主题\n\n\n1\n2\n3\n\n\n\n# 转义\n\n文本加粗\n\n** 正常显示星号 **\n\n转义\n\n**文本加粗**\n\n\\*\\* 正常显示星号 \\*\\*\n\n\\ 反斜线\n\n` 反引号\n\n- 星号\n\n_ 下划线\n\n{} 花括号\n\n[] 方括号\n\n() 小括号\n\n# 井字号\n\n- 加号\n\n* 减号\n\n. 英文句点\n\n! 感叹号\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# Emoji 表情\n\nEmoji 代码列表参考这里\n\n另一个 Emoji 代码列表\n\n去露营了！ ⛺️ 很快回来。\n\n真好笑！ 😂\n\n🎉 💯\n\nEmoji 表情\n\n去露营了！ :tent: 很快回来。\n\n真好笑！ :joy:\n\n:tada: :100:\n\n\n1\n2\n3\n4\n5\n\n\n\n# 目录\n\n\n\n * 二级标题\n   * 三级标题\n * 字体\n * 分割线+删除线+下划线\n * 列表\n * 引用\n * 代码\n * 链接\n * 高级链接\n * 图片\n * 表格\n * 支持 HTML 元素\n * 转义\n * Emoji 表情\n * 目录\n * 自定义容器\n * 卡片列表\n * 徽章组件\n * 外部标签\n * 流程图\n\n\n\n因为 vuepress-vdoing 会自动生成侧边栏，倒也不怎么需要这个了。\n\n目录自动生成\n\n[[toc]]\n\n\n1\n\n\n\n# 自定义容器\n\n目前支持这些容器：tip warning danger note center details right theorem cardList cardImgList\n\n自定义提示标题\n\n这是一个提示\n\n自定义警告标题\n\n这是一个警告\n\n自定义危险标题\n\n这是一个危险警告\n\n自定义笔记标题\n\n这是笔记容器，在 版本才支持哦~\n\n我是居中的内容\n\n（可用于标题、图片等的居中）\n\n自定义详情标题\n\n这是一个详情块，在 IE / Edge 中不生效\n\n自定义右浮动内容\n\n我是右浮动的标题\n\n我是右浮动的链接\n\n牛顿第一定律\n\n假若施加于某物体的外力为零，则该物体的运动速度不变。\n\n自定义右浮动内容\n\n来自 维基百科\n\n\n# 卡片列表\n\n普通卡片列表容器，可用于友情链接、项目推荐、诗词展示等。\n\n麋鹿鲁哟\n\n大道至简，知易行难\n\nXAOXUU\n\n#IOS #Volantis主题作者\n\n平凡的你我\n\n理想成为大牛的小陈同学\n\n- name: 麋鹿鲁哟\n  desc: 大道至简，知易行难\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200122153807.jpg # 可选\n  link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgColor: "#CBEAFA" # 可选，默认var(--bodyBg)。颜色值有#号时请添加单引号\n  textColor: "#6854A1" # 可选，默认var(--textColor)\n- name: XAOXUU\n  desc: "#IOS #Volantis主题作者"\n  avatar: https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png\n  link: https://xaoxuu.com\n  bgColor: "#718971"\n  textColor: "#fff"\n- name: 平凡的你我\n  desc: 理想成为大牛的小陈同学\n  avatar: https://reinness.com/avatar.png\n  link: https://reinness.com\n  bgColor: "#FCDBA0"\n  textColor: "#A05F2C"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n控制一行展示 2 个卡片。\n\n《静夜思》\n\n床前明月光，疑是地上霜。举头望明月，低头思故乡。\n\nVdoing\n\n🚀一款简洁高效的VuePress 知识管理&博客(blog) 主题\n\n- name: 《静夜思》\n  desc: 床前明月光，疑是地上霜。举头望明月，低头思故乡。\n  bgColor: "#F0DFB1"\n  textColor: "#242A38"\n- name: Vdoing\n  desc: 🚀一款简洁高效的VuePress 知识管理&博客(blog) 主题\n  link: https://github.com/xugaoyi/vuepress-theme-vdoing\n  bgColor: "#DFEEE7"\n  textColor: "#2A3344"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n还可以展示为图文卡片列表。\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nEvan Xu\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nEvan Xu\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nEvan Xu\n\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200529162253.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容 # 描述，可选\n  author: Evan Xu # 作者，可选\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg # 头像，可选\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100256.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: Evan Xu\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100257.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: Evan Xu\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 徽章组件\n\nBadge\n\n《沁园春·雪》\n\n北国风光，千里冰封，万里雪飘。\n\n> : 北方的风光。\n\nBadge\n\n<Badge text="译文" type="error" vertical="middle"/>\n\n\n1\n\n\n\n# 外部标签\n\n\n\n外部标签\n\n![npm](https://img.shields.io/npm/v/@kaokei/di)\n![star](https://img.shields.io/github/stars/kaokei/di)\n\n\n1\n2\n\n\n\n# 流程图\n\nmermaidjs 流程图编辑器',normalizedContent:'# markdown 示例文章\n\n\n# 一级标题\n\n一级标题应该只有一个，而且第一个一级标题不会显示出来。这里其实是第二个一级标题。\n\n\n# 二级标题\n\n注意到只有二级标题才有底部横线。\n\n\n# 三级标题\n\n注意到侧边栏只会显示到三级标题。\n\n# 四级标题\n\n# 五级标题\n\n# 六级标题\n\n标题\n\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n#### 四级标题\n\n##### 五级标题\n\n###### 六级标题\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 字体\n\n斜体文本 斜体文本\n\n粗体文本 粗体文本\n\n粗斜体文本 粗斜体文本\n\n字体\n\n_斜体文本_\n_斜体文本_\n\n**粗体文本**\n**粗体文本**\n\n**_粗斜体文本_**\n**_粗斜体文本_**\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 分割线+删除线+下划线\n\n---可以画一个全宽的横线。注意到上面的横线是二级标题自带的横线，下面才是我画的横线。\n\n----------------------------------------\n\nbaidu.com\n\n带下划线文本\n\n分割线\n\n---\n\n~~baidu.com~~\n\n<u>带下划线文本</u>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 列表\n\n分为有序列表和无序列表\n\n * 第一项\n   * 第一项嵌套的第一个元素\n   * 第一项嵌套的第二个元素\n * 第二项\n   * 第二项嵌套的第一个元素\n   * 第二项嵌套的第二个元素\n * 第三项\n   1. 第 3 项嵌套的第 1 个元素\n   2. 第 3 项嵌套的第 2 个元素\n   3. 第 3 项嵌套的第 3 个元素\n\n列表\n\n- 第一项\n  - 第一项嵌套的第一个元素\n  - 第一项嵌套的第二个元素\n- 第二项\n  - 第二项嵌套的第一个元素\n  - 第二项嵌套的第二个元素\n- 第三项\n  1. 第 3 项嵌套的第 1 个元素\n  2. 第 3 项嵌套的第 2 个元素\n  3. 第 3 项嵌套的第 3 个元素\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 引用\n\n嵌套引用\n\n> 最外层\n> \n> > 第一层嵌套\n> > \n> > > 第二层嵌套\n\n区块中使用列表\n\n> 区块中使用列表\n> \n>  1. 第一项\n>  2. 第二项\n> \n>  * 第一项\n>  * 第二项\n>  * 第三项\n\n列表中使用区块\n\n * 第一项\n   \n   > 菜鸟教程 学的不仅是技术更是梦想\n\n * 第二项\n\n引用\n\n> 最外层\n>\n> > 第一层嵌套\n> >\n> > > 第二层嵌套\n\n\n1\n2\n3\n4\n5\n\n\n\n# 代码\n\n这是内联代码：printf() 函数\n\n以下是代码块。这里是合法的语言列表\n\n常见语言代码：markdown js css html bash ts\n\n\n\n \n\n\n\n$(document).ready(function () {\n  alert("runoob");\n});\n\n\n1\n2\n3\n\n代码\n\n`printf()`\n\n```javascript {2}\n$(document).ready(function () {\n  alert("runoob");\n});\n```\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 链接\n\n百度地址\n\nhttps://www.baidu.com/\n\n链接\n\n[百度地址](https://www.baidu.com/)\n\n<https://www.baidu.com/>\n\n\n1\n2\n3\n\n\n\n# 高级链接\n\n这个链接用 1 作为 google 网址变量 google\n\n这个链接用 baidu 作为网址变量 baidu\n\n这个链接用 kaokei 作为图片网址变量 kaokei\n\n然后在文档的结尾为变量赋值（网址）\n\n高级链接\n\n这个链接用 1 作为 google 网址变量 [google][1]\n\n这个链接用 baidu 作为网址变量 [baidu][baidu]\n\n然后在文档的结尾为变量赋值（网址）\n\n[1]: https://www.google.com/\n[baidu]: https://www.baidu.com/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 图片\n\n\n\n图片\n\n![kaokei 图标](https://cdn.jsdelivr.net/gh/kaokei/static-cdn/logo/white/logo@512.png "kaokei")\n\n<img title="kaokei" alt="kaokei" src="https://cdn.jsdelivr.net/gh/kaokei/static-cdn/logo/white/logo@512.png" width="20%">\n\n\n1\n2\n3\n\n\n\n# 表格\n\n左对齐     居中对齐   右对齐\n单元格 1   单元格    单元格\n单元格 2   单元格    单元格\n单元格 3   单元格    单元格\n单元格 4   单元格    单元格\n\n表格\n\n| 左对齐   | 居中对齐 | 右对齐 |\n| :------- | :------: | -----: |\n| 单元格 1 |  单元格  | 单元格 |\n| 单元格 2 |  单元格  | 单元格 |\n| 单元格 3 |  单元格  | 单元格 |\n| 单元格 4 |  单元格  | 单元格 |\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 支持 html 元素\n\n目前支持的 html 元素有：<kbd> <b> <i> <em> <sup> <sub> <br> <mark>等。\n\n使用 ctrl+alt+del 重启电脑\n\nvdoing 是一款简洁高效的知识管理和博客主题\n\n支持 html 元素\n\n使用 <kbd>ctrl</kbd>+<kbd>alt</kbd>+<kbd>del</kbd> 重启电脑\n\nvdoing 是一款简洁高效的<mark>知识管理和博客</mark>主题\n\n\n1\n2\n3\n\n\n\n# 转义\n\n文本加粗\n\n** 正常显示星号 **\n\n转义\n\n**文本加粗**\n\n\\*\\* 正常显示星号 \\*\\*\n\n\\ 反斜线\n\n` 反引号\n\n- 星号\n\n_ 下划线\n\n{} 花括号\n\n[] 方括号\n\n() 小括号\n\n# 井字号\n\n- 加号\n\n* 减号\n\n. 英文句点\n\n! 感叹号\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# emoji 表情\n\nemoji 代码列表参考这里\n\n另一个 emoji 代码列表\n\n去露营了！ ⛺️ 很快回来。\n\n真好笑！ 😂\n\n🎉 💯\n\nemoji 表情\n\n去露营了！ :tent: 很快回来。\n\n真好笑！ :joy:\n\n:tada: :100:\n\n\n1\n2\n3\n4\n5\n\n\n\n# 目录\n\n\n\n * 二级标题\n   * 三级标题\n * 字体\n * 分割线+删除线+下划线\n * 列表\n * 引用\n * 代码\n * 链接\n * 高级链接\n * 图片\n * 表格\n * 支持 html 元素\n * 转义\n * emoji 表情\n * 目录\n * 自定义容器\n * 卡片列表\n * 徽章组件\n * 外部标签\n * 流程图\n\n\n\n因为 vuepress-vdoing 会自动生成侧边栏，倒也不怎么需要这个了。\n\n目录自动生成\n\n[[toc]]\n\n\n1\n\n\n\n# 自定义容器\n\n目前支持这些容器：tip warning danger note center details right theorem cardlist cardimglist\n\n自定义提示标题\n\n这是一个提示\n\n自定义警告标题\n\n这是一个警告\n\n自定义危险标题\n\n这是一个危险警告\n\n自定义笔记标题\n\n这是笔记容器，在 版本才支持哦~\n\n我是居中的内容\n\n（可用于标题、图片等的居中）\n\n自定义详情标题\n\n这是一个详情块，在 ie / edge 中不生效\n\n自定义右浮动内容\n\n我是右浮动的标题\n\n我是右浮动的链接\n\n牛顿第一定律\n\n假若施加于某物体的外力为零，则该物体的运动速度不变。\n\n自定义右浮动内容\n\n来自 维基百科\n\n\n# 卡片列表\n\n普通卡片列表容器，可用于友情链接、项目推荐、诗词展示等。\n\n麋鹿鲁哟\n\n大道至简，知易行难\n\nxaoxuu\n\n#ios #volantis主题作者\n\n平凡的你我\n\n理想成为大牛的小陈同学\n\n- name: 麋鹿鲁哟\n  desc: 大道至简，知易行难\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200122153807.jpg # 可选\n  link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgcolor: "#cbeafa" # 可选，默认var(--bodybg)。颜色值有#号时请添加单引号\n  textcolor: "#6854a1" # 可选，默认var(--textcolor)\n- name: xaoxuu\n  desc: "#ios #volantis主题作者"\n  avatar: https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png\n  link: https://xaoxuu.com\n  bgcolor: "#718971"\n  textcolor: "#fff"\n- name: 平凡的你我\n  desc: 理想成为大牛的小陈同学\n  avatar: https://reinness.com/avatar.png\n  link: https://reinness.com\n  bgcolor: "#fcdba0"\n  textcolor: "#a05f2c"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n控制一行展示 2 个卡片。\n\n《静夜思》\n\n床前明月光，疑是地上霜。举头望明月，低头思故乡。\n\nvdoing\n\n🚀一款简洁高效的vuepress 知识管理&博客(blog) 主题\n\n- name: 《静夜思》\n  desc: 床前明月光，疑是地上霜。举头望明月，低头思故乡。\n  bgcolor: "#f0dfb1"\n  textcolor: "#242a38"\n- name: vdoing\n  desc: 🚀一款简洁高效的vuepress 知识管理&博客(blog) 主题\n  link: https://github.com/xugaoyi/vuepress-theme-vdoing\n  bgcolor: "#dfeee7"\n  textcolor: "#2a3344"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n还可以展示为图文卡片列表。\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nevan xu\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nevan xu\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nevan xu\n\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200529162253.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容 # 描述，可选\n  author: evan xu # 作者，可选\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg # 头像，可选\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100256.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: evan xu\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n- img: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100257.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: evan xu\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 徽章组件\n\nbadge\n\n《沁园春·雪》\n\n北国风光，千里冰封，万里雪飘。\n\n> : 北方的风光。\n\nbadge\n\n<badge text="译文" type="error" vertical="middle"/>\n\n\n1\n\n\n\n# 外部标签\n\n\n\n外部标签\n\n![npm](https://img.shields.io/npm/v/@kaokei/di)\n![star](https://img.shields.io/github/stars/kaokei/di)\n\n\n1\n2\n\n\n\n# 流程图\n\nmermaidjs 流程图编辑器',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"npmrc总结",frontmatter:{title:"npmrc总结",date:"2022-01-11T14:51:52.000Z",permalink:"/pages/8255ce/",sidebar:"auto",categories:["随笔"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/npmrc%E6%80%BB%E7%BB%93.html",relativePath:"_posts/npmrc总结.md",key:"v-8baa32f8",path:"/pages/8255ce/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"pnpm使用总结",frontmatter:{title:"pnpm使用总结",date:"2022-01-11T14:40:09.000Z",permalink:"/pages/91c82f/",sidebar:"auto",categories:["随笔"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/pnpm%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93.html",relativePath:"_posts/pnpm使用总结.md",key:"v-46ea4296",path:"/pages/91c82f/",headersStr:null,content:"# pnpm 使用总结\n\n推荐个人项目统一使用 pnpm。公司项目暂时不使用。",normalizedContent:"# pnpm 使用总结\n\n推荐个人项目统一使用 pnpm。公司项目暂时不使用。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"依赖注入",frontmatter:{author:"kaokei",title:"依赖注入",date:"2021-12-19T16:52:54.000Z",permalink:"/pages/8b786e/",sidebar:"auto",categories:["随笔","技术"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/reactive-analysis.html",relativePath:"_posts/reactive-analysis.md",key:"v-080301c7",path:"/pages/8b786e/",headers:[{level:2,title:"doux",slug:"doux",normalizedTitle:"doux",charIndex:2},{level:2,title:"dob",slug:"dob",normalizedTitle:"dob",charIndex:847},{level:2,title:"dob-react",slug:"dob-react",normalizedTitle:"dob-react",charIndex:2054},{level:2,title:"concent",slug:"concent",normalizedTitle:"concent",charIndex:2601},{level:2,title:"@nx-js/observer-util",slug:"nx-js-observer-util",normalizedTitle:"@nx-js/observer-util",charIndex:4826},{level:2,title:"preact-nx-observer",slug:"preact-nx-observer",normalizedTitle:"preact-nx-observer",charIndex:5128},{level:2,title:"react-easy-state",slug:"react-easy-state",normalizedTitle:"react-easy-state",charIndex:5359},{level:2,title:"mobx",slug:"mobx",normalizedTitle:"mobx",charIndex:5987},{level:2,title:"vue-next",slug:"vue-next",normalizedTitle:"vue-next",charIndex:1222},{level:2,title:"constate",slug:"constate",normalizedTitle:"constate",charIndex:8049},{level:2,title:"react 类组件 vs vue 类组件",slug:"react-类组件-vs-vue-类组件",normalizedTitle:"react 类组件 vs vue 类组件",charIndex:8256},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:8445}],headersStr:"doux dob dob-react concent @nx-js/observer-util preact-nx-observer react-easy-state mobx vue-next constate react 类组件 vs vue 类组件 总结",content:'# doux\n\n该库似乎已经被删除了，但是历史代码还存在，代码实现比较简单，非常方便入门分析。\n\nobservable 相当于 reactive observe 相当于 watch observer 相当于 watchEffect\n\n其实 observable 和另外两个是比较独立的，可以独立分析。\n\nobservable 在 get/ownKeys/has 三个方法中会调用 track 方法来收集依赖。在 set/deleteProperty 这个两个方法中会调用 trigger 方法来触发副作用。\n\n对比 track 和 trigger 的参数部分，主要是通过 target+key 这两个参数作为链接的桥梁。简单的理解为在 track 时，把 activeEffect 存储到 target+key 对应的 map 中，当 trigger 发生时就可以通过 target+key 来获取曾经保存的 activeEffect，然后执行它。关键点在于 activeEffect 是一个运行时产生的，observable 本身是不依赖它的。\n\n提到 activeEffect，它是怎么产生的呢？其实就是由 observe 产生的。observe 的返回值就是 effect。 其中这段代码说明了 activeEffect 是怎么产生的：\n\neffectStack.push(effect);\nactiveEffect = effect;\nreturn Reflect.apply(fn, ctx, args);\n\n\n1\n2\n3\n\n\n其中fn就是我们想要观察的代码，想要收集依赖的代码。所以在执行该代码之前，我们提前准备好 activeEffect。\n\nobserver 主要是实现了对组件的观察，主要是判断 effect 是否有 cb 属性。\n\neffects.forEach((e: Effect) => (isFn(e.cb) ? e.cb(e) : e()));\n\n\n1\n\n\n\n# dob\n\n首先查看最简单的例子。\n\nimport { observable, observe } from "dob";\n\nconst obj = observable({ a: 1 });\n\nobserve(() => {\n  debugger;\n  console.log("obj.a has changed to", obj.a);\n}); // <· obj.a has changed to 1\n\nobj.a = 2; // <· obj.a has changed to 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n首先 observable 会把一个普通对象转变为 Proxy 对象。主要是 get/set/deleteProperty 这三个属性。这种转变只是为了后续作服务的。\n\n当执行 observe 函数时，类似于 vue-next 中的 watchEffect，它是立即执行的。关键在于 Reaction 中有一段代码是这样的。\n\nglobal_state_1.globalState.currentReaction = this; // Clear bindings first.\n\nthis.clearBinding();\n\ntry {\n  callback({\n    debugId: global_state_1.globalState.currentDebugId\n  });\n} finally {\n  global_state_1.globalState.currentReaction = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这段代码是非常经典的，首先设置当前的依赖项 currentReaction，然后执行 callback，再清除 currentReaction。这样在执行 callback 的过程中，会触发 observable 中设置的 getter 函数。会把 currentReaction 当作所有数据的依赖。关键代码在bindCurrentReaction中实现。\n\n相应的当我们执行obj.a = 2时，会触发 Proxy 的 setter 函数，会调用 queueRunReactions 从而找到刚才保存下来的 currentReaction，然后就可以runReaction(currentReaction)。\n\n重点需要关注Reaction的实现，类似于 vue-next 中的effect的实现。\n\n另一个比较重要的点是这个库非常依赖全局状态管理，主要集中在 global-state.ts 文件中，尤其是其中的 objectReactionBindings 这个对象。它全局保存了数据和 Reaction 的依赖关系。\n\n依赖dependency-inject实现依赖注入的功能。\n\n\n# dob-react\n\n主要是提供了 Provider 和 Connect 这两个方法。可以在 Provider 这个组件上声明任意多个 props，这些 props 数据都会被注入到@Connect装饰的组件中。\n\n也就是说我们自己写的组件如果使用了@Connect装饰器，那么组件内this.props就会自动被注入一些属性，这些属性就是 Provider 上声明的属性。\n\n目前发现的唯一路径是这样的。observe调用new Reaction调用设置currentReaction，然后在访问 getter 时，就会把数据和 currentReaction 绑定起来，也就是bindCurrentReaction。\n\n在 dob 中只能通过observe才能实现依赖收集。在dob-react中，有以下流程： @connect调用mixinAndInject调用mixinLifecycleEvents调用patch调用reactiveMixin调用initialRender调用new Reaction，从而把组件的 render 函数和数据绑定起来。\n\n当然最终的实现部分还是需要注意baseRender和initialRender和reactiveRender之间的关系。\n\n\n# concent\n\n这是一个框架，而且功能非常强大，并且更新非常活跃。同时支持类组件和函数组件。唯一我不太喜欢的地方可能就是过于复杂了，上手成本有点高，再加上使用字符串来区分模块也是一个原罪。不过它仍然是一个非常优秀的框架。\n\n我这里重点关注一下 register 和 useConcent 是如何实现组件的响应式更新的。\n\n参考官方文档中最简单的例子\n\nfunction Demo() {\n  const { state, setState } = useConcent({ module: "foo" });\n  const changeName = e => setState({ name: e.target.value });\n}\n\n\n1\n2\n3\n4\n\n\n可以猜测到 useConcent 本身是不需要做依赖收集的。因为我们还是需要手动调用setState方法去更新数据，这时可以强制调用forseUpdate方法去更新组件。\n\n分析源码可知，useConcent 返回值是一个CcHook的实例对象。这个实例对象的 state 和 setState\b 就是React.useState的返回值。综上 useConcent 就是对React.useState的封装，说明我猜测的没有错。\n\n我还发现 useConcent 是不支持直接 mutable 修改 state 数据的，只能通过 setState 来修改数据。make-ob-state.js 中的 setter 中是没有 trigger 方法的，说明确实没有实现 mutable 响应式。\n\n当然 useConcent 是需要做到多个组件共享数据的，也就是一个组件修改了数据，可能会影响到别的组件。\n\nuseConcent 调用 buildRef 调用 buildRefCtx，其中 buildRefCtx 会修改 ref.state 属性，该属性会合并当前组件的 state 和 moduleState。这就是 useConcent 从全局获取 moduleState 的过程。\n\n至于 moduleState 状态的改变，是如何改变所有依赖这个 moduleState 所有组件的稍微复杂一些。\n\nbuild-ref-ctx.js 中使用了 makeObState 处理了 state\b 数据，\b 从而利用 Proxy 的 getter 收集依赖。收集依赖的逻辑在 updateDep 函数中。主要是以下代码。\n\n// 这个key代表着refCtx，从而可以利用这个refCtx来更新组件\nconst ccUniqueKey = refCtx.ccUniqueKey;\n// 这个key代表着数据foo/count\nconst waKey = makeWaKey(module, key);\n// 最终在wakey-ukey-map.js文件中把这两个key通过waKey2uKeyMap关联起来。\n\n\n1\n2\n3\n4\n5\n\n\n当用户点击某个按钮，触发点击事件，然后调用 setState 去修改数据时，这个 setState 其实是在 build-ref-ctx.js 文件中定义的，最终会调用 changeState 调用 changeRefState。 changeRefState 会调用 triggerBroadcastState 会调用 broadcastState，其中有个重要的函数是 findUpdateRefs，这个函数会返回所有依赖了变更数据的 ref 的 key。有了这个 key，再加上我们还有全局的 ref 对象池。\n\n// 获取全局ref对象池，是一个Record<string, Ref>的对象\nconst ccUKey2ref = ccContext.ccUKey2ref;\n// 通过key和全局ref对象池，就能获取到ref对象\nconst ref = ccUKey2ref[refKey];\n// 有了ref对象，就能触发这个ref上的setState方法，从而\b更新组件\ntriggerReactSetState(ref);\n\n\n1\n2\n3\n4\n5\n6\n\n\n以上分析我是通过 debug 代码观察到 \b 的整个过程。当然我只是观察了最简单的两个组件依赖同一个 module 的过程。\n\n我观察到的最大的结论是 useConcent\b 没有实现 Proxy 中的 setter 的响应式触发，也就是不支持 mutable 更新数据。第二点就是 concent 在保存数据和视图的依赖关系时，是通过保存 key 与 key 之间的依赖关系，而且还保存了全局的 ref 对象池。从而实现当某个数据变化时，多个依赖该数据的视图都能得到更新。相对应的在很多别的 \b 库中，都是直接通过 map 来保存数据和 Dep 之间的依赖关系。\n\nregister 作为一个装饰器，会包装一个类组件，然后返回一个新的类组件。只需要知道这一行代码即可。\n\nbuildRefCtx(this, params, lite);\n\n\n1\n\n\n上面有提到的 useConcent 的核心代码就是buildRefCtx(hookRef, params, lite);，这行代码内部会重新包装 state 和 setState，从而可以支持 module 等特性。\n\n\n# @nx-js/observer-util\n\nobservable 方法对应的是 reactive 方法，实现原理和 doux 比较一致，只是封装的更好一些。也是在不同的 handler 中处理 track 和 trigger。当然 track 和 trigger 需要处理的是 reaction，相当于 doux 中的 effect。\n\nobserve 和 unobserve 则分别对应的是 watch 和 stopWatch 方法。注意这里使用reaction.scheduler代替了reaction。从而实现了从组件收集依赖和更新组件的分离。这一点和 doux 的cb属性是比较相似的。\n\n\n# preact-nx-observer\n\nobserver 方法支持类组件，这里比较取巧的地方就是在 componentDidMount 中替换了 render 方法。\n\nthis.render = observe(this.render, {\n  scheduler: () => this.setState({}),\n  lazy: true\n});\n\n\n1\n2\n3\n4\n\n\n这一段代码还是比较巧妙的，但就是不知道兼容性如何。而且也没有支持函数组件。\n\n\n# react-easy-state\n\nstore，以及 createStore 都是对 observable 的封装。只是增加了对unstable_batchedUpdates的支持。参考这片文章\n\nview 则是对组件的封装。支持函数组件和类组件。\n\n注意类组件中是在构造函数中替换掉的 render 方法，对比preact-nx-observer是在 componentDidMount 中替换的。我认为在构造函数中替换更符合直觉。\n\n// 针对函数组件的封装\nconst render = useMemo(\n  () =>\n    observe(Comp, {\n      scheduler: () => setState({}),\n      lazy: true\n    }),\n  // Adding the original Comp here is necessary to make React Hot Reload work\n  // it does not affect behavior otherwise\n  [Comp]\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n// 针对类组件的封装\nthis.render = observe(this.render, {\n  scheduler: () => this.setState({}),\n  lazy: true\n});\n\n\n1\n2\n3\n4\n5\n\n\n\n# mobx\n\n// 相当于vue-next中的reactive\nmakeObservable(target, annotations?, options?)\nmakeAutoObservable(target, overrides?, options?)\nobservable(source, overrides?, options?)\n\n\n1\n2\n3\n4\n\n\n需要指定@observable,@action,@computed等来指定各个属性的性质。\n\n// 相当于vue-next中的watch\nreaction(() => value, (value, previousValue, reaction) => { sideEffect }, options?).\n\n\n1\n2\n\n\n// 相当于vue-next中的watchEffect\nautorun(effect: (reaction) => void)\n\n\n1\n2\n\n\n// 对组件的封装\nimport { observer } from "mobx-react-lite"; // Or "mobx-react".\nconst MyComponent = observer(props => ReactElement);\n\n\n1\n2\n3\n\n\n这里的 observer 功能非常强大，只要组件依赖了 observable 数据，不管这个数据的来源是什么，都能触发组件重新渲染。\n\n尤其是对各种情况都考虑的非常周全，值得学习。\n\n\n# vue-next\n\n整个流程比较像@nx-js/observer-util，reactive 也是借助的 Proxy 来实现的，关键是 baseHandler 的实现。然后利用 track 来收集依赖。依赖被转为 effect，又有 activeEffect 和 effectStack 这些概念。\n\n可惜我只想依赖其中的@vue/reactivity 这个库。但是 watch/watchEffect 这两个方法都不包含在内，因为 watch 和 watchEffect 都是和 vue 深度绑定的。\n\n所以如果想要在 react 中使用，则必须实现自己的 watch/watchEffect 方法。\n\n我理解广义 watch 的 api 形式有这 3 种场景：\n\n 1. 指定需要 watch 的数据，可以是对象、数组、函数形式指定依赖数据，当数据有变化时，执行 callback\n 2. 指定一个 effect，第一次立即执行时会收集依赖，后续当这些依赖数据有变化的时候，会再次执行这个 effect\n 3. 指定 effect 和 callback，当 effect 对应的依赖有变化的时候，会执行 callback\n\n很容易发现在 vue-next 中已经实现了watch和watchEffect方法，但是实际上在 dowatch 中，又一个细节实现：\n\nconst runner = effect(getter, {\n  lazy: true,\n  onTrack,\n  onTrigger,\n  scheduler\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n这段代码可以理解为观察 getter 返回的数据是否有变化，如果有变化就执行 scheduler。这就是上面提到的第 3 中 api。而且 1 和 2 就是依赖 3 来实现的。 当 watch 的数据本身看作是一个 getter 时，1 就变成 3 了。 当 effect 等于 callback 时，2 就是 3 的一种特殊形式。 需要注意这里的 3 中的 effect 和 callback 不是完全独立的。如果是完全独立的，应该采用 1 这种形式以 getter 的形式提供观察的数据，而不是以 effect 的形式提供依赖数据。观察如下代码：\n\n// 这里的本意是当state.count变化时，输出state.name\n// 但是这里不应该这么写\nwatch(\n  () => console.log(state.count),\n  () => console.log(state.name)\n);\n// 这里明确以getter的形式提供依赖数据\nwatch(\n  () => state.count,\n  () => console.log(state.name)\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n3 的场景可能是这样的。\n\n// renderView是渲染试图的函数，也是我们观察的effect，当其依赖的数据有变化时，我们可能没有办法直接调用renderView这个函数\n// 我们只能通过另一个函数forceUpdate来触发视图更新\nwatch(\n  () => renderView(someView),\n  () => forceUpdate(someView)\n);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# constate\n\ngithub 网址\n\n我想实现的库可以看作是 constate 的升级版。现在 constate 只是把 hooks 都放到一个全局的空间中。然后达到所有组件可以共享这个 hooks 的状态。\n\n缺点是只有一个全局命名空间。而且服务的形式只能是 hooks，没有依赖注入，没有 mutable 响应式。\n\n优点是简单，而且只依赖 hooks 和 context，应该是兼容并发模式的。\n\n\n# react 类组件 vs vue 类组件\n\nreact 类组件是官方原生支持的，实例属性不是 reactive 的，只有通过 this.setState 修改 this.state 才会 re-render。\n\nvue 类组件必须借助 vue-class-component 才能工作，其原理也是转化为 Option 组件。其中所有实例属性都是 reactive 的。\n\n\n# 总结\n\ndoux 使用函数组件包裹业务组件，也可以看作是observe函数的返回值作为 this.render preact-nx-observer 是observe直接返回新的 render 函数替换 this.render react-easy-state 也是直接替换的 this.render dob-react 是需要自己构建新的 render 函数去替换 this.render concent 主要是对setState的封装，而且不支持 mutable 响应式 mobx 再看看 vue-next 中的 render 函数默认就会收集依赖的，而且会把 render 函数当作一个 watchEffect 来对待',normalizedContent:'# doux\n\n该库似乎已经被删除了，但是历史代码还存在，代码实现比较简单，非常方便入门分析。\n\nobservable 相当于 reactive observe 相当于 watch observer 相当于 watcheffect\n\n其实 observable 和另外两个是比较独立的，可以独立分析。\n\nobservable 在 get/ownkeys/has 三个方法中会调用 track 方法来收集依赖。在 set/deleteproperty 这个两个方法中会调用 trigger 方法来触发副作用。\n\n对比 track 和 trigger 的参数部分，主要是通过 target+key 这两个参数作为链接的桥梁。简单的理解为在 track 时，把 activeeffect 存储到 target+key 对应的 map 中，当 trigger 发生时就可以通过 target+key 来获取曾经保存的 activeeffect，然后执行它。关键点在于 activeeffect 是一个运行时产生的，observable 本身是不依赖它的。\n\n提到 activeeffect，它是怎么产生的呢？其实就是由 observe 产生的。observe 的返回值就是 effect。 其中这段代码说明了 activeeffect 是怎么产生的：\n\neffectstack.push(effect);\nactiveeffect = effect;\nreturn reflect.apply(fn, ctx, args);\n\n\n1\n2\n3\n\n\n其中fn就是我们想要观察的代码，想要收集依赖的代码。所以在执行该代码之前，我们提前准备好 activeeffect。\n\nobserver 主要是实现了对组件的观察，主要是判断 effect 是否有 cb 属性。\n\neffects.foreach((e: effect) => (isfn(e.cb) ? e.cb(e) : e()));\n\n\n1\n\n\n\n# dob\n\n首先查看最简单的例子。\n\nimport { observable, observe } from "dob";\n\nconst obj = observable({ a: 1 });\n\nobserve(() => {\n  debugger;\n  console.log("obj.a has changed to", obj.a);\n}); // <· obj.a has changed to 1\n\nobj.a = 2; // <· obj.a has changed to 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n首先 observable 会把一个普通对象转变为 proxy 对象。主要是 get/set/deleteproperty 这三个属性。这种转变只是为了后续作服务的。\n\n当执行 observe 函数时，类似于 vue-next 中的 watcheffect，它是立即执行的。关键在于 reaction 中有一段代码是这样的。\n\nglobal_state_1.globalstate.currentreaction = this; // clear bindings first.\n\nthis.clearbinding();\n\ntry {\n  callback({\n    debugid: global_state_1.globalstate.currentdebugid\n  });\n} finally {\n  global_state_1.globalstate.currentreaction = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这段代码是非常经典的，首先设置当前的依赖项 currentreaction，然后执行 callback，再清除 currentreaction。这样在执行 callback 的过程中，会触发 observable 中设置的 getter 函数。会把 currentreaction 当作所有数据的依赖。关键代码在bindcurrentreaction中实现。\n\n相应的当我们执行obj.a = 2时，会触发 proxy 的 setter 函数，会调用 queuerunreactions 从而找到刚才保存下来的 currentreaction，然后就可以runreaction(currentreaction)。\n\n重点需要关注reaction的实现，类似于 vue-next 中的effect的实现。\n\n另一个比较重要的点是这个库非常依赖全局状态管理，主要集中在 global-state.ts 文件中，尤其是其中的 objectreactionbindings 这个对象。它全局保存了数据和 reaction 的依赖关系。\n\n依赖dependency-inject实现依赖注入的功能。\n\n\n# dob-react\n\n主要是提供了 provider 和 connect 这两个方法。可以在 provider 这个组件上声明任意多个 props，这些 props 数据都会被注入到@connect装饰的组件中。\n\n也就是说我们自己写的组件如果使用了@connect装饰器，那么组件内this.props就会自动被注入一些属性，这些属性就是 provider 上声明的属性。\n\n目前发现的唯一路径是这样的。observe调用new reaction调用设置currentreaction，然后在访问 getter 时，就会把数据和 currentreaction 绑定起来，也就是bindcurrentreaction。\n\n在 dob 中只能通过observe才能实现依赖收集。在dob-react中，有以下流程： @connect调用mixinandinject调用mixinlifecycleevents调用patch调用reactivemixin调用initialrender调用new reaction，从而把组件的 render 函数和数据绑定起来。\n\n当然最终的实现部分还是需要注意baserender和initialrender和reactiverender之间的关系。\n\n\n# concent\n\n这是一个框架，而且功能非常强大，并且更新非常活跃。同时支持类组件和函数组件。唯一我不太喜欢的地方可能就是过于复杂了，上手成本有点高，再加上使用字符串来区分模块也是一个原罪。不过它仍然是一个非常优秀的框架。\n\n我这里重点关注一下 register 和 useconcent 是如何实现组件的响应式更新的。\n\n参考官方文档中最简单的例子\n\nfunction demo() {\n  const { state, setstate } = useconcent({ module: "foo" });\n  const changename = e => setstate({ name: e.target.value });\n}\n\n\n1\n2\n3\n4\n\n\n可以猜测到 useconcent 本身是不需要做依赖收集的。因为我们还是需要手动调用setstate方法去更新数据，这时可以强制调用forseupdate方法去更新组件。\n\n分析源码可知，useconcent 返回值是一个cchook的实例对象。这个实例对象的 state 和 setstate\b 就是react.usestate的返回值。综上 useconcent 就是对react.usestate的封装，说明我猜测的没有错。\n\n我还发现 useconcent 是不支持直接 mutable 修改 state 数据的，只能通过 setstate 来修改数据。make-ob-state.js 中的 setter 中是没有 trigger 方法的，说明确实没有实现 mutable 响应式。\n\n当然 useconcent 是需要做到多个组件共享数据的，也就是一个组件修改了数据，可能会影响到别的组件。\n\nuseconcent 调用 buildref 调用 buildrefctx，其中 buildrefctx 会修改 ref.state 属性，该属性会合并当前组件的 state 和 modulestate。这就是 useconcent 从全局获取 modulestate 的过程。\n\n至于 modulestate 状态的改变，是如何改变所有依赖这个 modulestate 所有组件的稍微复杂一些。\n\nbuild-ref-ctx.js 中使用了 makeobstate 处理了 state\b 数据，\b 从而利用 proxy 的 getter 收集依赖。收集依赖的逻辑在 updatedep 函数中。主要是以下代码。\n\n// 这个key代表着refctx，从而可以利用这个refctx来更新组件\nconst ccuniquekey = refctx.ccuniquekey;\n// 这个key代表着数据foo/count\nconst wakey = makewakey(module, key);\n// 最终在wakey-ukey-map.js文件中把这两个key通过wakey2ukeymap关联起来。\n\n\n1\n2\n3\n4\n5\n\n\n当用户点击某个按钮，触发点击事件，然后调用 setstate 去修改数据时，这个 setstate 其实是在 build-ref-ctx.js 文件中定义的，最终会调用 changestate 调用 changerefstate。 changerefstate 会调用 triggerbroadcaststate 会调用 broadcaststate，其中有个重要的函数是 findupdaterefs，这个函数会返回所有依赖了变更数据的 ref 的 key。有了这个 key，再加上我们还有全局的 ref 对象池。\n\n// 获取全局ref对象池，是一个record<string, ref>的对象\nconst ccukey2ref = cccontext.ccukey2ref;\n// 通过key和全局ref对象池，就能获取到ref对象\nconst ref = ccukey2ref[refkey];\n// 有了ref对象，就能触发这个ref上的setstate方法，从而\b更新组件\ntriggerreactsetstate(ref);\n\n\n1\n2\n3\n4\n5\n6\n\n\n以上分析我是通过 debug 代码观察到 \b 的整个过程。当然我只是观察了最简单的两个组件依赖同一个 module 的过程。\n\n我观察到的最大的结论是 useconcent\b 没有实现 proxy 中的 setter 的响应式触发，也就是不支持 mutable 更新数据。第二点就是 concent 在保存数据和视图的依赖关系时，是通过保存 key 与 key 之间的依赖关系，而且还保存了全局的 ref 对象池。从而实现当某个数据变化时，多个依赖该数据的视图都能得到更新。相对应的在很多别的 \b 库中，都是直接通过 map 来保存数据和 dep 之间的依赖关系。\n\nregister 作为一个装饰器，会包装一个类组件，然后返回一个新的类组件。只需要知道这一行代码即可。\n\nbuildrefctx(this, params, lite);\n\n\n1\n\n\n上面有提到的 useconcent 的核心代码就是buildrefctx(hookref, params, lite);，这行代码内部会重新包装 state 和 setstate，从而可以支持 module 等特性。\n\n\n# @nx-js/observer-util\n\nobservable 方法对应的是 reactive 方法，实现原理和 doux 比较一致，只是封装的更好一些。也是在不同的 handler 中处理 track 和 trigger。当然 track 和 trigger 需要处理的是 reaction，相当于 doux 中的 effect。\n\nobserve 和 unobserve 则分别对应的是 watch 和 stopwatch 方法。注意这里使用reaction.scheduler代替了reaction。从而实现了从组件收集依赖和更新组件的分离。这一点和 doux 的cb属性是比较相似的。\n\n\n# preact-nx-observer\n\nobserver 方法支持类组件，这里比较取巧的地方就是在 componentdidmount 中替换了 render 方法。\n\nthis.render = observe(this.render, {\n  scheduler: () => this.setstate({}),\n  lazy: true\n});\n\n\n1\n2\n3\n4\n\n\n这一段代码还是比较巧妙的，但就是不知道兼容性如何。而且也没有支持函数组件。\n\n\n# react-easy-state\n\nstore，以及 createstore 都是对 observable 的封装。只是增加了对unstable_batchedupdates的支持。参考这片文章\n\nview 则是对组件的封装。支持函数组件和类组件。\n\n注意类组件中是在构造函数中替换掉的 render 方法，对比preact-nx-observer是在 componentdidmount 中替换的。我认为在构造函数中替换更符合直觉。\n\n// 针对函数组件的封装\nconst render = usememo(\n  () =>\n    observe(comp, {\n      scheduler: () => setstate({}),\n      lazy: true\n    }),\n  // adding the original comp here is necessary to make react hot reload work\n  // it does not affect behavior otherwise\n  [comp]\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n// 针对类组件的封装\nthis.render = observe(this.render, {\n  scheduler: () => this.setstate({}),\n  lazy: true\n});\n\n\n1\n2\n3\n4\n5\n\n\n\n# mobx\n\n// 相当于vue-next中的reactive\nmakeobservable(target, annotations?, options?)\nmakeautoobservable(target, overrides?, options?)\nobservable(source, overrides?, options?)\n\n\n1\n2\n3\n4\n\n\n需要指定@observable,@action,@computed等来指定各个属性的性质。\n\n// 相当于vue-next中的watch\nreaction(() => value, (value, previousvalue, reaction) => { sideeffect }, options?).\n\n\n1\n2\n\n\n// 相当于vue-next中的watcheffect\nautorun(effect: (reaction) => void)\n\n\n1\n2\n\n\n// 对组件的封装\nimport { observer } from "mobx-react-lite"; // or "mobx-react".\nconst mycomponent = observer(props => reactelement);\n\n\n1\n2\n3\n\n\n这里的 observer 功能非常强大，只要组件依赖了 observable 数据，不管这个数据的来源是什么，都能触发组件重新渲染。\n\n尤其是对各种情况都考虑的非常周全，值得学习。\n\n\n# vue-next\n\n整个流程比较像@nx-js/observer-util，reactive 也是借助的 proxy 来实现的，关键是 basehandler 的实现。然后利用 track 来收集依赖。依赖被转为 effect，又有 activeeffect 和 effectstack 这些概念。\n\n可惜我只想依赖其中的@vue/reactivity 这个库。但是 watch/watcheffect 这两个方法都不包含在内，因为 watch 和 watcheffect 都是和 vue 深度绑定的。\n\n所以如果想要在 react 中使用，则必须实现自己的 watch/watcheffect 方法。\n\n我理解广义 watch 的 api 形式有这 3 种场景：\n\n 1. 指定需要 watch 的数据，可以是对象、数组、函数形式指定依赖数据，当数据有变化时，执行 callback\n 2. 指定一个 effect，第一次立即执行时会收集依赖，后续当这些依赖数据有变化的时候，会再次执行这个 effect\n 3. 指定 effect 和 callback，当 effect 对应的依赖有变化的时候，会执行 callback\n\n很容易发现在 vue-next 中已经实现了watch和watcheffect方法，但是实际上在 dowatch 中，又一个细节实现：\n\nconst runner = effect(getter, {\n  lazy: true,\n  ontrack,\n  ontrigger,\n  scheduler\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n这段代码可以理解为观察 getter 返回的数据是否有变化，如果有变化就执行 scheduler。这就是上面提到的第 3 中 api。而且 1 和 2 就是依赖 3 来实现的。 当 watch 的数据本身看作是一个 getter 时，1 就变成 3 了。 当 effect 等于 callback 时，2 就是 3 的一种特殊形式。 需要注意这里的 3 中的 effect 和 callback 不是完全独立的。如果是完全独立的，应该采用 1 这种形式以 getter 的形式提供观察的数据，而不是以 effect 的形式提供依赖数据。观察如下代码：\n\n// 这里的本意是当state.count变化时，输出state.name\n// 但是这里不应该这么写\nwatch(\n  () => console.log(state.count),\n  () => console.log(state.name)\n);\n// 这里明确以getter的形式提供依赖数据\nwatch(\n  () => state.count,\n  () => console.log(state.name)\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n3 的场景可能是这样的。\n\n// renderview是渲染试图的函数，也是我们观察的effect，当其依赖的数据有变化时，我们可能没有办法直接调用renderview这个函数\n// 我们只能通过另一个函数forceupdate来触发视图更新\nwatch(\n  () => renderview(someview),\n  () => forceupdate(someview)\n);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# constate\n\ngithub 网址\n\n我想实现的库可以看作是 constate 的升级版。现在 constate 只是把 hooks 都放到一个全局的空间中。然后达到所有组件可以共享这个 hooks 的状态。\n\n缺点是只有一个全局命名空间。而且服务的形式只能是 hooks，没有依赖注入，没有 mutable 响应式。\n\n优点是简单，而且只依赖 hooks 和 context，应该是兼容并发模式的。\n\n\n# react 类组件 vs vue 类组件\n\nreact 类组件是官方原生支持的，实例属性不是 reactive 的，只有通过 this.setstate 修改 this.state 才会 re-render。\n\nvue 类组件必须借助 vue-class-component 才能工作，其原理也是转化为 option 组件。其中所有实例属性都是 reactive 的。\n\n\n# 总结\n\ndoux 使用函数组件包裹业务组件，也可以看作是observe函数的返回值作为 this.render preact-nx-observer 是observe直接返回新的 render 函数替换 this.render react-easy-state 也是直接替换的 this.render dob-react 是需要自己构建新的 render 函数去替换 this.render concent 主要是对setstate的封装，而且不支持 mutable 响应式 mobx 再看看 vue-next 中的 render 函数默认就会收集依赖的，而且会把 render 函数当作一个 watcheffect 来对待',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"参考文章",frontmatter:{author:"kaokei",title:"参考文章",date:"2021-12-19T16:52:54.000Z",permalink:"/pages/5b7b92/",sidebar:"auto",categories:["随笔","技术"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/",relativePath:"_posts/readme.md",key:"v-8adb67f4",path:"/pages/5b7b92/",headersStr:null,content:"这里记录一些我对前端某些知识点的理解\n\nwatch在vue中是不需要返回render函数的，而是返回的stopWatchHandler，是因为vue能完全控制模版的更新。 但是在react中，我们不能直接调用react组件的render函数，只能通过setState来间接触发组件更新。\n\nsvelte无法解决this问题，svelte无法解决依赖注入问题，因为导入的是store。而不是原始对象。但是在vue中因为使用的是proxy，所以导入的还是原始对象",normalizedContent:"这里记录一些我对前端某些知识点的理解\n\nwatch在vue中是不需要返回render函数的，而是返回的stopwatchhandler，是因为vue能完全控制模版的更新。 但是在react中，我们不能直接调用react组件的render函数，只能通过setstate来间接触发组件更新。\n\nsvelte无法解决this问题，svelte无法解决依赖注入问题，因为导入的是store。而不是原始对象。但是在vue中因为使用的是proxy，所以导入的还是原始对象",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"toke和cookie",frontmatter:{title:"toke和cookie",date:"2022-01-07T10:24:08.000Z",permalink:"/pages/fff5cd/",sidebar:"auto",categories:["随笔"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/toke%E5%92%8Ccookie.html",relativePath:"_posts/toke和cookie.md",key:"v-490a2e94",path:"/pages/fff5cd/",headers:[{level:2,title:"不关心安全",slug:"不关心安全",normalizedTitle:"不关心安全",charIndex:21},{level:2,title:"关心安全",slug:"关心安全",normalizedTitle:"关心安全",charIndex:22},{level:2,title:"不建议的方案",slug:"不建议的方案",normalizedTitle:"不建议的方案",charIndex:593},{level:2,title:"jwt 适用场景",slug:"jwt-适用场景",normalizedTitle:"jwt 适用场景",charIndex:1578},{level:2,title:"服务器端让 jwt token 失效",slug:"服务器端让-jwt-token-失效",normalizedTitle:"服务器端让 jwt token 失效",charIndex:1743},{level:2,title:"参考文档",slug:"参考文档",normalizedTitle:"参考文档",charIndex:2138}],headersStr:"不关心安全 关心安全 不建议的方案 jwt 适用场景 服务器端让 jwt token 失效 参考文档",content:"# token 和 cookie\n\n\n# 不关心安全\n\n无脑选择 jwt token。直接把 token 存储在 localstorage 中即可。\n\n虽然会放大 xss 攻击的危害。但是都已经假设网站存在 xss 攻击了，危害又能小多少？\n\n最大的优点是可以在不同的域名之间传递 token，使用方便。\n\n最大的缺点时不够安全，主要是会放大 xss 攻击的危害。\n\n一般使用 jwt token 不会直接只是使用 jwt token，因为 jwt token 还有一个缺点是不能在服务器端销毁。所以一般需要配合 refresh token 来实现服务器端销毁。\n\n\n# 关心安全\n\n选择普通 cookie 机制，设置 cookie 中的 cookieId 为 http-only,secure,same-site。\n\nhttp-only 强制该 cookieId 不能被 js 读取。\n\nsecure 强制只能在 https 中使用该 cookie。\n\nsame-site 可以避免 csrf 攻击。但是对于低版本浏览器需要采用另一种方案 csrf-token。\n\n最大的缺点是不能在不同的域名之间共享 cookieId。\n\n另一种缺点就是服务器端消费 token 时强制指定从 header 中的 Authorization 字段获取。此时的 cookie 就无能为力了。\n\n\n# 不建议的方案\n\n第一种就是把 jwt token 写入到 cookie 中，虽然可以享受到 cookie 在安全方面的利益，但是损失了 jwt token 本身的便利性，关键是前端不能读取 cookie 中的 token，也就不能使用 jwt token 中的数据。这种使用方案本质上就是一个 cookieId。\n\n第二种方案我称之为大聪明方案，就是把 jwt 的 refresh token 放到 cookie 中，然后每次刷新页面都会请求接口获取 access token，然后把 access token 存储在内存中。 因为没有持久化，所以刷新页面会丢失 access token。打开一个新页面和新的 tab 页面也会丢失 access token。导致每次都会通过 refresh token 获取新的 access token。 以上都没有问题。关键的问题时不能增加想象中的额外的安全性。因为只要网站存在 xss 漏洞，虽然不能读取 refresh token。但是只要调用一下接口，就能获取 access token。 这样就和把 access token 存储在 localstorage 中没有区别了。 我并不是完全反对这种方案，实际上我是反对这种方案标榜的安全性。我们完全可以把 refresh token 放到 cookie 中，然后把 access token 直接存储在 localstorage 中。分成两个 token 的好处就是缩短了 token 的有效期。比如本来设置 token 的有效期为 7 天，那么就只能等到 7 天后 token 才能失效，因为 token 本身是无状态的。但是分成两个 token 后，refresh token 还是 7 天有效期。但是每次获取的 access token 的有效期可以设置为 10 分钟，这样每隔 10 分钟，都需要通过 refresh token 获取新的 access token。此时需要校验该 refresh token 的有效性，因为 refresh token 是有状态的，服务器端可以设置改 refresh token 为无效 token，这样就算 token 还没有过期，也是无效 token。这样就达到一个效果就是把原来 7 天的有效期缩短到 10 分钟了。\n\n\n# jwt 适用场景\n\n适用于 server-to-server 类型的服务。比如我们开发了一套 api，想对外提供服务，那么可以采用 jwt token 和 refresh token 机制。\n\n适用于移动端 app 中的接口，因为移动端 app 可以把 token 存储在移动端内部，而不依赖 localstorage。\n\n\n# 服务器端让 jwt token 失效\n\n除了采用 refresh token 和 access token 这种方案以外，还可以采用黑名单机制。正常的 cookieId 可以理解为白名单机制，每次判断这个 cookieId 是不是合法的 cookieId 时，都需要从 redis 中查询一次，只有查询到数据就说明这个 cookieId 是合法的。\n\n类似的道理，当需要废弃一个 jwt token 时，我们可以把这个 token 假如到 redis 中作为黑名单。这样每次判断一个 jwt token 是否合法时，除了判断 token 本身是否合法以外，还需要去黑名单中查询一次。如果黑名单中有这个 token，那么就返回 token 已失效。\n\n当然黑名单中的 token 生存时间至少要比 jwt token 剩余时间要长，简单一点可以直接统一设置为 token 的有效期。\n\n\n# 参考文档\n\nIs it safe to store a JWT in localStorage with ReactJS?\n\nAuth0 Token Storage\n\n大聪明方案\n\nsame site 属性解释\n\nJWT authentication: Best practices and when to use it\n\n中肯的建议",normalizedContent:"# token 和 cookie\n\n\n# 不关心安全\n\n无脑选择 jwt token。直接把 token 存储在 localstorage 中即可。\n\n虽然会放大 xss 攻击的危害。但是都已经假设网站存在 xss 攻击了，危害又能小多少？\n\n最大的优点是可以在不同的域名之间传递 token，使用方便。\n\n最大的缺点时不够安全，主要是会放大 xss 攻击的危害。\n\n一般使用 jwt token 不会直接只是使用 jwt token，因为 jwt token 还有一个缺点是不能在服务器端销毁。所以一般需要配合 refresh token 来实现服务器端销毁。\n\n\n# 关心安全\n\n选择普通 cookie 机制，设置 cookie 中的 cookieid 为 http-only,secure,same-site。\n\nhttp-only 强制该 cookieid 不能被 js 读取。\n\nsecure 强制只能在 https 中使用该 cookie。\n\nsame-site 可以避免 csrf 攻击。但是对于低版本浏览器需要采用另一种方案 csrf-token。\n\n最大的缺点是不能在不同的域名之间共享 cookieid。\n\n另一种缺点就是服务器端消费 token 时强制指定从 header 中的 authorization 字段获取。此时的 cookie 就无能为力了。\n\n\n# 不建议的方案\n\n第一种就是把 jwt token 写入到 cookie 中，虽然可以享受到 cookie 在安全方面的利益，但是损失了 jwt token 本身的便利性，关键是前端不能读取 cookie 中的 token，也就不能使用 jwt token 中的数据。这种使用方案本质上就是一个 cookieid。\n\n第二种方案我称之为大聪明方案，就是把 jwt 的 refresh token 放到 cookie 中，然后每次刷新页面都会请求接口获取 access token，然后把 access token 存储在内存中。 因为没有持久化，所以刷新页面会丢失 access token。打开一个新页面和新的 tab 页面也会丢失 access token。导致每次都会通过 refresh token 获取新的 access token。 以上都没有问题。关键的问题时不能增加想象中的额外的安全性。因为只要网站存在 xss 漏洞，虽然不能读取 refresh token。但是只要调用一下接口，就能获取 access token。 这样就和把 access token 存储在 localstorage 中没有区别了。 我并不是完全反对这种方案，实际上我是反对这种方案标榜的安全性。我们完全可以把 refresh token 放到 cookie 中，然后把 access token 直接存储在 localstorage 中。分成两个 token 的好处就是缩短了 token 的有效期。比如本来设置 token 的有效期为 7 天，那么就只能等到 7 天后 token 才能失效，因为 token 本身是无状态的。但是分成两个 token 后，refresh token 还是 7 天有效期。但是每次获取的 access token 的有效期可以设置为 10 分钟，这样每隔 10 分钟，都需要通过 refresh token 获取新的 access token。此时需要校验该 refresh token 的有效性，因为 refresh token 是有状态的，服务器端可以设置改 refresh token 为无效 token，这样就算 token 还没有过期，也是无效 token。这样就达到一个效果就是把原来 7 天的有效期缩短到 10 分钟了。\n\n\n# jwt 适用场景\n\n适用于 server-to-server 类型的服务。比如我们开发了一套 api，想对外提供服务，那么可以采用 jwt token 和 refresh token 机制。\n\n适用于移动端 app 中的接口，因为移动端 app 可以把 token 存储在移动端内部，而不依赖 localstorage。\n\n\n# 服务器端让 jwt token 失效\n\n除了采用 refresh token 和 access token 这种方案以外，还可以采用黑名单机制。正常的 cookieid 可以理解为白名单机制，每次判断这个 cookieid 是不是合法的 cookieid 时，都需要从 redis 中查询一次，只有查询到数据就说明这个 cookieid 是合法的。\n\n类似的道理，当需要废弃一个 jwt token 时，我们可以把这个 token 假如到 redis 中作为黑名单。这样每次判断一个 jwt token 是否合法时，除了判断 token 本身是否合法以外，还需要去黑名单中查询一次。如果黑名单中有这个 token，那么就返回 token 已失效。\n\n当然黑名单中的 token 生存时间至少要比 jwt token 剩余时间要长，简单一点可以直接统一设置为 token 的有效期。\n\n\n# 参考文档\n\nis it safe to store a jwt in localstorage with reactjs?\n\nauth0 token storage\n\n大聪明方案\n\nsame site 属性解释\n\njwt authentication: best practices and when to use it\n\n中肯的建议",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"vite支持decorator",frontmatter:{title:"vite支持decorator",date:"2022-01-25T14:10:36.000Z",permalink:"/pages/b11568/",sidebar:"auto",categories:["随笔"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/vite%E6%94%AF%E6%8C%81decorator.html",relativePath:"_posts/vite支持decorator.md",key:"v-2c9d4562",path:"/pages/b11568/",headers:[{level:2,title:"官方态度",slug:"官方态度",normalizedTitle:"官方态度",charIndex:2},{level:2,title:"walkaround",slug:"walkaround",normalizedTitle:"walkaround",charIndex:164},{level:2,title:"遗憾",slug:"遗憾",normalizedTitle:"遗憾",charIndex:325},{level:2,title:"参考文章",slug:"参考文章",normalizedTitle:"参考文章",charIndex:407}],headersStr:"官方态度 walkaround 遗憾 参考文章",content:'# 官方态度\n\n因为 vite 是强依赖 esbuild 的，而 esbuild 的最大特性就是速度快，所以也不愿意支持完整的 typescript type checker。\n\n导致 vite 不能和 reflect-metadata 一起使用，比较有名的框架包括 typeorm，nestjs 等都不能很好的结合。\n\n\n# walkaround\n\n因为 vite 是依赖 esbuild 和 rollup 的，所以可以寻找相应的 esbuild 插件和 rollup 插件。\n\n基本思路就是完全使用 swc/tsc 代替 esbuild。或者使用了装饰器的文件让 swc/tsc 处理，其他文件让 esbuild 来处理，这样速度更快。\n\n\n# 遗憾\n\n目前的在线 demo 网站，比如 codesandbox 和 stackblitz 基本都支持 vite 了，但是都还不支持 decorator。\n\n\n# 参考文章\n\n极速 DX: Vite + Electron + esbuild vite 项目支持 typescript 的 emitDecoratorMetadata 和 experimentalDecorators Support emitting typescript decorator metadata decorators not support in js for prebuild Ask for support of decortors in jsx! How do i enable "@babel/plugin-proposal-decorators" with vite vite react 项目中使用装饰器 开启 decorators-legacy Why can\'t reflect-metadata be used in vite Reconsider about using swc as JS/TS transformer',normalizedContent:'# 官方态度\n\n因为 vite 是强依赖 esbuild 的，而 esbuild 的最大特性就是速度快，所以也不愿意支持完整的 typescript type checker。\n\n导致 vite 不能和 reflect-metadata 一起使用，比较有名的框架包括 typeorm，nestjs 等都不能很好的结合。\n\n\n# walkaround\n\n因为 vite 是依赖 esbuild 和 rollup 的，所以可以寻找相应的 esbuild 插件和 rollup 插件。\n\n基本思路就是完全使用 swc/tsc 代替 esbuild。或者使用了装饰器的文件让 swc/tsc 处理，其他文件让 esbuild 来处理，这样速度更快。\n\n\n# 遗憾\n\n目前的在线 demo 网站，比如 codesandbox 和 stackblitz 基本都支持 vite 了，但是都还不支持 decorator。\n\n\n# 参考文章\n\n极速 dx: vite + electron + esbuild vite 项目支持 typescript 的 emitdecoratormetadata 和 experimentaldecorators support emitting typescript decorator metadata decorators not support in js for prebuild ask for support of decortors in jsx! how do i enable "@babel/plugin-proposal-decorators" with vite vite react 项目中使用装饰器 开启 decorators-legacy why can\'t reflect-metadata be used in vite reconsider about using swc as js/ts transformer',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"代理方案调研",frontmatter:{sidebar:"auto",title:"代理方案调研",date:"2021-12-23T21:27:25.000Z",permalink:"/pages/7dfa32/",categories:["随笔","技术"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/%E4%BB%A3%E7%90%86%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94.html",relativePath:"_posts/代理方案调研.md",key:"v-964a6848",path:"/pages/7dfa32/",headers:[{level:2,title:"使用 charles 和 fiddle",slug:"使用-charles-和-fiddle",normalizedTitle:"使用 charles 和 fiddle",charIndex:151},{level:2,title:"使用 anyproxy",slug:"使用-anyproxy",normalizedTitle:"使用 anyproxy",charIndex:319},{level:2,title:"建议使用 mitmproxy",slug:"建议使用-mitmproxy",normalizedTitle:"建议使用 mitmproxy",charIndex:656},{level:2,title:"对于 wireshark 和 tcpdump",slug:"对于-wireshark-和-tcpdump",normalizedTitle:"对于 wireshark 和 tcpdump",charIndex:888}],headersStr:"使用 charles 和 fiddle 使用 anyproxy 建议使用 mitmproxy 对于 wireshark 和 tcpdump",content:"目前抓包软件总体可以分为两类：\n\n * 一种是设置代理抓取 http 包，比如 charles 和 fiddle，以及 mitmproxy 和 anyproxy。\n\n * 另一种是直接抓取经过网卡的所有协议包，比如 tcpdump、wireshark、tshark、httpry、ngrep。\n\n\n# 使用 charles 和 fiddle\n\nmacos 常用 charles，windows 常用 fiddle。\n\nmacos 支持断点功能，可以修改请求以及返回值。并且支持 map local 和 map remote。\n\n但是最大的缺陷是不能区分 options 请求和 GET/POST 请求。导致以上功能完全不能使用。\n\n\n# 使用 anyproxy\n\n因为 anyproxy 可以手动创建规则，可以通过编程来处理请求和返回值，这样就可以方便的区分 options 请求和 GET/POST 请求。\n\n警告\n\n实际情况比较复杂。\n\n比如在 ios14，ios15 的 safari 浏览器中都不能正常解析 https 请求。 另外一台 ios13 则可以正常解析 https 请求，使用的也是 safari 浏览器。\n\n比如在小米手机自带的浏览器中，就算手机已经安装了证书，该浏览器还是不信任证书，这个真是大无语事件。 但是在小米手机上的 UC 浏览器中就可以正常访问。所以建议不要使用自带的浏览器。\n\n总体上来看还是可以使用的。\n\n有想法做一个可视化界面来配置代理规则，而不用手动写代码了。\n\n\n# 建议使用 mitmproxy\n\nmitmproxy 和 anyproxy 比较类似，主要是语言方面的区别，mitmproxy 是 python 语言开发的，anyproxy 是 nodejs 开发的。另外 mitmproxy 目前仍然在积极维护，但是 anyproxy 似乎不再维护了。\n\ncharles 和 fiddle 是自带客户端的，anyproxy 和 mitmproxy 是通过 web GUI 和命令行来显示抓包数据的。这里更加推荐命令行的。\n\n\n# 对于 wireshark 和 tcpdump\n\n如果想要抓取非 http 的包，或者在服务器上直接抓包，可以使用这些工具。",normalizedContent:"目前抓包软件总体可以分为两类：\n\n * 一种是设置代理抓取 http 包，比如 charles 和 fiddle，以及 mitmproxy 和 anyproxy。\n\n * 另一种是直接抓取经过网卡的所有协议包，比如 tcpdump、wireshark、tshark、httpry、ngrep。\n\n\n# 使用 charles 和 fiddle\n\nmacos 常用 charles，windows 常用 fiddle。\n\nmacos 支持断点功能，可以修改请求以及返回值。并且支持 map local 和 map remote。\n\n但是最大的缺陷是不能区分 options 请求和 get/post 请求。导致以上功能完全不能使用。\n\n\n# 使用 anyproxy\n\n因为 anyproxy 可以手动创建规则，可以通过编程来处理请求和返回值，这样就可以方便的区分 options 请求和 get/post 请求。\n\n警告\n\n实际情况比较复杂。\n\n比如在 ios14，ios15 的 safari 浏览器中都不能正常解析 https 请求。 另外一台 ios13 则可以正常解析 https 请求，使用的也是 safari 浏览器。\n\n比如在小米手机自带的浏览器中，就算手机已经安装了证书，该浏览器还是不信任证书，这个真是大无语事件。 但是在小米手机上的 uc 浏览器中就可以正常访问。所以建议不要使用自带的浏览器。\n\n总体上来看还是可以使用的。\n\n有想法做一个可视化界面来配置代理规则，而不用手动写代码了。\n\n\n# 建议使用 mitmproxy\n\nmitmproxy 和 anyproxy 比较类似，主要是语言方面的区别，mitmproxy 是 python 语言开发的，anyproxy 是 nodejs 开发的。另外 mitmproxy 目前仍然在积极维护，但是 anyproxy 似乎不再维护了。\n\ncharles 和 fiddle 是自带客户端的，anyproxy 和 mitmproxy 是通过 web gui 和命令行来显示抓包数据的。这里更加推荐命令行的。\n\n\n# 对于 wireshark 和 tcpdump\n\n如果想要抓取非 http 的包，或者在服务器上直接抓包，可以使用这些工具。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"代码托管服务总结",frontmatter:{sidebar:"auto",title:"代码托管服务总结",date:"2021-12-22T10:59:21.000Z",permalink:"/pages/3d42c5/",categories:["随笔","技术"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BB%93.html",relativePath:"_posts/代码托管服务总结.md",key:"v-50fdf4f7",path:"/pages/3d42c5/",headers:[{level:2,title:"码云",slug:"码云",normalizedTitle:"码云",charIndex:18},{level:2,title:"码市",slug:"码市",normalizedTitle:"码市",charIndex:115},{level:2,title:"百度云",slug:"百度云",normalizedTitle:"百度云",charIndex:199},{level:2,title:"CSDN 代码托管平台（已关闭）",slug:"csdn-代码托管平台-已关闭",normalizedTitle:"csdn 代码托管平台（已关闭）",charIndex:314},{level:2,title:"github",slug:"github",normalizedTitle:"github",charIndex:359},{level:2,title:"gitlab",slug:"gitlab",normalizedTitle:"gitlab",charIndex:463},{level:2,title:"bitbucket",slug:"bitbucket",normalizedTitle:"bitbucket",charIndex:681},{level:2,title:"google code（已关闭）",slug:"google-code-已关闭",normalizedTitle:"google code（已关闭）",charIndex:776}],headersStr:"码云 码市 百度云 CSDN 代码托管平台（已关闭） github gitlab bitbucket google code（已关闭）",content:"# 国内外代码托管服务总结\n\n\n# 码云\n\n旧网址是 https://git.oschina.net/\n\n新网址是 https://gitee.com\n\n可以看出来背后的公司是开源中国，目前应该是国内最大的代码托管平台。\n\n\n# 码市\n\n背后公司是腾讯云。\n\n虽然本身已经是腾讯云的一个子产品，但是目前至少是有独立域名，而且独立提供服务。\n\n网址是 https://coding.net/\n\n\n# 百度云\n\n这里并不是在推官百度的产品，而是做一个对比。\n\n虽然大家都是代码托管平台，但是到百度云这里已经没有独立域名了。\n\n因为它只是百度云系列产品中普通的一个产品模块而已，只是为百度云提供服务的。\n\n百度云代码托管产品\n\n\n# CSDN 代码托管平台（已关闭）\n\n参考这篇文章，发现该服务已经关闭了。参考文章\n\n\n# github\n\n网址是 https://github.com\n\n这个不用多说，代码托管界的扛把子。\n\n虽然微软也会把 github 和 azure 做整合，但是并不会影响 github 本身的体验。\n\n\n# gitlab\n\n网址是 https://about.gitlab.com/\n\n这个在以前还是比较有用的，因为以前 github 对私有仓库是收费的。而 gitlab 是免费的。但是现在 github 对私有仓库也是免费的。\n\n还有一部分人可能是对微软的产品有抵触情绪，所以不愿意使用 github，可以使用 gitlab。\n\n关键 gitlab 是支持私有化部署的，国内大多数公司的内部代码管理系统应该都是 gitlab 吧。\n\n\n# bitbucket\n\n背后公司是 atlassian。就是开发 jira 和 confluence 的公司。\n\n网址是 https://bitbucket.org/product/\n\n\n# google code（已关闭）\n\n网址是 https://code.google.com/\n\n参考这篇文章",normalizedContent:"# 国内外代码托管服务总结\n\n\n# 码云\n\n旧网址是 https://git.oschina.net/\n\n新网址是 https://gitee.com\n\n可以看出来背后的公司是开源中国，目前应该是国内最大的代码托管平台。\n\n\n# 码市\n\n背后公司是腾讯云。\n\n虽然本身已经是腾讯云的一个子产品，但是目前至少是有独立域名，而且独立提供服务。\n\n网址是 https://coding.net/\n\n\n# 百度云\n\n这里并不是在推官百度的产品，而是做一个对比。\n\n虽然大家都是代码托管平台，但是到百度云这里已经没有独立域名了。\n\n因为它只是百度云系列产品中普通的一个产品模块而已，只是为百度云提供服务的。\n\n百度云代码托管产品\n\n\n# csdn 代码托管平台（已关闭）\n\n参考这篇文章，发现该服务已经关闭了。参考文章\n\n\n# github\n\n网址是 https://github.com\n\n这个不用多说，代码托管界的扛把子。\n\n虽然微软也会把 github 和 azure 做整合，但是并不会影响 github 本身的体验。\n\n\n# gitlab\n\n网址是 https://about.gitlab.com/\n\n这个在以前还是比较有用的，因为以前 github 对私有仓库是收费的。而 gitlab 是免费的。但是现在 github 对私有仓库也是免费的。\n\n还有一部分人可能是对微软的产品有抵触情绪，所以不愿意使用 github，可以使用 gitlab。\n\n关键 gitlab 是支持私有化部署的，国内大多数公司的内部代码管理系统应该都是 gitlab 吧。\n\n\n# bitbucket\n\n背后公司是 atlassian。就是开发 jira 和 confluence 的公司。\n\n网址是 https://bitbucket.org/product/\n\n\n# google code（已关闭）\n\n网址是 https://code.google.com/\n\n参考这篇文章",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"公共服务",frontmatter:{title:"公共服务",date:"2021-12-21T11:39:26.000Z",permalink:"/pages/7426c9/",sidebar:"auto",categories:["随笔","技术"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/%E5%85%AC%E5%85%B1%E6%9C%8D%E5%8A%A1.html",relativePath:"_posts/公共服务.md",key:"v-d38315a6",path:"/pages/7426c9/",headers:[{level:2,title:"最小资源",slug:"最小资源",normalizedTitle:"最小资源",charIndex:2},{level:2,title:"查询 IP",slug:"查询-ip",normalizedTitle:"查询 ip",charIndex:92}],headersStr:"最小资源 查询 IP",content:"# 最小资源\n\n主要作用是用于测试代理是否可用，并且节省流量。\n\n国内某个 204 页面\n\n国内某个 204 页面\n\n国内某个 nginx 欢迎页面\n\n美国某个 204 页面\n\n\n# 查询 IP\n\n国内网站，所以如果本地是智能代理，是不会显示代理 IP，而是真实 IP\n\n国外网站，所以如果本地有代理会显示代理 IP\n\n免费代理 IP",normalizedContent:"# 最小资源\n\n主要作用是用于测试代理是否可用，并且节省流量。\n\n国内某个 204 页面\n\n国内某个 204 页面\n\n国内某个 nginx 欢迎页面\n\n美国某个 204 页面\n\n\n# 查询 ip\n\n国内网站，所以如果本地是智能代理，是不会显示代理 ip，而是真实 ip\n\n国外网站，所以如果本地有代理会显示代理 ip\n\n免费代理 ip",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"删除git中的敏感数据",frontmatter:{title:"删除git中的敏感数据",date:"2022-01-11T14:43:13.000Z",permalink:"/pages/1fac03/",sidebar:"auto",categories:["随笔"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/%E5%88%A0%E9%99%A4git%E4%B8%AD%E7%9A%84%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE.html",relativePath:"_posts/删除git中的敏感数据.md",key:"v-27c99f0a",path:"/pages/1fac03/",headersStr:null,content:"# 删除敏感数据\n\n参考这里\n\n参考这里",normalizedContent:"# 删除敏感数据\n\n参考这里\n\n参考这里",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"刻板印象",frontmatter:{title:"刻板印象",date:"2022-01-07T15:19:42.000Z",permalink:"/pages/c86144/",sidebar:"auto",categories:["随笔"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1.html",relativePath:"_posts/刻板印象.md",key:"v-2b5187de",path:"/pages/c86144/",headersStr:null,content:"# 刻板印象\n\n游戏 老师 科学家\n\n如何看待教育产品游戏化？我觉得没毛病。游戏只是形式，关键是要能学到知识。游戏这种形式反而可以增加学习乐趣，提升学习效率，改变学习是痛苦的刻板形象。\n\n就像科学家就应该是穷苦形象，不能购买奢侈品。\n\n老师就应该被人尊敬，一切行为都是正确的。\n\n我觉得我们应该像尊敬清洁工一样尊敬老师，尊敬的是这份工作，给大家提供的服务。",normalizedContent:"# 刻板印象\n\n游戏 老师 科学家\n\n如何看待教育产品游戏化？我觉得没毛病。游戏只是形式，关键是要能学到知识。游戏这种形式反而可以增加学习乐趣，提升学习效率，改变学习是痛苦的刻板形象。\n\n就像科学家就应该是穷苦形象，不能购买奢侈品。\n\n老师就应该被人尊敬，一切行为都是正确的。\n\n我觉得我们应该像尊敬清洁工一样尊敬老师，尊敬的是这份工作，给大家提供的服务。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"前端和后端的思考",frontmatter:{title:"前端和后端的思考",date:"2022-03-09T20:38:19.000Z",permalink:"/pages/2ac946/",sidebar:"auto",categories:["随笔"],tags:[null],showSidebar:!1},regularPath:"/_posts/%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF%E7%9A%84%E6%80%9D%E8%80%83.html",relativePath:"_posts/前端和后端的思考.md",key:"v-2ad5ddba",path:"/pages/2ac946/",headers:[{level:2,title:"后端",slug:"后端",normalizedTitle:"后端",charIndex:2},{level:2,title:"前端",slug:"前端",normalizedTitle:"前端",charIndex:919}],headersStr:"后端 前端",content:'# 后端\n\n最近使用 midwayjs 开发了一个后端的项目。这里记录一下遇到的问题。\n\n# 中间件\n\n可以处理用户鉴权，以及修改 request，返回固定格式的 response。\n\n# 过滤器\n\n主要是统一处理异常，因为公司是通过标准输出来收集异常日志，所以并不需要专门的 logger。可以直接使用console.log。\n\n当然还可以使用 sentry 的 api 主动上报日志。\n\n# 批量处理\n\n通常如果是执行一个任务，我们可以直接返回任务执行是成功了，还是失败了。但是如果该接口是批量执行一批任务，那么就会涉及到有些任务执行成功，有些任务执行失败。主要是此时接口状态只能是成功，然后返回数据中包含两个数组。\n\n{\n  "errCode": 0,\n  "data": {\n    "successResult": [],\n    "failedResult": []\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 服务\n\n服务可以相互注入，但是最终会得到一个网状的依赖关系。更关键的是，因为任意一个服务都能访问到其他服务，导致有些逻辑代码不知道写在哪里合适，或者说写到哪里都合适。\n\n建议把服务分成两种类型。\n\n基础类型服务：此时的服务没有依赖其他服务，只能操作自己的数据和操作数据库。 业务类型服务：此时的服务依赖多个基础类型服务。可以实现复杂的业务逻辑。\n\n控制器：其实本来控制器应该承担业务类型服务的角色，但是我发现，在控制器里面出现大量的具体的业务逻辑非常不利于维护和复用。控制器中只适用于逻辑路由和数据校验。\n\n逻辑路由：应该在控制器中做具体的逻辑路由。\n\nif (flag1) {\n  return doSomething1();\n} else if (flag2) {\n  return doSomething2();\n} else {\n  return doSomething3();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n逻辑组合：应该在业务类型的服务中实现具体的业务逻辑。\n\ndoSomething1();\ndoSomething2();\ndoSomething3();\n\n\n1\n2\n3\n\n\n\n# 前端\n\n前端最重要的就是快速实现 monorepo 来管理代码。当然也不是全部都要 monorepo，关键还是看场景。\n\n比如类似 antd 和 element-ui 这样的统一 UI 库，实际上并不是 monorepo，这是因为这些组件是统一发版的。当然也可以采用 monorepo 来管理。\n\n如果是公司内部的组件库，最好还是每个组件单独发版，这种场景比较合适 monorepo。\n\n像赛事系统还有模块化系统这种复杂的多项目系统，最好也是采用 monorepo 来维护，因为这样可以在不同项目之间共享一些代码。',normalizedContent:'# 后端\n\n最近使用 midwayjs 开发了一个后端的项目。这里记录一下遇到的问题。\n\n# 中间件\n\n可以处理用户鉴权，以及修改 request，返回固定格式的 response。\n\n# 过滤器\n\n主要是统一处理异常，因为公司是通过标准输出来收集异常日志，所以并不需要专门的 logger。可以直接使用console.log。\n\n当然还可以使用 sentry 的 api 主动上报日志。\n\n# 批量处理\n\n通常如果是执行一个任务，我们可以直接返回任务执行是成功了，还是失败了。但是如果该接口是批量执行一批任务，那么就会涉及到有些任务执行成功，有些任务执行失败。主要是此时接口状态只能是成功，然后返回数据中包含两个数组。\n\n{\n  "errcode": 0,\n  "data": {\n    "successresult": [],\n    "failedresult": []\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 服务\n\n服务可以相互注入，但是最终会得到一个网状的依赖关系。更关键的是，因为任意一个服务都能访问到其他服务，导致有些逻辑代码不知道写在哪里合适，或者说写到哪里都合适。\n\n建议把服务分成两种类型。\n\n基础类型服务：此时的服务没有依赖其他服务，只能操作自己的数据和操作数据库。 业务类型服务：此时的服务依赖多个基础类型服务。可以实现复杂的业务逻辑。\n\n控制器：其实本来控制器应该承担业务类型服务的角色，但是我发现，在控制器里面出现大量的具体的业务逻辑非常不利于维护和复用。控制器中只适用于逻辑路由和数据校验。\n\n逻辑路由：应该在控制器中做具体的逻辑路由。\n\nif (flag1) {\n  return dosomething1();\n} else if (flag2) {\n  return dosomething2();\n} else {\n  return dosomething3();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n逻辑组合：应该在业务类型的服务中实现具体的业务逻辑。\n\ndosomething1();\ndosomething2();\ndosomething3();\n\n\n1\n2\n3\n\n\n\n# 前端\n\n前端最重要的就是快速实现 monorepo 来管理代码。当然也不是全部都要 monorepo，关键还是看场景。\n\n比如类似 antd 和 element-ui 这样的统一 ui 库，实际上并不是 monorepo，这是因为这些组件是统一发版的。当然也可以采用 monorepo 来管理。\n\n如果是公司内部的组件库，最好还是每个组件单独发版，这种场景比较合适 monorepo。\n\n像赛事系统还有模块化系统这种复杂的多项目系统，最好也是采用 monorepo 来维护，因为这样可以在不同项目之间共享一些代码。',charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"名言金句",frontmatter:{sidebar:"auto",title:"名言金句",date:"2021-12-26T20:01:07.000Z",permalink:"/pages/de158a/",categories:["随笔","生活"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/%E5%90%8D%E8%A8%80%E9%87%91%E5%8F%A5.html",relativePath:"_posts/名言金句.md",key:"v-13888698",path:"/pages/de158a/",headersStr:null,content:"我想起下乡插队时分配粮食的张队长。\n\n手气和脚气为什么差别那么大？\n\n外包的优势在于弹性扩容。",normalizedContent:"我想起下乡插队时分配粮食的张队长。\n\n手气和脚气为什么差别那么大？\n\n外包的优势在于弹性扩容。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"小规模纳税人报税",frontmatter:{title:"小规模纳税人报税",date:"2022-03-06T21:34:30.000Z",permalink:"/pages/925b67/",sidebar:"auto",categories:["随笔"],tags:[null],showSidebar:!1},regularPath:"/_posts/%E5%B0%8F%E8%A7%84%E6%A8%A1%E7%BA%B3%E7%A8%8E%E4%BA%BA%E6%8A%A5%E7%A8%8E.html",relativePath:"_posts/小规模纳税人报税.md",key:"v-266ce9eb",path:"/pages/925b67/",headersStr:null,content:"620121198803277521\n\n可以在网上税务局里面查询企业核定的税种以及申报方式。\n\n增值税 《增值税纳税申报表（小规模纳税人适用）》\n\n企业所得税和非居民企业所得税(包括季报和年报) 季度：《居民企业所得税月（季）度预缴纳税申报表（A类，2021年版）》 年报：《中华人民共和国企业所得税年度纳税申报表（A类）》（A100000）\n\n2013版财务报表 季度：小企业会计准则财务报表报送与信息采集 年报：小企业会计准则财务报表报送与信息采集\n\n城建税、教育费附加、地方教育附加税（费）申报表 《城建税、教育费附加、地方教育附加税（费）申报表》\n\n印花税 《印花税申报》\n\n非税（包括残保金、工会经费、非税收入） 《残疾人就业保障金缴费申报》\n\n为什么没有个人所得税。每个月申报。\n\nhttp://zhejiang.chinatax.gov.cn/ https://etax.chinatax.gov.cn/withholding/index.html#/withholding/statistics_home/statistics_company 客户端只有window版本的，没有mac版本的，但是有web端\n\n还有工商年报。\n\n2021-01-05 财务报表（小企业会计准则） 2021-01-05 增值税及附加税（费）申报（小规模纳税人适用） 2021-01-05 城建税、教育费附加、地方教育附加税（费）申报表 2021-01-05 居民企业所得税月（季）度预缴纳税申报（A类，2018版）\n\n2021-04-08 财务报表（小企业会计准则） 2021-04-08 增值税及附加税（费）申报（小规模纳税人适用） 2021-04-08 城建税、教育费附加、地方教育附加税（费）申报表 2021-04-08 居民企业所得税月（季）度预缴纳税申报表（A类，2021年版） 2021-04-08 年度财务报表2013(小企业会计准则) 2021-04-08 中华人民共和国企业所得税年度纳税申报表（A类、2017年版）\n\n2021-07-02 财务报表（小企业会计准则） 2021-07-02 增值税及附加税（费）申报（小规模纳税人适用） 2021-07-02 城建税、教育费附加、地方教育附加税（费）申报表 2021-07-02 居民企业所得税月（季）度预缴纳税申报表（A类，2021年版） 2021-07-02 印花税税源采集 2021-07-02 财产和行为税纳税申报表\n\n2021-10-26 财务报表（小企业会计准则） 2021-10-26 增值税及附加税（费）申报（小规模纳税人适用） 2021-10-26 居民企业所得税月（季）度预缴纳税申报表（A类，2021年版） 2021-10-26 印花税税源采集 2021-10-26 财产和行为税纳税申报表\n\n2021-12-16 残疾人就业保障金缴费申报\n\n2022-01-18 财务报表（小企业会计准则） 2022-01-18 增值税及附加税（费）申报（小规模纳税人适用） 2022-01-18 居民企业所得税月（季）度预缴纳税申报表（A类，2021年版） 2022-01-18 印花税税源采集 2022-01-18 财产和行为税纳税申报表",normalizedContent:"620121198803277521\n\n可以在网上税务局里面查询企业核定的税种以及申报方式。\n\n增值税 《增值税纳税申报表（小规模纳税人适用）》\n\n企业所得税和非居民企业所得税(包括季报和年报) 季度：《居民企业所得税月（季）度预缴纳税申报表（a类，2021年版）》 年报：《中华人民共和国企业所得税年度纳税申报表（a类）》（a100000）\n\n2013版财务报表 季度：小企业会计准则财务报表报送与信息采集 年报：小企业会计准则财务报表报送与信息采集\n\n城建税、教育费附加、地方教育附加税（费）申报表 《城建税、教育费附加、地方教育附加税（费）申报表》\n\n印花税 《印花税申报》\n\n非税（包括残保金、工会经费、非税收入） 《残疾人就业保障金缴费申报》\n\n为什么没有个人所得税。每个月申报。\n\nhttp://zhejiang.chinatax.gov.cn/ https://etax.chinatax.gov.cn/withholding/index.html#/withholding/statistics_home/statistics_company 客户端只有window版本的，没有mac版本的，但是有web端\n\n还有工商年报。\n\n2021-01-05 财务报表（小企业会计准则） 2021-01-05 增值税及附加税（费）申报（小规模纳税人适用） 2021-01-05 城建税、教育费附加、地方教育附加税（费）申报表 2021-01-05 居民企业所得税月（季）度预缴纳税申报（a类，2018版）\n\n2021-04-08 财务报表（小企业会计准则） 2021-04-08 增值税及附加税（费）申报（小规模纳税人适用） 2021-04-08 城建税、教育费附加、地方教育附加税（费）申报表 2021-04-08 居民企业所得税月（季）度预缴纳税申报表（a类，2021年版） 2021-04-08 年度财务报表2013(小企业会计准则) 2021-04-08 中华人民共和国企业所得税年度纳税申报表（a类、2017年版）\n\n2021-07-02 财务报表（小企业会计准则） 2021-07-02 增值税及附加税（费）申报（小规模纳税人适用） 2021-07-02 城建税、教育费附加、地方教育附加税（费）申报表 2021-07-02 居民企业所得税月（季）度预缴纳税申报表（a类，2021年版） 2021-07-02 印花税税源采集 2021-07-02 财产和行为税纳税申报表\n\n2021-10-26 财务报表（小企业会计准则） 2021-10-26 增值税及附加税（费）申报（小规模纳税人适用） 2021-10-26 居民企业所得税月（季）度预缴纳税申报表（a类，2021年版） 2021-10-26 印花税税源采集 2021-10-26 财产和行为税纳税申报表\n\n2021-12-16 残疾人就业保障金缴费申报\n\n2022-01-18 财务报表（小企业会计准则） 2022-01-18 增值税及附加税（费）申报（小规模纳税人适用） 2022-01-18 居民企业所得税月（季）度预缴纳税申报表（a类，2021年版） 2022-01-18 印花税税源采集 2022-01-18 财产和行为税纳税申报表",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"德州扑克之夜",frontmatter:{title:"德州扑克之夜",date:"2021-12-31T22:46:43.000Z",permalink:"/pages/1d6b00/",sidebar:"auto",categories:["随笔","生活"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/%E5%BE%B7%E5%B7%9E%E6%89%91%E5%85%8B%E4%B9%8B%E5%A4%9C.html",relativePath:"_posts/德州扑克之夜.md",key:"v-f4156710",path:"/pages/1d6b00/",headersStr:null,content:"# 难忘的德州扑克之夜\n\n提示\n\n果然以后自信心爆棚的时候，就来一场德州扑克吧，然后就能清楚的认清自己了。\n\n今天是 2021 年 12 月 31 日，没想到在 2021 年的最后一天，参加了公司的德州扑克。\n\n今天玩的是 5/10 的局，一手是 50 个大盲，就是 500 块，总共输了 3 手，就是 1500 元。\n\n说实话还是挺心疼的。在回家的路上，媳妇跟我说想吃樱桃，但是不舍得吃，要 80 多一斤呢。内心就更加后悔了。\n\n回家吃着手里的猪蹄子，感叹 1500 块可以吃多少猪蹄子了，然后又喝了一大杯酸奶，又想到这 1500 块可以喝 100 多杯酸奶了。\n\n不过德州扑克确实是我一直心心念念想玩的游戏了。\n\n有一段时间，一直在手机上玩的德州扑克，然后还看了不少文章喝视频，确实非常迷这个。\n\n虽然在手机上玩这个游戏，总是输多赢少。总是在低端局慢慢攒钱，然后在高端局输得飞起。一直在重复这个过程，总结自己的缺点就是不能控制自己的行为。总是被游戏氛围带动，盲目的跟注以及 all in。\n\n我自我觉得自己洞察到了赌博的奥秘。赌博是非常容易上头的。\n\n当你拿到一手好牌的时候，当你堵到最后一张河牌时，当你是天同花时，当你是天顺时，你会心跳加速。\n\n当你投入了很多筹码，对手也一直跟注的时候。\n\n当你 bluf 对手，但是对手一直跟注时。\n\n所有的一切都是因为筹码再也不是真实的人民币，而只是达到输出形象的工具。\n\n2个大盲说明我有好牌，10个大盲说明我有非常好的牌。all in就是为了说明牌桌上我最大。\n\n至于10个大盲到底是多少人民币，当时的我是不会关心的。\n\n以前在手机上玩的都是虚拟币。所以一直想着能线下玩。但是陌生人组的局是万万不能参加的。和公司的同事玩一玩，心理上更加容易接受一些。\n\n虽然如此，今天在这里确实犯了 2 个错误。\n\n第一个错误是不能随意和陌生人玩德州扑克，虽然大家都是同事，但是并不了解大家的竞技水平。\n\n第二个错误是不应该参与自己不能承受的大额局，我还是适合 1/2 的局，这样算下来，一晚上的输赢应该不会超过 1000 元了。\n\n我一直深刻的知道玩德州扑克，一定不能上头，一旦上头了，就没有办法控制自己的行为，就会胡乱的 all in。再多的本金也会输掉。\n\n但是我还是不能控制住自己的行为，而且本身玩的非常紧，个人形象非常的单一。\n\n今天写下这篇总结，倒也不是说做自我反思。只是做一下纪念。\n\n虽然不至于以后都不再玩德州扑克了，但是至少最近几年是不会再碰这个了。\n\n我知道德州扑克很有意思，但是不适合我。",normalizedContent:"# 难忘的德州扑克之夜\n\n提示\n\n果然以后自信心爆棚的时候，就来一场德州扑克吧，然后就能清楚的认清自己了。\n\n今天是 2021 年 12 月 31 日，没想到在 2021 年的最后一天，参加了公司的德州扑克。\n\n今天玩的是 5/10 的局，一手是 50 个大盲，就是 500 块，总共输了 3 手，就是 1500 元。\n\n说实话还是挺心疼的。在回家的路上，媳妇跟我说想吃樱桃，但是不舍得吃，要 80 多一斤呢。内心就更加后悔了。\n\n回家吃着手里的猪蹄子，感叹 1500 块可以吃多少猪蹄子了，然后又喝了一大杯酸奶，又想到这 1500 块可以喝 100 多杯酸奶了。\n\n不过德州扑克确实是我一直心心念念想玩的游戏了。\n\n有一段时间，一直在手机上玩的德州扑克，然后还看了不少文章喝视频，确实非常迷这个。\n\n虽然在手机上玩这个游戏，总是输多赢少。总是在低端局慢慢攒钱，然后在高端局输得飞起。一直在重复这个过程，总结自己的缺点就是不能控制自己的行为。总是被游戏氛围带动，盲目的跟注以及 all in。\n\n我自我觉得自己洞察到了赌博的奥秘。赌博是非常容易上头的。\n\n当你拿到一手好牌的时候，当你堵到最后一张河牌时，当你是天同花时，当你是天顺时，你会心跳加速。\n\n当你投入了很多筹码，对手也一直跟注的时候。\n\n当你 bluf 对手，但是对手一直跟注时。\n\n所有的一切都是因为筹码再也不是真实的人民币，而只是达到输出形象的工具。\n\n2个大盲说明我有好牌，10个大盲说明我有非常好的牌。all in就是为了说明牌桌上我最大。\n\n至于10个大盲到底是多少人民币，当时的我是不会关心的。\n\n以前在手机上玩的都是虚拟币。所以一直想着能线下玩。但是陌生人组的局是万万不能参加的。和公司的同事玩一玩，心理上更加容易接受一些。\n\n虽然如此，今天在这里确实犯了 2 个错误。\n\n第一个错误是不能随意和陌生人玩德州扑克，虽然大家都是同事，但是并不了解大家的竞技水平。\n\n第二个错误是不应该参与自己不能承受的大额局，我还是适合 1/2 的局，这样算下来，一晚上的输赢应该不会超过 1000 元了。\n\n我一直深刻的知道玩德州扑克，一定不能上头，一旦上头了，就没有办法控制自己的行为，就会胡乱的 all in。再多的本金也会输掉。\n\n但是我还是不能控制住自己的行为，而且本身玩的非常紧，个人形象非常的单一。\n\n今天写下这篇总结，倒也不是说做自我反思。只是做一下纪念。\n\n虽然不至于以后都不再玩德州扑克了，但是至少最近几年是不会再碰这个了。\n\n我知道德州扑克很有意思，但是不适合我。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"我要做商城",frontmatter:{title:"我要做商城",date:"2022-01-12T10:11:33.000Z",permalink:"/pages/46bf00/",sidebar:"auto",categories:["随笔"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/%E6%88%91%E8%A6%81%E5%81%9A%E5%95%86%E5%9F%8E.html",relativePath:"_posts/我要做商城.md",key:"v-ab5313be",path:"/pages/46bf00/",headers:[{level:2,title:"电商能力是一种很重要的基建能力",slug:"电商能力是一种很重要的基建能力",normalizedTitle:"电商能力是一种很重要的基建能力",charIndex:448},{level:2,title:"我要做商城",slug:"我要做商城-2",normalizedTitle:"我要做商城",charIndex:2},{level:2,title:"其他商城",slug:"其他商城",normalizedTitle:"其他商城",charIndex:833}],headersStr:"电商能力是一种很重要的基建能力 我要做商城 其他商城",content:"# 我要做商城\n\n头条做电商是因为已经有大量的流量。需要精细化的运营这些流量。\n\n在没有电商之前，这些流量的运营方式就是卖广告位。技术的任务就是通过优化推荐系统，推荐更加适合的广告内容给用户，提升广告转化率。这样就有更多的广告主来投广告。\n\n问题是无论怎么优化，一定有一部分利润被广告主分走了。比如用户花了 100 元购买了一块肥皂。头条赚了 30 元，广告主也就是商家赚了 70 元，除去成本 50 元，净赚 20 元利润。\n\n这里的例子不太好，容易误解为头条是追求更多的利润才开始做电商的。虽然我一开始是这么理解的。\n\n后来头条就自己建商城，自己招商，自己做活动。从宏观上来看，这和原来没有区别呀，还是卖广告，只不过以前是卖信息流广告，是一种通用广告，现在是卖电商广告。毕竟淘宝和京东都是靠广告费盈利的，是正宗的广告公司。\n\n既然如此，那么头条为什么不自己做商家，自己卖东西呢？我理解是专业的事情还是专业的人来做。没有必要把所有利润都吃掉。就算是京东自营也不是完全意义上的自营电商。\n\n\n# 电商能力是一种很重要的基建能力\n\n不管是西瓜视频，还是抖音电商，还是 tiktok 的小黄车。现在都接入了电商的能力。\n\n这样才能随时随地一边看直播、看视频，一边直接下单。给用户提供更好的使用体验。 同时给公司带来盈利能力，同时也可以收集更多的用户数据，虽然不愿意，但是消费数据确实可以更加描述用户的画像。\n\n其实我理解这里还是在卖广告流量，只不过和信息流中的广告位不一样，广告是和视频绑定，是和某个直播绑定。\n\n\n# 我要做商城\n\n我们做电商，还需要花钱买流量。现在的流量本来就贵，能把 roi 做正就很不容易了。\n\n其实我更想说的是，技术和产品在这里能做的不多，绝对不是把下单按钮改成红色，然后再改成蓝色就能提升 GMV 的，也不是把两步下单改为一步下单就能提升转化率的。毕竟淘宝都已经做了这么久了，整个下单流程已经很稳定了。\n\n那么拼夕夕是怎么成功的呢？\n\n\n# 其他商城\n\n# 企业商城\n\n企业内部商城，一般可以卖一些公司的周边。\n\n# 积分商城\n\n很多 app 都会带有积分系统，用户攒够一定的积分，就可以兑换商品，一般在兑换的时候，还可以积分+钱一起优化购买。\n\n# 外贸商城\n\n那种一看就是外贸商城，一般只卖一种商品，或者一类商品。面向海外用户。看起来比较高大上。\n\ndemo1\n\ndemo2\n\n# 小程序商城\n\n比如这里的 NUTRIPACKS，中文名是橘袋。现在有一些小公司只做小程序。这里的商品好像是海外代购商品。没想到这种业务也可以赚钱。\n\n# 在线教育\n\n在线教育购买课程，一般会在官网导流到微信的公众号或者小程序中下单。其他流量来源包括进校合作，线下机构合作，投放广告，转介绍。 到这里已经不太像商城了，基本就是一个 H5 页面一个商品。更像是一个 H5 表单，只不过接入了支付能力，可以完成支付功能。",normalizedContent:"# 我要做商城\n\n头条做电商是因为已经有大量的流量。需要精细化的运营这些流量。\n\n在没有电商之前，这些流量的运营方式就是卖广告位。技术的任务就是通过优化推荐系统，推荐更加适合的广告内容给用户，提升广告转化率。这样就有更多的广告主来投广告。\n\n问题是无论怎么优化，一定有一部分利润被广告主分走了。比如用户花了 100 元购买了一块肥皂。头条赚了 30 元，广告主也就是商家赚了 70 元，除去成本 50 元，净赚 20 元利润。\n\n这里的例子不太好，容易误解为头条是追求更多的利润才开始做电商的。虽然我一开始是这么理解的。\n\n后来头条就自己建商城，自己招商，自己做活动。从宏观上来看，这和原来没有区别呀，还是卖广告，只不过以前是卖信息流广告，是一种通用广告，现在是卖电商广告。毕竟淘宝和京东都是靠广告费盈利的，是正宗的广告公司。\n\n既然如此，那么头条为什么不自己做商家，自己卖东西呢？我理解是专业的事情还是专业的人来做。没有必要把所有利润都吃掉。就算是京东自营也不是完全意义上的自营电商。\n\n\n# 电商能力是一种很重要的基建能力\n\n不管是西瓜视频，还是抖音电商，还是 tiktok 的小黄车。现在都接入了电商的能力。\n\n这样才能随时随地一边看直播、看视频，一边直接下单。给用户提供更好的使用体验。 同时给公司带来盈利能力，同时也可以收集更多的用户数据，虽然不愿意，但是消费数据确实可以更加描述用户的画像。\n\n其实我理解这里还是在卖广告流量，只不过和信息流中的广告位不一样，广告是和视频绑定，是和某个直播绑定。\n\n\n# 我要做商城\n\n我们做电商，还需要花钱买流量。现在的流量本来就贵，能把 roi 做正就很不容易了。\n\n其实我更想说的是，技术和产品在这里能做的不多，绝对不是把下单按钮改成红色，然后再改成蓝色就能提升 gmv 的，也不是把两步下单改为一步下单就能提升转化率的。毕竟淘宝都已经做了这么久了，整个下单流程已经很稳定了。\n\n那么拼夕夕是怎么成功的呢？\n\n\n# 其他商城\n\n# 企业商城\n\n企业内部商城，一般可以卖一些公司的周边。\n\n# 积分商城\n\n很多 app 都会带有积分系统，用户攒够一定的积分，就可以兑换商品，一般在兑换的时候，还可以积分+钱一起优化购买。\n\n# 外贸商城\n\n那种一看就是外贸商城，一般只卖一种商品，或者一类商品。面向海外用户。看起来比较高大上。\n\ndemo1\n\ndemo2\n\n# 小程序商城\n\n比如这里的 nutripacks，中文名是橘袋。现在有一些小公司只做小程序。这里的商品好像是海外代购商品。没想到这种业务也可以赚钱。\n\n# 在线教育\n\n在线教育购买课程，一般会在官网导流到微信的公众号或者小程序中下单。其他流量来源包括进校合作，线下机构合作，投放广告，转介绍。 到这里已经不太像商城了，基本就是一个 h5 页面一个商品。更像是一个 h5 表单，只不过接入了支付能力，可以完成支付功能。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"技术内容",frontmatter:{sidebar:"auto",title:"技术内容",date:"2021-12-30T13:45:40.000Z",permalink:"/pages/cd1a6e/",categories:["随笔","技术"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/%E6%8A%80%E6%9C%AF%E5%86%85%E5%AE%B9.html",relativePath:"_posts/技术内容.md",key:"v-1ab3ab88",path:"/pages/cd1a6e/",headersStr:null,content:"# 技术内容\n\n一切技术文章，比如：git，shell，操作系统，编译器，计算机网络。",normalizedContent:"# 技术内容\n\n一切技术文章，比如：git，shell，操作系统，编译器，计算机网络。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"生活内容",frontmatter:{sidebar:"auto",title:"生活内容",date:"2021-12-30T13:44:07.000Z",permalink:"/pages/4c0878/",categories:["随笔","生活"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/%E7%94%9F%E6%B4%BB%E5%86%85%E5%AE%B9.html",relativePath:"_posts/生活内容.md",key:"v-4a1889c6",path:"/pages/4c0878/",headersStr:null,content:"# 生活内容\n\n鸡汤，吐槽，笑话，头脑风暴。\n\n只要不是技术分章，都是生活内容。",normalizedContent:"# 生活内容\n\n鸡汤，吐槽，笑话，头脑风暴。\n\n只要不是技术分章，都是生活内容。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"电影观看记录",frontmatter:{sidebar:"auto",title:"电影观看记录",date:"2021-12-26T18:16:08.000Z",permalink:"/pages/67fd5e/",categories:["随笔","生活"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/%E7%94%B5%E5%BD%B1%E8%A7%82%E7%9C%8B%E8%AE%B0%E5%BD%95.html",relativePath:"_posts/电影观看记录.md",key:"v-540c7b98",path:"/pages/67fd5e/",headers:[{level:2,title:"动画电影",slug:"动画电影",normalizedTitle:"动画电影",charIndex:16},{level:2,title:"动画短片",slug:"动画短片",normalizedTitle:"动画短片",charIndex:41}],headersStr:"动画电影 动画短片",content:"# 记录所有观看的电影\n\n\n# 动画电影\n\n寻梦环游记\n\n哈尔的移动城堡\n\n\n# 动画短片\n\n鹬\n\n月神\n\n洞穴\n\n温暖的 Bilby》\n\n暴力云与送子鹤\n\n云在天边\n\n不太喜欢这个动画，作者强行安排的剧情过多，逻辑不够自然顺畅。\n\n尽管我们的手中空无一物\n\n闹钟\n\n狐狸和老鼠\n\n鸟的故事\n\n如果我是英雄\n\n美丽的蝴蝶\n\n海螺与鲸鱼 1\n\n海螺与鲸鱼 2\n\n勿忘我\n\n非常好的表现了老年痴呆的世界。\n\nAlike\n\n无论如何我爱你\n\nIf anything happens I love you. 剧情非常流畅。\n\n熊的故事\n\n致杰拉德\n\n出柜 Out\n\n我亲爱的\n\n庸才 Run of the Mill (1999)\n\n失物招领\n\n团结就是力量\n\n低头人生\n\n包宝宝\n\n雨伞\n\n纸飞机\n\n北极熊 Migrants\n\n雨伞和情书\n\n舍得\n\n无翼鸟\n\n错误的方向，怎么努力都是无用功。\n\n自我欺骗并不能算是成功。\n\n绝大多数人不会为了片刻的灿烂选择放弃生命，当然如果你做了这样的选择，并且清楚自己的选择，我也会尊重并敬佩你的选择。\n\n死神和鹿\n\n冲破天际\n\n村庄\n\n花园派对\n\n老妇人与死神\n\n萌萌死神的培训\n\n昼与夜\n\n借我一生\n\n丢失的皇冠\n\n无嘴人\n\n喂食怪物的老奶奶\n\n美味盛宴\n\n魔术师和兔子",normalizedContent:"# 记录所有观看的电影\n\n\n# 动画电影\n\n寻梦环游记\n\n哈尔的移动城堡\n\n\n# 动画短片\n\n鹬\n\n月神\n\n洞穴\n\n温暖的 bilby》\n\n暴力云与送子鹤\n\n云在天边\n\n不太喜欢这个动画，作者强行安排的剧情过多，逻辑不够自然顺畅。\n\n尽管我们的手中空无一物\n\n闹钟\n\n狐狸和老鼠\n\n鸟的故事\n\n如果我是英雄\n\n美丽的蝴蝶\n\n海螺与鲸鱼 1\n\n海螺与鲸鱼 2\n\n勿忘我\n\n非常好的表现了老年痴呆的世界。\n\nalike\n\n无论如何我爱你\n\nif anything happens i love you. 剧情非常流畅。\n\n熊的故事\n\n致杰拉德\n\n出柜 out\n\n我亲爱的\n\n庸才 run of the mill (1999)\n\n失物招领\n\n团结就是力量\n\n低头人生\n\n包宝宝\n\n雨伞\n\n纸飞机\n\n北极熊 migrants\n\n雨伞和情书\n\n舍得\n\n无翼鸟\n\n错误的方向，怎么努力都是无用功。\n\n自我欺骗并不能算是成功。\n\n绝大多数人不会为了片刻的灿烂选择放弃生命，当然如果你做了这样的选择，并且清楚自己的选择，我也会尊重并敬佩你的选择。\n\n死神和鹿\n\n冲破天际\n\n村庄\n\n花园派对\n\n老妇人与死神\n\n萌萌死神的培训\n\n昼与夜\n\n借我一生\n\n丢失的皇冠\n\n无嘴人\n\n喂食怪物的老奶奶\n\n美味盛宴\n\n魔术师和兔子",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"空间定位法",frontmatter:{title:"空间定位法",date:"2022-02-09T10:03:35.000Z",permalink:"/pages/0e5286/",sidebar:"auto",categories:["随笔"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%BD%8D%E6%B3%95.html",relativePath:"_posts/空间定位法.md",key:"v-70c71972",path:"/pages/0e5286/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:2,title:"市政府",slug:"市政府",normalizedTitle:"市政府",charIndex:215},{level:2,title:"开源项目",slug:"开源项目",normalizedTitle:"开源项目",charIndex:326}],headersStr:"简介 市政府 开源项目",content:"# 简介\n\n这里介绍一种我总结的学习方法。\n\n当我们学习一种全新的事物的时候，总会丈二和尚摸不着头脑，无从下手，不知从何开始学起。\n\n其实我们可以学习盲人摸象，上下左右前后都摸一摸，然后再把大象解刨一下看看里面长啥样，基本就 OK 了。\n\n * 上下：上下级部门\n * 左右：平级部门\n * 前后：该部门历史发展轨迹\n * 中间：该部门包含的子部门\n\n提示\n\n虽然说这种学习方法是我总结的，但我相信一定有人已经总结过了。\n\n\n# 市政府\n\n * 上下：省政府 --\x3e 市政府 --\x3e 县政府\n * 左右：和政府平级的概念大概就是党委了，一般常说党和政府，党领导政府。\n * 前后：市政府在不同朝代的变化。\n * 中间：市政府划分为哪些子部门。\n\n\n# 开源项目\n\n * 上下：当前开源项目被哪些上级项目依赖，同时依赖了哪些下级项目。\n * 左右：完成类似功能的开源项目还有哪些？\n * 前后：该开源项目不同版本有哪些更新？\n * 中间：该开源项目包含哪些子模块，子模块之间是如何通信的？",normalizedContent:"# 简介\n\n这里介绍一种我总结的学习方法。\n\n当我们学习一种全新的事物的时候，总会丈二和尚摸不着头脑，无从下手，不知从何开始学起。\n\n其实我们可以学习盲人摸象，上下左右前后都摸一摸，然后再把大象解刨一下看看里面长啥样，基本就 ok 了。\n\n * 上下：上下级部门\n * 左右：平级部门\n * 前后：该部门历史发展轨迹\n * 中间：该部门包含的子部门\n\n提示\n\n虽然说这种学习方法是我总结的，但我相信一定有人已经总结过了。\n\n\n# 市政府\n\n * 上下：省政府 --\x3e 市政府 --\x3e 县政府\n * 左右：和政府平级的概念大概就是党委了，一般常说党和政府，党领导政府。\n * 前后：市政府在不同朝代的变化。\n * 中间：市政府划分为哪些子部门。\n\n\n# 开源项目\n\n * 上下：当前开源项目被哪些上级项目依赖，同时依赖了哪些下级项目。\n * 左右：完成类似功能的开源项目还有哪些？\n * 前后：该开源项目不同版本有哪些更新？\n * 中间：该开源项目包含哪些子模块，子模块之间是如何通信的？",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"通过api获取npm包的所有版本",frontmatter:{title:"通过api获取npm包的所有版本",date:"2022-01-14T11:30:27.000Z",permalink:"/pages/942cef/",sidebar:"auto",categories:["随笔"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/%E9%80%9A%E8%BF%87api%E8%8E%B7%E5%8F%96npm%E5%8C%85%E7%9A%84%E6%89%80%E6%9C%89%E7%89%88%E6%9C%AC.html",relativePath:"_posts/通过api获取npm包的所有版本.md",key:"v-fb433546",path:"/pages/942cef/",headersStr:null,content:"如果是官方的 npm 仓库，可以直接使用 npm.io 提供的 api。\n\n这里研究的是私有仓库，是通过 Verdaccio 搭建的。\n\n首先能想到的是通过命令行来获取相关数据。\n\nnpm view @someScope/packageName versions --json\n\n\n1\n\n\n但是不太喜欢命令行这种方式，猜测应该是存在相应的 rest api。最终发现是这个 API。\n\nhttps://private.registry.com/@someScope/packageName\n\n\n1\n\n\n当然对于私有包，需要设置 token 来获取数据，注意这里的 token 并不是我们在仓库的官方网站登录后产生的 token。而是在命令行中npm login之后产生的 token，会存储在~/.npmrc 文件中。\n\n需要设置https header\nauthorization: 'Bearer abcdefg123123123123123123123123123'\n\n\n1\n2\n\n\n以上拿就是最终的结论，下面再记录一下调查过程。\n\n首先我想到的是抓包来看看当我执行 npm view 命令时，到底发送了什么 api 请求，这样不就立即搞定了吗？\n\n以前了解到的抓包都是代理抓包，但是我不知道怎么设置终端的代理。\n\n后来调研到可以使用 httpry，ngrep，wireshark。但是都有一个问题就是不能分析 https 的包，就连请求的 URL 都看不见。本来以为不看数据体也行，至少要能看看请求头。最终抓包这个方案行不通。\n\n没有办法，只能去看 npm view 的源代码。分析如下：\n\nnpm 源代码仓库是这里。\n\nnpm view文件再lib/commands/view.js，猜测应该是执行的exec方法，然后调用的是getData方法，然后关键的是packument方法。\n\n注意到 packument 来源于pacote这个 npm 包，所以下载它的源代码。\n\n查看 pacote 的入口文件 index.js，其中 packument 方法依赖 get 方法，get 方法来源fetcher.js文件。\n\nfetcher.js 文件中猜测应该走的是RegistryFetcher这个分支。然后看registry.js这个文件。终于找到了我们需要的packument方法，我们可以在这里打印this.packumentUrl，就能知道实际访问的 api 接口了。\n\n继续观察到其中packument方法依赖fetch方法，本以为这个 fetch 方法就是常用的 fetch 方法，后来发现居然是专用的一个 npm 包npm-registry-fetch。\n\n同样的下载npm-registry-fetch，这里就是一个默认导出，主要是注意到其中的pickRegistry和getHeaders。\n\n分析这两个方法并打印日志，就可以观察到实际使用的是~/.npmrc文件中的 token 作为授权 token，需要注意增加Bearer\b前缀。",normalizedContent:"如果是官方的 npm 仓库，可以直接使用 npm.io 提供的 api。\n\n这里研究的是私有仓库，是通过 verdaccio 搭建的。\n\n首先能想到的是通过命令行来获取相关数据。\n\nnpm view @somescope/packagename versions --json\n\n\n1\n\n\n但是不太喜欢命令行这种方式，猜测应该是存在相应的 rest api。最终发现是这个 api。\n\nhttps://private.registry.com/@somescope/packagename\n\n\n1\n\n\n当然对于私有包，需要设置 token 来获取数据，注意这里的 token 并不是我们在仓库的官方网站登录后产生的 token。而是在命令行中npm login之后产生的 token，会存储在~/.npmrc 文件中。\n\n需要设置https header\nauthorization: 'bearer abcdefg123123123123123123123123123'\n\n\n1\n2\n\n\n以上拿就是最终的结论，下面再记录一下调查过程。\n\n首先我想到的是抓包来看看当我执行 npm view 命令时，到底发送了什么 api 请求，这样不就立即搞定了吗？\n\n以前了解到的抓包都是代理抓包，但是我不知道怎么设置终端的代理。\n\n后来调研到可以使用 httpry，ngrep，wireshark。但是都有一个问题就是不能分析 https 的包，就连请求的 url 都看不见。本来以为不看数据体也行，至少要能看看请求头。最终抓包这个方案行不通。\n\n没有办法，只能去看 npm view 的源代码。分析如下：\n\nnpm 源代码仓库是这里。\n\nnpm view文件再lib/commands/view.js，猜测应该是执行的exec方法，然后调用的是getdata方法，然后关键的是packument方法。\n\n注意到 packument 来源于pacote这个 npm 包，所以下载它的源代码。\n\n查看 pacote 的入口文件 index.js，其中 packument 方法依赖 get 方法，get 方法来源fetcher.js文件。\n\nfetcher.js 文件中猜测应该走的是registryfetcher这个分支。然后看registry.js这个文件。终于找到了我们需要的packument方法，我们可以在这里打印this.packumenturl，就能知道实际访问的 api 接口了。\n\n继续观察到其中packument方法依赖fetch方法，本以为这个 fetch 方法就是常用的 fetch 方法，后来发现居然是专用的一个 npm 包npm-registry-fetch。\n\n同样的下载npm-registry-fetch，这里就是一个默认导出，主要是注意到其中的pickregistry和getheaders。\n\n分析这两个方法并打印日志，就可以观察到实际使用的是~/.npmrc文件中的 token 作为授权 token，需要注意增加bearer\b前缀。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"链接库",frontmatter:{title:"链接库",date:"2022-02-09T10:40:48.000Z",permalink:"/pages/c782dd/",sidebar:"auto",categories:["随笔"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/%E9%93%BE%E6%8E%A5%E5%BA%93.html",relativePath:"_posts/链接库.md",key:"v-0447f706",path:"/pages/c782dd/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2}],headersStr:"简介",content:"# 简介\n\n一般常听说动态链接库和静态链接库。\n\n首先说一说在 java 和 nodejs 中的库，这些库都是以源码或者中间代码存在。\n\n比如在 nodejs 中，npm 包可以发布到 npmjs.com 中，然后使用npm install来下载依赖的第三方 npm 包。而 npm 包中都是源码。\n\n这是因为在执行 nodejs 代码时，执行方式是node xxx.js。注意到 node 命令后是直接使用的 js 源代码，并不存在中间代码。\n\n相对的 java 环境中，假设我们编写了一个简单的 Hello.java 文件，必须要先javac Hello.java编译成Hello.class文件，然后才能执行java Hello。\n\n所以当我们想要发布一个 java 库时，就需要发布成 class 文件。这里需要明确 java 中的 import 和 export 具体规则。\n\n但是如果时 c 或者 c++语言，又不一样了，c 或者 c++是直接编译成机器码的，并不是中间代码。所谓静态链接库是指我们的代码在编译完成后，在链接阶段把依赖的第三方库直接包含进来变成一整个可执行文件。\n\n其缺点是每个程序都有自己的静态链接库，并不会复用。相反动态链接库则是可以复用的，并不会打包进可执行文件。这里涉及到如何寻找动态链接库的机制。公共链接库和私有链接库，链接库如何发布的问题。\n\nLinux 中的动态链接库和静态链接库是干什么的？ - wuxinliulei 的回答 - 知乎",normalizedContent:"# 简介\n\n一般常听说动态链接库和静态链接库。\n\n首先说一说在 java 和 nodejs 中的库，这些库都是以源码或者中间代码存在。\n\n比如在 nodejs 中，npm 包可以发布到 npmjs.com 中，然后使用npm install来下载依赖的第三方 npm 包。而 npm 包中都是源码。\n\n这是因为在执行 nodejs 代码时，执行方式是node xxx.js。注意到 node 命令后是直接使用的 js 源代码，并不存在中间代码。\n\n相对的 java 环境中，假设我们编写了一个简单的 hello.java 文件，必须要先javac hello.java编译成hello.class文件，然后才能执行java hello。\n\n所以当我们想要发布一个 java 库时，就需要发布成 class 文件。这里需要明确 java 中的 import 和 export 具体规则。\n\n但是如果时 c 或者 c++语言，又不一样了，c 或者 c++是直接编译成机器码的，并不是中间代码。所谓静态链接库是指我们的代码在编译完成后，在链接阶段把依赖的第三方库直接包含进来变成一整个可执行文件。\n\n其缺点是每个程序都有自己的静态链接库，并不会复用。相反动态链接库则是可以复用的，并不会打包进可执行文件。这里涉及到如何寻找动态链接库的机制。公共链接库和私有链接库，链接库如何发布的问题。\n\nlinux 中的动态链接库和静态链接库是干什么的？ - wuxinliulei 的回答 - 知乎",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"预渲染原理",frontmatter:{title:"预渲染原理",date:"2022-01-10T16:21:59.000Z",permalink:"/pages/3734eb/",sidebar:"auto",categories:["随笔"],tags:["todo"],showSidebar:!1},regularPath:"/_posts/%E9%A2%84%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86.html",relativePath:"_posts/预渲染原理.md",key:"v-d37c0f4a",path:"/pages/3734eb/",headers:[{level:2,title:"没有想象中的完美",slug:"没有想象中的完美",normalizedTitle:"没有想象中的完美",charIndex:118},{level:2,title:"vue 有没有针对 mount 做优化",slug:"vue-有没有针对-mount-做优化",normalizedTitle:"vue 有没有针对 mount 做优化",charIndex:474},{level:2,title:"对比普通 html 网页",slug:"对比普通-html-网页",normalizedTitle:"对比普通 html 网页",charIndex:576},{level:2,title:"对比 SPA 网页",slug:"对比-spa-网页",normalizedTitle:"对比 spa 网页",charIndex:696}],headersStr:"没有想象中的完美 vue 有没有针对 mount 做优化 对比普通 html 网页 对比 SPA 网页",content:"# 预渲染原理\n\n在网络上搜索预渲染的原理，基本都是在说 webpack 构建完成之后，使用 puppeteer 抓取页面，然后在特定时机保存 html 结果。倒也不是说它不正确。但是我比较关心的是预渲染是怎么提升页面性能的？\n\n\n# 没有想象中的完美\n\n一句话解释就是预渲染只能解决 html 和 css 的问题，不能解决 js 的问题。\n\n实际运行过程是这样的。当用户访问网址时，服务器返回的是带有 html 和 css 内容的 html 文件，这样浏览器就能立即渲染页面了，所以看上去页面加载会很快。\n\n但实际上此时的按钮是没有事件响应的。它必须等到 html 文件中引用的 js 文件加载成功之后，作为一个 SPA 应用，在mount('#app')之后，会完全替换掉<div id=\"app\"></div>中的所有内容。此时相应的按钮才会响应点击事件。\n\n总之就是页面实际上渲染了两次。第一次是服务器端返回的完整的 html 内容。第二次是作为普通的 SPA 应用再次渲染。只有第二次渲染之后页面上的按钮才能响应响应的点击事件。\n\n\n# vue 有没有针对 mount 做优化\n\n我比较好奇就是当el元素中含有内容时，在mount('#app')时有没有复用 dom，还是直接替换的。\n\n目前来看是没有这种优化的，应该就是直接替换。\n\n\n# 对比普通 html 网页\n\n服务器返回 html 内容后，浏览器开始渲染，同时开始下载 js 文件，当 js 文件下载成功后。然后 js 会查找 dom 元素，然后在 dom 上注册事件。\n\n对比来说，这里并不会导致页面重新渲染。\n\n\n# 对比 SPA 网页\n\n服务器返回 html 内容后，一般这里的 html 内容是一个空壳 html，需要等待 js 下载完成后，js 将动态生成的 dom 写入到<div id=\"app\"></div>。\n\n对比来说，这里也是只会渲染一次，但是需要等待 js 下载完成之后才能渲染内容。导致页面白屏的时间较长。",normalizedContent:"# 预渲染原理\n\n在网络上搜索预渲染的原理，基本都是在说 webpack 构建完成之后，使用 puppeteer 抓取页面，然后在特定时机保存 html 结果。倒也不是说它不正确。但是我比较关心的是预渲染是怎么提升页面性能的？\n\n\n# 没有想象中的完美\n\n一句话解释就是预渲染只能解决 html 和 css 的问题，不能解决 js 的问题。\n\n实际运行过程是这样的。当用户访问网址时，服务器返回的是带有 html 和 css 内容的 html 文件，这样浏览器就能立即渲染页面了，所以看上去页面加载会很快。\n\n但实际上此时的按钮是没有事件响应的。它必须等到 html 文件中引用的 js 文件加载成功之后，作为一个 spa 应用，在mount('#app')之后，会完全替换掉<div id=\"app\"></div>中的所有内容。此时相应的按钮才会响应点击事件。\n\n总之就是页面实际上渲染了两次。第一次是服务器端返回的完整的 html 内容。第二次是作为普通的 spa 应用再次渲染。只有第二次渲染之后页面上的按钮才能响应响应的点击事件。\n\n\n# vue 有没有针对 mount 做优化\n\n我比较好奇就是当el元素中含有内容时，在mount('#app')时有没有复用 dom，还是直接替换的。\n\n目前来看是没有这种优化的，应该就是直接替换。\n\n\n# 对比普通 html 网页\n\n服务器返回 html 内容后，浏览器开始渲染，同时开始下载 js 文件，当 js 文件下载成功后。然后 js 会查找 dom 元素，然后在 dom 上注册事件。\n\n对比来说，这里并不会导致页面重新渲染。\n\n\n# 对比 spa 网页\n\n服务器返回 html 内容后，一般这里的 html 内容是一个空壳 html，需要等待 js 下载完成后，js 将动态生成的 dom 写入到<div id=\"app\"></div>。\n\n对比来说，这里也是只会渲染一次，但是需要等待 js 下载完成之后才能渲染内容。导致页面白屏的时间较长。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3},{title:"Home",frontmatter:{home:!0,heroText:"kaokei's blog",tagline:"项目文档，学习笔记，游戏，demo。"},regularPath:"/",relativePath:"index.md",key:"v-ebc99984",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/07/22, 15:37:14",lastUpdatedTimestamp:1658475434e3}],themeConfig:{nav:[{text:"项目文档",link:"/project/",items:[{text:"di",link:"/project/di/"},{text:"use-vue-service",link:"/project/use-vue-service/"},{text:"use-react-service",link:"/project/use-react-service/"},{text:"use-solid-service",link:"/project/use-solid-service/"},{text:"use-svelte-service",link:"/project/use-svelte-service/"}]},{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"},{text:"关于",link:"/about/"}],sidebarDepth:2,logo:"/img/logo.svg",repo:"kaokei/kaokei.github.io",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",docsBranch:"docs",editLinks:!0,editLinkText:"编辑",bodyBgImg:"https://picture.zwc365.com/getbing.jpg",sidebar:{"/00.目录页/":[["00.di.md","di","/project/di"],["01.use-vue-service.md","use-vue-service","/project/use-vue-service"],["02.use-react-service.md","use-react-service","/project/use-react-service"],["03.use-solid-service.md","use-solid-service","/project/use-solid-service"],["99.project.md","项目文档","/project"]],catalogue:{di:"/project/di","use-vue-service":"/project/use-vue-service","use-react-service":"/project/use-react-service","use-solid-service":"/project/use-solid-service",project:"/project"},"/30.项目文档/":[{title:"di",collapsable:!0,children:[["00.di/00.快速开始.md","快速开始","/pages/358991/"],["00.di/01.什么是服务.md","什么是服务","/pages/8dfb90/"],["00.di/02.什么是Provider.md","什么是Provider","/pages/4828a1/"],["00.di/03.什么是Injector.md","什么是Injector","/pages/d699f9/"],["00.di/04.什么是依赖注入.md","什么是依赖注入","/pages/53952f/"],["00.di/80.在服务中注入其他服务.md","在服务中注入其他服务","/pages/b09aca/"],["00.di/90.API文档.md","API文档","/pages/64784b/"],["00.di/91.faq.md","FAQ","/pages/762b47/"],["00.di/92.案例.md","案例","/pages/b3da0e/"],["00.di/93.资源.md","资源","/pages/71016c/"]]},{title:"use-vue-service",collapsable:!0,children:[["01.use-vue-service/00.快速开始.md","快速开始","/pages/46481f/"],["01.use-vue-service/01.基础教程.md","基础教程","/pages/4497fd/"],["01.use-vue-service/02.进阶教程.md","进阶教程","/pages/a03917/"],["01.use-vue-service/03.应用服务化.md","应用服务化","/pages/3a3a6b/"],["01.use-vue-service/04.组件与Injector.md","组件与Injector","/pages/60ce48/"],["01.use-vue-service/90.API文档.md","API文档","/pages/36ae88/"],["01.use-vue-service/91.faq.md","FAQ","/pages/e83ee6/"],["01.use-vue-service/92.案例.md","案例","/pages/c72e25/"],["01.use-vue-service/93.资源.md","资源","/pages/c70da9/"]]},{title:"use-react-service",collapsable:!0,children:[["02.use-react-service/00.快速开始.md","快速开始","/pages/ac9306/"]]},{title:"use-solid-service",collapsable:!0,children:[["03.use-solid-service/00.快速开始.md","快速开始","/pages/550423/"]]},{title:"use-svelte-service",collapsable:!0,children:[["04.use-svelte-service/00.快速开始.md","快速开始","/pages/0129d5/"]]}]},author:{name:"kaokei",link:"https://github.com/kaokei"},blogger:{avatar:"https://cdn.jsdelivr.net/gh/kaokei/static-cdn/logo/white/logo@512.png"},social:{icons:[]},footer:{createYear:2019,copyrightInfo:'kaokei | <a href="https://github.com/kaokei/kaokei.github.io/blob/docs/LICENSE" target="_blank">kaokei License</a> | <a href="https://beian.miit.gov.cn/" target="_blank">京ICP备16051049号</a>'},htmlModules:{}}};var bc=t(94),yc=t(95),xc=t(11);var jc={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(xc.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(xc.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(xc.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,o=n.length;r<o;r++){const{frontmatter:{categories:o,tags:a}}=n[r];"array"===Object(xc.n)(o)&&o.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object(xc.n)(a)&&a.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Ht.component(bc.default),Ht.component(yc.default);function kc(n){return n.toString().padStart(2,"0")}t(237);Ht.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,408))),Ht.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,94))),Ht.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,95)));t(238);var wc={props:{color:{required:!1,default:"rgb(66, 185, 131)"}}},_c=(t(239),Object(mc.a)(wc,(function(){return(0,this._self._c)("div",{staticClass:"spinner",style:{background:this.color}})}),[],!1,null,"1bbcb91a",null).exports);const Sc={name:"Mermaid",props:{id:{type:String,required:!1,default:()=>"diagram_"+Date.now()},graph:{type:String,required:!1}},data:()=>({svg:void 0}),computed:{graphData(){return this.graph?this.graph:this.$slots.default[0].text}},render(n){return void 0===this.svg?n("Loading"):n("div",{class:["mermaid-diagram"],domProps:{innerHTML:this.svg,style:"width: 100%"}})},mounted(){t.e(80).then(t.t.bind(null,328,7)).then(n=>{n.initialize({startOnLoad:!0,gantt:{barHeight:40}}),n.render(this.id,this.graphData,n=>{this.svg=n})})},components:{Loading:_c}};t(240);var Ic=t(93),Ec=t.n(Ic),Cc=t(25);let Tc,Ac;var Pc;"valine"===(Pc="gitalk")?t.e(82).then(t.t.bind(null,329,7)).then(n=>Ac=n.default):"gitalk"===Pc&&Promise.all([t.e(0),t.e(81)]).then(t.t.bind(null,330,7)).then(()=>t.e(79).then(t.t.bind(null,331,7))).then(n=>Tc=n.default);function Oc(n,e){const t={};return Reflect.ownKeys(n).forEach(r=>{if("string"==typeof n[r])try{t[r]=Ec.a.render(n[r],e)}catch(e){console.warn(`Comment config option error at key named "${r}"`),console.warn("More info: "+e.message),t[r]=n[r]}else t[r]=n[r]}),t}console.log(`How to use "gitalk" in ${Cc.name}@v${Cc.version}:`,Cc.homepage);const zc={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new Tc(Oc({clientID:"642d3441487709af2c66",clientSecret:"3f1acfc48e7042fce4204021f6068beeb47fb374",repo:"blog-gitalk-comment",owner:"kaokei",admin:["kaokei"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new Ac({...Oc({clientID:"642d3441487709af2c66",clientSecret:"3f1acfc48e7042fce4204021f6068beeb47fb374",repo:"blog-gitalk-comment",owner:"kaokei",admin:["kaokei"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},$c="vuepress-plugin-comment";let Bc=null;function Lc(n){return zc.gitalk.clear($c)}function Rc(n){return!1!==n.comment&&!1!==n.comments}function Uc(n){clearTimeout(Bc);if(document.querySelector("main.page"))return zc.gitalk.render(n,$c);Bc=setTimeout(()=>Uc(n),200)}var Dc={mounted(){Bc=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};Lc()&&Rc(n)&&Uc(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};Lc()&&Rc(t)&&Uc(t)})}},Mc=Object(mc.a)(Dc,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,Nc=[({Vue:n,options:e,router:t,siteData:r})=>{},({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${kc(n.getUTCMonth()+1)}-${kc(n.getUTCDate())} ${kc(n.getUTCHours())}:${kc(n.getUTCMinutes())}:${kc(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(jc)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},({Vue:n})=>{n.component(Sc.name,Sc)},({Vue:n})=>{n.component("Comment",Mc)},({router:n})=>{"undefined"!=typeof window&&(((n,e)=>{window.dataLayer=window.dataLayer||[],window.gtag=function(){dataLayer.push(arguments)},gtag("js",new Date),gtag("config",e,{anonymize_ip:!0}),function(){var n=document.createElement("script");n.async=1,n.src="https://www.googletagmanager.com/gtag/js?id="+e;var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}(),n.afterEach((function(e){const t=n.app.$withBase(e.fullPath);t&&(gtag("set","page_path",t),gtag("event","page_view"))}))})(n,"G-EYD6NYPT3M"),((n,e)=>{window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.async=1,n.src="https://hm.baidu.com/hm.js?"+e;var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}(),n.afterEach((function(e){const t=n.app.$withBase(e.fullPath);t&&_hmt.push(["_trackPageview",t])}))})(n,"9f9f1c76099d607f81d70747b83af59f"),((n,e,t)=>{!function(){var n=document.createElement("script");n.async=1,n.src="https://s9.cnzz.com/z_stat.php?id="+e+"&web_id="+t;var r=document.getElementsByTagName("script")[0];r.parentNode.insertBefore(n,r)}(),n.afterEach((function(e){if("undefined"!=typeof _czc){const t=n.app.$withBase(e.fullPath);t&&_czc.push(["_trackPageview",t])}}))})(n,"1280697181","1280697181"))}],Fc=["Comment"];class Vc extends class{constructor(){this.store=new Ht({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Ht.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Vc.prototype,{getPageAsyncComponent:as,getLayoutAsyncComponent:is,getAsyncComponent:ss,getVueComponent:cs});var qc={install(n){const e=new Vc;n.$vuepress=e,n.prototype.$vuepress=e}};function Hc(n,e){return n.options.routes.filter(n=>n.path.toLowerCase()===e.toLowerCase()).length>0}var Kc={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return us("pageKey",e),Ht.component(e)||Ht.component(e,as(e)),Ht.component(e)?n(e):n("")}},Zc={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Wc={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Jc=(t(246),t(247),Object(mc.a)(Wc,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Gc={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Ht.config.productionTip=!1,Ht.use(qi),Ht.use(qc),Ht.mixin(function(n,e,t=Ht){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),o=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),a={};return Object.keys(o).reduce((n,e)=>(e.startsWith("$")&&(n[e]=o[e].get),n),a),{computed:a}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},gc)),Ht.component("Content",Kc),Ht.component("ContentSlotsDistributor",Zc),Ht.component("OutboundLink",Jc),Ht.component("ClientOnly",Gc),Ht.component("Layout",is("Layout")),Ht.component("NotFound",is("NotFound")),Ht.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.8.0",hash:"1bda5d0"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:gc.routerBase||gc.base,t=new qi({base:e,mode:"history",fallback:!1,routes:fc,scrollBehavior:(n,e,t)=>t||(n.hash?!Ht.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(Hc(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Hc(n,t)?r(t):r()}else r();else{const t=e.path+"/",o=e.path+".html";Hc(n,o)?r(o):Hc(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(Nc.filter(n=>"function"==typeof n).map(e=>e({Vue:Ht,options:r,router:t,siteData:gc,isServer:n})))}catch(n){console.error(n)}return{app:new Ht(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Fc.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);